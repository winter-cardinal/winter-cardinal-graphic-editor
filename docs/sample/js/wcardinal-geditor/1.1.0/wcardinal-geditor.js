/*
 WinterCardinal Graphic Editor v1.1.0
 Copyright (C) TOSHIBA Coorporation
 SPDX-License-Identifier: Apache-2.0

 Material Design icons by Google
 Apache license version 2.0.
*/
(function (wcardinalUi, pixi_js) {
    'use strict';

    class ECommandComposition extends wcardinalUi.DCommandBase {
        constructor(commands, selection) {
            super();
            this._commands = commands;
            this._selection = selection;
        }
        get commands() {
            return this._commands;
        }
        get selection() {
            return this._selection;
        }
        execute() {
            return true;
        }
        redo() {
            const selection = this._selection;
            const commands = this._commands;
            selection.lock();
            for (let i = 0, imax = commands.length; i < imax; ++i) {
                commands[i].redo();
            }
            selection.unlock();
            return true;
        }
        undo() {
            const selection = this._selection;
            selection.lock();
            const commands = this._commands;
            for (let i = commands.length - 1; 0 <= i; --i) {
                commands[i].undo();
            }
            selection.unlock();
            return true;
        }
        destroy() {
            const commands = this._commands;
            for (let i = 0, imax = commands.length; i < imax; ++i) {
                commands[i].destroy();
            }
        }
    }

    class ECommandDocumentAll extends wcardinalUi.DCommandBase {
        constructor(diagram, canvas, name, label, width, height, category, summary, description, backgroundColor, backgroundAlpha) {
            super();
            this._diagram = diagram;
            this._canvas = canvas;
            this._name = name;
            this._label = label;
            this._width = width;
            this._height = height;
            this._category = category;
            this._summary = summary;
            this._description = description;
            this._backgroundColor = backgroundColor;
            this._backgroundAlpha = backgroundAlpha;
        }
        get diagram() {
            return this._diagram;
        }
        get canvas() {
            return this._canvas;
        }
        get name() {
            return this._name;
        }
        get label() {
            return this._label;
        }
        get width() {
            return this._width;
        }
        get height() {
            return this._height;
        }
        get category() {
            return this._category;
        }
        get summary() {
            return this._summary;
        }
        get description() {
            return this._description;
        }
        get backgroundColor() {
            return this._backgroundColor;
        }
        get backgroundAlpha() {
            return this._backgroundAlpha;
        }
        execute() {
            return this.redo();
        }
        redo() {
            const canvas = this._canvas;
            const name = this._name;
            this._name = canvas.name;
            canvas.name = name;
            const label = this._label;
            this._label = canvas.label;
            canvas.label = label;
            const width = this._width;
            this._width = canvas.width;
            canvas.width = width;
            const height = this._height;
            this._height = canvas.height;
            canvas.height = height;
            const category = this._category;
            this._category = canvas.category;
            canvas.category = category;
            const summary = this._summary;
            this._summary = canvas.summary;
            canvas.summary = summary;
            const description = this._description;
            this._description = canvas.description;
            canvas.description = description;
            const backgroundColor = this._backgroundColor;
            const backgroundAlpha = this._backgroundAlpha;
            const state = new wcardinalUi.DBaseStateSetImpl();
            const background = canvas.background;
            this._backgroundColor = background.getColor(state);
            this._backgroundAlpha = background.getAlpha(state);
            background.color = backgroundColor;
            background.alpha = backgroundAlpha;
            this._diagram.emit("change", this._diagram);
            return true;
        }
        undo() {
            return this.redo();
        }
    }

    class ECommandDocumentBackground extends wcardinalUi.DCommandBase {
        constructor(diagram, color, alpha) {
            super();
            this._diagram = diagram;
            this._color = color;
            this._alpha = alpha;
        }
        get diagram() {
            return this._diagram;
        }
        get color() {
            return this._color;
        }
        get alpha() {
            return this._alpha;
        }
        execute() {
            return this.redo();
        }
        redo() {
            const canvas = this._diagram.canvas;
            if (canvas != null) {
                const background = canvas.background;
                const color = this._color;
                const alpha = this._alpha;
                const state = new wcardinalUi.DBaseStateSetImpl();
                this._color = background.getColor(state);
                this._alpha = background.getAlpha(state);
                background.color = color;
                background.alpha = alpha;
                this._diagram.emit("change", this._diagram);
            }
            return true;
        }
        undo() {
            return this.redo();
        }
    }

    class ECommandDocumentCategory extends wcardinalUi.DCommandBase {
        constructor(diagram, canvas, category) {
            super();
            this._diagram = diagram;
            this._canvas = canvas;
            this._category = category;
        }
        get diagram() {
            return this._diagram;
        }
        get canvas() {
            return this._canvas;
        }
        get category() {
            return this._category;
        }
        execute() {
            return this.redo();
        }
        redo() {
            const canvas = this._canvas;
            const category = this._category;
            this._category = canvas.category;
            canvas.category = category;
            this._diagram.emit("change", this._diagram);
            return true;
        }
        undo() {
            return this.redo();
        }
    }

    class ECommandDocumentCreate extends wcardinalUi.DCommandCreate {
        constructor(diagram, canvas) {
            super();
            this._diagram = diagram;
            this._canvas = canvas;
        }
        get diagram() {
            return this._diagram;
        }
        get canvas() {
            return this._canvas;
        }
        execute() {
            return true;
        }
    }

    class ECommandDocumentDescription extends wcardinalUi.DCommandBase {
        constructor(diagram, canvas, description) {
            super();
            this._diagram = diagram;
            this._canvas = canvas;
            this._description = description;
        }
        get diagram() {
            return this._diagram;
        }
        get canvas() {
            return this._canvas;
        }
        get description() {
            return this._description;
        }
        execute() {
            return this.redo();
        }
        redo() {
            const canvas = this._canvas;
            const description = this._description;
            this._description = canvas.description;
            canvas.description = description;
            this._diagram.emit("change", this._diagram);
            return true;
        }
        undo() {
            return this.redo();
        }
    }

    class ECommandDocumentHeight extends wcardinalUi.DCommandBase {
        constructor(diagram, canvas, height) {
            super();
            this._diagram = diagram;
            this._canvas = canvas;
            this._height = height;
        }
        get diagram() {
            return this._diagram;
        }
        get canvas() {
            return this._canvas;
        }
        get height() {
            return this._height;
        }
        execute() {
            return this.redo();
        }
        redo() {
            const canvas = this._canvas;
            const height = this._height;
            this._height = canvas.height;
            canvas.y = canvas.y + (canvas.height - height) * 0.5;
            canvas.height = height;
            this._diagram.emit("change", this._diagram);
            return true;
        }
        undo() {
            return this.redo();
        }
    }

    class ECommandDocumentLabel extends wcardinalUi.DCommandBase {
        constructor(diagram, canvas, label) {
            super();
            this._diagram = diagram;
            this._canvas = canvas;
            this._label = label;
        }
        get diagram() {
            return this._diagram;
        }
        get canvas() {
            return this._canvas;
        }
        get label() {
            return this._label;
        }
        execute() {
            return this.redo();
        }
        redo() {
            const canvas = this._canvas;
            const label = this._label;
            this._label = canvas.label;
            canvas.label = label;
            this._diagram.emit("change", this._diagram);
            return true;
        }
        undo() {
            return this.redo();
        }
    }

    class ECommandDocumentName extends wcardinalUi.DCommandBase {
        constructor(diagram, canvas, name) {
            super();
            this._diagram = diagram;
            this._canvas = canvas;
            this._name = name;
        }
        get diagram() {
            return this._diagram;
        }
        get canvas() {
            return this._canvas;
        }
        get name() {
            return this._name;
        }
        execute() {
            return this.redo();
        }
        redo() {
            const canvas = this._canvas;
            const name = this._name;
            this._name = canvas.name;
            canvas.name = name;
            this._diagram.emit("change", this._diagram);
            return true;
        }
        undo() {
            return this.redo();
        }
    }

    class ECommandDocumentOpen extends wcardinalUi.DCommandCreate {
        constructor(diagram, canvas) {
            super();
            this._diagram = diagram;
            this._canvas = canvas;
        }
        get diagram() {
            return this._diagram;
        }
        get canvas() {
            return this._canvas;
        }
        execute() {
            return true;
        }
    }

    class ECommandDocumentSnapBringForward extends wcardinalUi.DCommandBase {
        constructor(snapper, index) {
            super();
            this._snapper = snapper;
            this._index = index;
        }
        get snapper() {
            return this._snapper;
        }
        get index() {
            return this._index;
        }
        execute() {
            return this.redo();
        }
        redo() {
            const index = this._index;
            this._snapper.target.swap(index - 1, index);
            return true;
        }
        undo() {
            return this.redo();
        }
    }

    class ECommandDocumentSnapCreate extends wcardinalUi.DCommandBase {
        constructor(snapper, target) {
            super();
            this._snapper = snapper;
            this._target = target;
        }
        get snapper() {
            return this._snapper;
        }
        get target() {
            return this._target;
        }
        execute() {
            return this.redo();
        }
        redo() {
            this._snapper.target.add(this._target);
            return true;
        }
        undo() {
            const target = this._snapper.target;
            target.remove(target.size - 1);
            return true;
        }
    }

    class ECommandDocumentSnapDelete extends wcardinalUi.DCommandBase {
        constructor(snapper, index, target) {
            super();
            this._snapper = snapper;
            this._index = index;
            this._target = target;
        }
        get snapper() {
            return this._snapper;
        }
        get index() {
            return this._index;
        }
        get target() {
            return this._target;
        }
        execute() {
            return this.redo();
        }
        redo() {
            this._snapper.target.remove(this._index);
            return true;
        }
        undo() {
            this._snapper.target.add(this._target, this._index);
            return true;
        }
    }

    class ECommandDocumentSnapGridSize extends wcardinalUi.DCommandBase {
        constructor(snapper, size) {
            super();
            this._snapper = snapper;
            this._size = size;
        }
        get snapper() {
            return this._snapper;
        }
        get size() {
            return this._size;
        }
        execute() {
            return this.redo();
        }
        redo() {
            const snapper = this._snapper;
            const size = this._size;
            this._size = snapper.grid.size;
            snapper.grid.size = size;
            return true;
        }
        undo() {
            return this.redo();
        }
    }

    class ECommandDocumentSnapGridToggleVisibility extends wcardinalUi.DCommandBase {
        constructor(snapper) {
            super();
            this._snapper = snapper;
        }
        get snapper() {
            return this._snapper;
        }
        execute() {
            return this.redo();
        }
        redo() {
            const grid = this._snapper.grid;
            grid.visible = !grid.visible;
            return true;
        }
        undo() {
            return this.redo();
        }
    }

    class ECommandDocumentSnapGridToggle extends wcardinalUi.DCommandBase {
        constructor(snapper) {
            super();
            this._snapper = snapper;
        }
        get snapper() {
            return this._snapper;
        }
        execute() {
            return this.redo();
        }
        redo() {
            const grid = this._snapper.grid;
            grid.enable = !grid.enable;
            return true;
        }
        undo() {
            return this.redo();
        }
    }

    class ECommandDocumentSnapReplace extends wcardinalUi.DCommandBase {
        constructor(snapper, oldValue, newValue, list) {
            super();
            this._snapper = snapper;
            this._oldValue = oldValue;
            this._newValue = newValue;
            this._index = snapper.target.values.indexOf(this._oldValue);
            this._list = list;
        }
        get snapper() {
            return this._snapper;
        }
        get index() {
            return this._index;
        }
        get oldValue() {
            return this._oldValue;
        }
        get newValue() {
            return this._newValue;
        }
        get list() {
            return this._list;
        }
        execute() {
            return this.redo();
        }
        redo() {
            const index = this._index;
            if (0 <= index) {
                const list = this._list;
                const newValue = this._newValue;
                const snapper = this._snapper;
                if (list.data.selection.contains(this._oldValue)) {
                    snapper.target.replace(index, newValue);
                    list.data.selection.clearAndAdd(newValue);
                }
                else {
                    snapper.target.replace(index, newValue);
                }
            }
            return true;
        }
        undo() {
            const index = this._index;
            if (0 <= index) {
                const list = this._list;
                const oldValue = this._oldValue;
                const snapper = this._snapper;
                if (list.data.selection.contains(this._newValue)) {
                    snapper.target.replace(index, oldValue);
                    list.data.selection.clearAndAdd(oldValue);
                }
                else {
                    snapper.target.replace(index, oldValue);
                }
            }
            return true;
        }
    }

    class ECommandDocumentSnapSendBackward extends wcardinalUi.DCommandBase {
        constructor(snapper, index) {
            super();
            this._snapper = snapper;
            this._index = index;
        }
        get snapper() {
            return this._snapper;
        }
        get index() {
            return this._index;
        }
        execute() {
            return this.redo();
        }
        redo() {
            const index = this._index;
            this._snapper.target.swap(index, index + 1);
            return true;
        }
        undo() {
            return this.redo();
        }
    }

    class ECommandDocumentSnapTargetToggleVisibility extends wcardinalUi.DCommandBase {
        constructor(snapper) {
            super();
            this._snapper = snapper;
        }
        get snapper() {
            return this._snapper;
        }
        execute() {
            return this.redo();
        }
        redo() {
            const target = this._snapper.target;
            target.visible = !target.visible;
            return true;
        }
        undo() {
            return this.redo();
        }
    }

    class ECommandDocumentSnapTargetToggle extends wcardinalUi.DCommandBase {
        constructor(snapper) {
            super();
            this._snapper = snapper;
        }
        get snapper() {
            return this._snapper;
        }
        execute() {
            return this.redo();
        }
        redo() {
            const target = this._snapper.target;
            target.enable = !target.enable;
            return true;
        }
        undo() {
            return this.redo();
        }
    }

    class ECommandDocumentSnapToggle extends wcardinalUi.DCommandBase {
        constructor(snapper) {
            super();
            this._snapper = snapper;
        }
        get snapper() {
            return this._snapper;
        }
        execute() {
            return this.redo();
        }
        redo() {
            const snapper = this._snapper;
            snapper.enable = !snapper.enable;
            return true;
        }
        undo() {
            return this.redo();
        }
    }

    class ECommandDocumentSummary extends wcardinalUi.DCommandBase {
        constructor(diagram, canvas, summary) {
            super();
            this._diagram = diagram;
            this._canvas = canvas;
            this._summary = summary;
        }
        get diagram() {
            return this._diagram;
        }
        get canvas() {
            return this._canvas;
        }
        get summary() {
            return this._summary;
        }
        execute() {
            return this.redo();
        }
        redo() {
            const canvas = this._canvas;
            const summary = this._summary;
            this._summary = canvas.summary;
            canvas.summary = summary;
            this._diagram.emit("change", this._diagram);
            return true;
        }
        undo() {
            return this.redo();
        }
    }

    class ECommandDocumentWidth extends wcardinalUi.DCommandBase {
        constructor(diagram, canvas, width) {
            super();
            this._diagram = diagram;
            this._canvas = canvas;
            this._width = width;
        }
        get diagram() {
            return this._diagram;
        }
        get canvas() {
            return this._canvas;
        }
        get width() {
            return this._width;
        }
        execute() {
            return this.redo();
        }
        redo() {
            const canvas = this._canvas;
            const width = this._width;
            this._width = canvas.width;
            canvas.x = canvas.x + (canvas.width - width) * 0.5;
            canvas.width = width;
            this._diagram.emit("change", this._diagram);
            return true;
        }
        undo() {
            return this.redo();
        }
    }

    class ECommandLayerBringForward extends wcardinalUi.DCommandBase {
        constructor(index, layerContainer) {
            super();
            this._index = index;
            this._layerContainer = layerContainer;
        }
        get index() {
            return this._index;
        }
        get layerContainer() {
            return this._layerContainer;
        }
        execute() {
            return this.redo();
        }
        redo() {
            const index = this._index;
            const layerContainer = this._layerContainer;
            const children = layerContainer.children;
            const tmp = children[index];
            children[index] = children[index + 1];
            children[index + 1] = tmp;
            layerContainer.onChildrenChange(index);
            layerContainer.emit("change", layerContainer);
            wcardinalUi.DApplications.update(layerContainer);
            return true;
        }
        undo() {
            this.redo();
            return true;
        }
    }

    class EDialogLayerValueBackground {
        constructor(enable, color, alpha) {
            this.enable = enable;
            this.color = color;
            this.alpha = alpha;
        }
        isEqual(target) {
            return (this.enable === target.enable &&
                this.color === target.color &&
                this.alpha === target.alpha);
        }
        static from(layer) {
            return new EDialogLayerValueBackground(layer.background.enable, layer.background.color, layer.background.alpha);
        }
    }

    class EDialogLayerValue {
        constructor(name, x, y, width, height, background, visible, interactive, gesture) {
            this.name = name;
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            this.background = background;
            this.visible = visible;
            this.interactive = interactive;
            this.gesture = gesture;
        }
        isEqual(target) {
            return (this.name === target.name &&
                this.x === target.x &&
                this.y === target.y &&
                this.width === target.width &&
                this.height === target.height &&
                this.background.isEqual(target.background) &&
                this.visible === target.visible &&
                this.interactive === target.interactive &&
                this.gesture === target.gesture);
        }
        copyTo(layer) {
            layer.name = this.name;
            layer.position.set(this.x, this.y);
            layer.width = this.width;
            layer.height = this.height;
            layer.background.copy(this.background);
            const state = layer.state;
            state.lock();
            state.set(wcardinalUi.EShapeLayerState.INVISIBLE, !this.visible);
            state.set(wcardinalUi.EShapeLayerState.INTERACTIVE, this.interactive);
            const gesture = this.gesture;
            state.set(wcardinalUi.EShapeLayerState.DRAGGABLE, !!(gesture & wcardinalUi.EShapeActionValueGestureOperationType.DRAG));
            state.set(wcardinalUi.EShapeLayerState.PINCHABLE, !!(gesture & wcardinalUi.EShapeActionValueGestureOperationType.PINCH));
            state.unlock();
            return this;
        }
        static from(layer) {
            const drag = layer.state.is(wcardinalUi.EShapeLayerState.DRAGGABLE)
                ? wcardinalUi.EShapeActionValueGestureOperationType.DRAG
                : wcardinalUi.EShapeActionValueGestureOperationType.NONE;
            const pinch = layer.state.is(wcardinalUi.EShapeLayerState.PINCHABLE)
                ? wcardinalUi.EShapeActionValueGestureOperationType.PINCH
                : wcardinalUi.EShapeActionValueGestureOperationType.NONE;
            const gesture = drag | pinch;
            return new EDialogLayerValue(layer.name, layer.position.x, layer.position.y, layer.width, layer.height, EDialogLayerValueBackground.from(layer), !layer.state.is(wcardinalUi.EShapeLayerState.INVISIBLE), layer.state.is(wcardinalUi.EShapeLayerState.INTERACTIVE), gesture);
        }
    }

    class ECommandLayerChange extends wcardinalUi.DCommandBase {
        constructor(layer, value, layerContainer) {
            super();
            this._layer = layer;
            this._layerContainer = layerContainer;
            this._oldValue = EDialogLayerValue.from(layer);
            this._newValue = value;
        }
        get layer() {
            return this._layer;
        }
        get newValue() {
            return this._newValue;
        }
        get oldValue() {
            return this._oldValue;
        }
        get layerContainer() {
            return this._layerContainer;
        }
        execute() {
            return this.redo();
        }
        redo() {
            this._newValue.copyTo(this._layer);
            const layerContainer = this._layerContainer;
            layerContainer.emit("change", layerContainer);
            return true;
        }
        undo() {
            this._oldValue.copyTo(this._layer);
            const layerContainer = this._layerContainer;
            layerContainer.emit("change", layerContainer);
            return true;
        }
    }

    class ECommandLayerCreate extends wcardinalUi.DCommandBase {
        constructor(value, layerContainer, selection) {
            super();
            this._value = value;
            this._layerContainer = layerContainer;
            this._layerActive = layerContainer.active;
            this._layerCreated = null;
            this._selection = selection;
            this._selectionStored = null;
        }
        newLayer(value, layerContainer) {
            const result = layerContainer.create(value.name, true);
            value.copyTo(result);
            return result;
        }
        get value() {
            return this._value;
        }
        get layerContainer() {
            return this._layerContainer;
        }
        get layerActive() {
            return this._layerActive;
        }
        get layerCreated() {
            return this._layerCreated;
        }
        get selection() {
            return this._selection;
        }
        get selectionStored() {
            return this._selectionStored;
        }
        execute() {
            const selection = this._selection;
            if (!selection.isEmpty()) {
                this._selectionStored = selection.store();
                selection.clear();
            }
            else {
                this._selectionStored = null;
            }
            this._layerCreated = this.newLayer(this._value, this._layerContainer);
            this._layerCreated.reference += 1;
            return true;
        }
        redo() {
            const selectionStored = this._selectionStored;
            if (selectionStored != null) {
                this._selection.clear();
            }
            const layerCreated = this._layerCreated;
            if (layerCreated != null) {
                this._layerContainer.attach(layerCreated, true);
            }
            return true;
        }
        undo() {
            const layerCreated = this._layerCreated;
            if (layerCreated != null) {
                this._layerContainer.detach(layerCreated, this._layerActive);
            }
            const selectionStored = this._selectionStored;
            if (selectionStored != null) {
                this._selection.restore(selectionStored);
            }
            return true;
        }
        destroy() {
            const layerCreated = this._layerCreated;
            if (layerCreated != null) {
                layerCreated.reference -= 1;
                if (layerCreated.parent == null && layerCreated.reference <= 0) {
                    layerCreated.destroy();
                }
            }
            this._layerActive = null;
        }
    }

    class ECommandLayerDelete extends wcardinalUi.DCommandBase {
        constructor(layer, layerContainer, selection) {
            super();
            this._layerContainer = layerContainer;
            this._layerActive = layerContainer.active;
            this._layer = layer;
            layer.reference += 1;
            this._layerIndex = -1;
            this._selection = selection;
            this._selectionStored = null;
        }
        get layerContainer() {
            return this._layerContainer;
        }
        get layerActive() {
            return this._layerActive;
        }
        get layer() {
            return this._layer;
        }
        get layerIndex() {
            return this._layerIndex;
        }
        get selection() {
            return this._selection;
        }
        get selectionStored() {
            return this._selectionStored;
        }
        execute() {
            const layer = this._layer;
            const layerContainer = this._layerContainer;
            const selection = this._selection;
            if (layer === layerContainer.active && !selection.isEmpty()) {
                this._selectionStored = selection.store();
                selection.clear();
            }
            else {
                this._selectionStored = null;
            }
            this._layerIndex = layerContainer.delete(layer, true);
            return true;
        }
        redo() {
            if (this._selectionStored != null) {
                this._selection.clear();
            }
            this._layerContainer.delete(this._layer, true);
            return true;
        }
        undo() {
            this._layerContainer.attachAt(this._layer, this._layerIndex, this._layer === this._layerActive);
            if (this._selectionStored != null) {
                this._selection.restore(this._selectionStored);
            }
            return true;
        }
        destroy() {
            const layer = this._layer;
            layer.reference -= 1;
            if (layer.parent == null && layer.reference <= 0) {
                layer.destroy();
            }
            this._layerActive = null;
            this._selectionStored = null;
        }
    }

    class ECommandLayerSendBackward extends wcardinalUi.DCommandBase {
        constructor(index, layerContainer) {
            super();
            this._index = index;
            this._layerContainer = layerContainer;
        }
        get index() {
            return this._index;
        }
        get layerContainer() {
            return this._layerContainer;
        }
        execute() {
            return this.redo();
        }
        redo() {
            const index = this._index;
            const layerContainer = this._layerContainer;
            const children = layerContainer.children;
            const tmp = children[index];
            children[index] = children[index - 1];
            children[index - 1] = tmp;
            layerContainer.onChildrenChange(index);
            layerContainer.emit("change", layerContainer);
            wcardinalUi.DApplications.update(layerContainer);
            return true;
        }
        undo() {
            this.redo();
            return true;
        }
    }

    class ECommandShapeActionValueAdd extends wcardinalUi.DCommandBase {
        constructor(value, selection) {
            super();
            this._selection = selection;
            this._value = value;
        }
        get selection() {
            return this._selection;
        }
        get value() {
            return this._value;
        }
        execute() {
            return this.redo();
        }
        redo() {
            const value = this._value;
            const shapes = this._selection.get();
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                shapes[i].action.add(value);
            }
            this._selection.update("PROPERTY");
            return true;
        }
        undo() {
            const shapes = this._selection.get();
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                shape.action.remove(shape.action.size() - 1);
            }
            this._selection.update("PROPERTY");
            return true;
        }
    }

    class ECommandShapeActionValueBringForward extends wcardinalUi.DCommandBase {
        constructor(target, selection) {
            super();
            this._selection = selection;
            this._target = target;
            this._indices = [];
        }
        get selection() {
            return this._selection;
        }
        get target() {
            return this._target;
        }
        get indices() {
            return this._indices;
        }
        execute() {
            const target = this._target;
            const indices = this._indices;
            const shapes = this._selection.get();
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                const index = shape.action.indexOf(target);
                indices.push(index);
                if (0 < index) {
                    shape.action.swap(index - 1, index);
                }
            }
            this._indices = indices;
            this._selection.update("PROPERTY");
            return true;
        }
        redo() {
            const shapes = this._selection.get();
            const indices = this._indices;
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                const index = indices[i];
                if (0 < index) {
                    shape.action.swap(index - 1, index);
                }
            }
            this._selection.update("PROPERTY");
            return true;
        }
        undo() {
            return this.redo();
        }
    }

    class ECommandShapeActionValueRemove extends wcardinalUi.DCommandBase {
        constructor(target, selection) {
            super();
            this._selection = selection;
            this._target = target;
            this._indices = [];
        }
        get selection() {
            return this._selection;
        }
        get target() {
            return this._target;
        }
        get indices() {
            return this._indices;
        }
        execute() {
            const target = this._target;
            const indices = this._indices;
            const shapes = this._selection.get();
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                const index = shape.action.indexOf(target);
                indices.push(index);
                if (0 <= index) {
                    shape.action.remove(index);
                }
            }
            this._selection.update("PROPERTY");
            return true;
        }
        redo() {
            const indices = this._indices;
            const shapes = this._selection.get();
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                const index = indices[i];
                if (0 <= index) {
                    shape.action.remove(index);
                }
            }
            this._selection.update("PROPERTY");
            return true;
        }
        undo() {
            const target = this._target;
            const indices = this._indices;
            const shapes = this._selection.get();
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                const index = indices[i];
                if (0 <= index) {
                    shape.action.add(target, index);
                }
            }
            this._selection.update("PROPERTY");
            return true;
        }
    }

    class ECommandShapeActionValueReplace extends wcardinalUi.DCommandBase {
        constructor(oldValue, newValue, selection, list) {
            super();
            this._selection = selection;
            this._oldValue = oldValue;
            this._newValue = newValue;
            this._list = list;
            this._indices = [];
            this._oldValues = [];
        }
        get selection() {
            return this._selection;
        }
        get oldValue() {
            return this._oldValue;
        }
        get newValue() {
            return this._newValue;
        }
        get indices() {
            return this._indices;
        }
        get oldValues() {
            return this._oldValues;
        }
        get list() {
            return this._list;
        }
        execute() {
            const oldValue = this._oldValue;
            const newValue = this._newValue;
            const indices = this._indices;
            const oldValues = this._oldValues;
            const shapes = this._selection.get();
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                const index = shape.action.indexOf(oldValue);
                indices.push(index);
                if (0 <= index) {
                    oldValues.push(shape.action.get(index));
                    shape.action.set(index, newValue);
                }
                else {
                    oldValues.push(newValue);
                }
            }
            const list = this._list;
            if (list.data.selection.contains(oldValue)) {
                list.data.selection.clearAndAdd(newValue);
            }
            this._selection.update("PROPERTY");
            return true;
        }
        redo() {
            const newValue = this._newValue;
            const indices = this._indices;
            const shapes = this._selection.get();
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const index = indices[i];
                if (0 <= index) {
                    shapes[i].action.set(index, newValue);
                }
            }
            const list = this._list;
            if (list.data.selection.contains(this._oldValue)) {
                list.data.selection.clearAndAdd(newValue);
            }
            this._selection.update("PROPERTY");
            return true;
        }
        undo() {
            const indices = this._indices;
            const oldValues = this._oldValues;
            const shapes = this._selection.get();
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const index = indices[i];
                if (0 <= index) {
                    shapes[i].action.set(index, oldValues[i]);
                }
            }
            const list = this._list;
            if (list.data.selection.contains(this._newValue)) {
                list.data.selection.clearAndAdd(this._oldValue);
            }
            this._selection.update("PROPERTY");
            return true;
        }
    }

    class ECommandShapeActionValueSendBackward extends wcardinalUi.DCommandBase {
        constructor(target, selection) {
            super();
            this._selection = selection;
            this._target = target;
            const indices = [];
            const shapes = this._selection.get();
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                const action = shape.action;
                const index = action.indexOf(target);
                indices.push(index);
                if (0 <= index && index < action.size() - 1) {
                    action.swap(index + 1, index);
                }
            }
            this._indices = indices;
            this._selection.update("PROPERTY");
        }
        get selection() {
            return this._selection;
        }
        get target() {
            return this._target;
        }
        get indices() {
            return this._indices;
        }
        execute() {
            return true;
        }
        redo() {
            const shapes = this._selection.get();
            const indices = this._indices;
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                const action = shape.action;
                const index = indices[i];
                if (0 <= index && index < action.size() - 1) {
                    action.swap(index + 1, index);
                }
            }
            this._selection.update("PROPERTY");
            return true;
        }
        undo() {
            return this.redo();
        }
    }

    class ECommandShapeCreate extends wcardinalUi.DCommandBase {
        constructor(shapes, parent, selection, select) {
            super();
            this._shapes = shapes;
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                shapes[i].reference += 1;
            }
            this._parent = parent;
            this._selection = selection;
            this._select = select;
        }
        get parent() {
            return this._parent;
        }
        get shapes() {
            return this._shapes;
        }
        get selection() {
            return this._selection;
        }
        get selectionStored() {
            return this._selectionStored;
        }
        get select() {
            return this._select;
        }
        execute() {
            const selection = this._selection;
            selection.lock();
            if (this._select) {
                this._selectionStored = selection.store();
                selection.clearAndAddAll(this._shapes);
            }
            selection.update("TREE");
            selection.unlock();
            return true;
        }
        redo() {
            const shapes = this._shapes;
            const parent = this._parent;
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                shapes[i].attach(parent);
            }
            const selection = this._selection;
            selection.lock();
            if (this._select) {
                selection.clearAndAddAll(shapes);
            }
            selection.update("TREE");
            selection.unlock();
            return true;
        }
        undo() {
            const shapes = this._shapes;
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                shapes[i].detach();
            }
            const selection = this._selection;
            const selectionStored = this._selectionStored;
            selection.lock();
            if (this._select && selectionStored != null) {
                selection.restore(selectionStored);
            }
            selection.update("TREE");
            selection.unlock();
            return true;
        }
        destroy() {
            const shapes = this._shapes;
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                shape.reference -= 1;
                if (shape.parent == null && shape.reference <= 0) {
                    shape.destroy();
                }
            }
        }
    }

    class ECommandShapeDataMappingValueAdd extends wcardinalUi.DCommandBase {
        constructor(value, selection) {
            super();
            this._selection = selection;
            this._value = value;
        }
        get selection() {
            return this._selection;
        }
        get value() {
            return this._value;
        }
        execute() {
            return this.redo();
        }
        redo() {
            const value = this._value;
            const shapes = this._selection.get();
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                if (wcardinalUi.EShapeCapabilities.contains(shape, wcardinalUi.EShapeCapability.DATA_MAPPING)) {
                    shape.data.mapping.add(value);
                }
            }
            this._selection.update("PROPERTY");
            return true;
        }
        undo() {
            const shapes = this._selection.get();
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                if (wcardinalUi.EShapeCapabilities.contains(shape, wcardinalUi.EShapeCapability.DATA_MAPPING)) {
                    const mapping = shape.data.getMapping();
                    if (mapping) {
                        mapping.remove(mapping.size() - 1);
                    }
                }
            }
            this._selection.update("PROPERTY");
            return true;
        }
    }

    class ECommandShapeDataMappingValueBringForward extends wcardinalUi.DCommandBase {
        constructor(target, selection) {
            super();
            this._selection = selection;
            this._target = target;
            const indices = [];
            const shapes = this._selection.get();
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                if (wcardinalUi.EShapeCapabilities.contains(shape, wcardinalUi.EShapeCapability.DATA_MAPPING)) {
                    const mapping = shape.data.getMapping();
                    if (mapping) {
                        const index = mapping.indexOf(target);
                        indices.push(index);
                        if (0 < index) {
                            mapping.swap(index - 1, index);
                        }
                    }
                    else {
                        indices.push(-1);
                    }
                }
                else {
                    indices.push(-1);
                }
            }
            this._indices = indices;
            this._selection.update("PROPERTY");
        }
        get selection() {
            return this._selection;
        }
        get target() {
            return this._target;
        }
        get indices() {
            return this._indices;
        }
        execute() {
            return true;
        }
        redo() {
            const shapes = this._selection.get();
            const indices = this._indices;
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                const index = indices[i];
                if (0 < index) {
                    const mapping = shape.data.getMapping();
                    if (mapping) {
                        mapping.swap(index - 1, index);
                    }
                }
            }
            this._selection.update("PROPERTY");
            return true;
        }
        undo() {
            return this.redo();
        }
    }

    class ECommandShapeDataMappingValueRemove extends wcardinalUi.DCommandBase {
        constructor(target, selection) {
            super();
            this._selection = selection;
            this._target = target;
            const indices = [];
            const shapes = this._selection.get();
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                if (wcardinalUi.EShapeCapabilities.contains(shape, wcardinalUi.EShapeCapability.DATA_MAPPING)) {
                    const mapping = shape.data.getMapping();
                    if (mapping) {
                        const index = mapping.indexOf(target);
                        indices.push(index);
                        if (0 <= index) {
                            mapping.remove(index);
                        }
                    }
                    else {
                        indices.push(-1);
                    }
                }
                else {
                    indices.push(-1);
                }
            }
            this._indices = indices;
            this._selection.update("PROPERTY");
        }
        get selection() {
            return this._selection;
        }
        get target() {
            return this._target;
        }
        get indices() {
            return this._indices;
        }
        execute() {
            return true;
        }
        redo() {
            const shapes = this._selection.get();
            const indices = this._indices;
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                const index = indices[i];
                if (0 <= index) {
                    const mapping = shape.data.getMapping();
                    if (mapping) {
                        mapping.remove(index);
                    }
                }
            }
            this._selection.update("PROPERTY");
            return true;
        }
        undo() {
            const target = this._target;
            const shapes = this._selection.get();
            const indices = this._indices;
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                const index = indices[i];
                if (0 <= index) {
                    const mapping = shape.data.getMapping();
                    if (mapping) {
                        mapping.add(target, index);
                    }
                }
            }
            this._selection.update("PROPERTY");
            return true;
        }
    }

    class ECommandShapeDataMappingValueReplace extends wcardinalUi.DCommandBase {
        constructor(oldValue, newValue, selection, list) {
            super();
            this._selection = selection;
            this._oldValue = oldValue;
            this._newValue = newValue;
            this._list = list;
            const indices = [];
            const oldValues = [];
            const shapes = this._selection.get();
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                if (wcardinalUi.EShapeCapabilities.contains(shape, wcardinalUi.EShapeCapability.DATA_MAPPING)) {
                    const mapping = shape.data.getMapping();
                    if (mapping) {
                        const index = mapping.indexOf(oldValue);
                        indices.push(index);
                        if (0 <= index) {
                            oldValues.push(mapping.get(index));
                            mapping.set(index, newValue);
                        }
                        else {
                            oldValues.push(newValue);
                        }
                    }
                    else {
                        indices.push(-1);
                        oldValues.push(newValue);
                    }
                }
                else {
                    indices.push(-1);
                    oldValues.push(newValue);
                }
            }
            this._indices = indices;
            this._oldValues = oldValues;
            if (list.data.selection.contains(oldValue)) {
                list.data.selection.clearAndAdd(newValue);
            }
            this._selection.update("PROPERTY");
        }
        get selection() {
            return this._selection;
        }
        get oldValue() {
            return this._oldValue;
        }
        get newValue() {
            return this._newValue;
        }
        get indices() {
            return this._indices;
        }
        get oldValues() {
            return this._oldValues;
        }
        get list() {
            return this._list;
        }
        execute() {
            return true;
        }
        redo() {
            const newValue = this._newValue;
            const indices = this._indices;
            const shapes = this._selection.get();
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                const index = indices[i];
                if (0 <= index) {
                    const mapping = shape.data.getMapping();
                    if (mapping) {
                        mapping.set(index, newValue);
                    }
                }
            }
            const list = this._list;
            if (list.data.selection.contains(this._oldValue)) {
                list.data.selection.clearAndAdd(newValue);
            }
            this._selection.update("PROPERTY");
            return true;
        }
        undo() {
            const indices = this._indices;
            const oldValues = this._oldValues;
            const shapes = this._selection.get();
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                const index = indices[i];
                if (0 <= index) {
                    const mapping = shape.data.getMapping();
                    if (mapping) {
                        mapping.set(index, oldValues[i]);
                    }
                }
            }
            const list = this._list;
            if (list.data.selection.contains(this._newValue)) {
                list.data.selection.clearAndAdd(this._oldValue);
            }
            this._selection.update("PROPERTY");
            return true;
        }
    }

    class ECommandShapeDataMappingValueSendBackward extends wcardinalUi.DCommandBase {
        constructor(target, selection) {
            super();
            this._selection = selection;
            this._target = target;
            const indices = [];
            const shapes = this._selection.get();
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                if (wcardinalUi.EShapeCapabilities.contains(shape, wcardinalUi.EShapeCapability.DATA_MAPPING)) {
                    const mapping = shape.data.getMapping();
                    if (mapping) {
                        const index = mapping.indexOf(target);
                        indices.push(index);
                        if (0 <= index && index < mapping.size() - 1) {
                            mapping.swap(index + 1, index);
                        }
                    }
                    else {
                        indices.push(-1);
                    }
                }
                else {
                    indices.push(-1);
                }
            }
            this._indices = indices;
            this._selection.update("PROPERTY");
        }
        get selection() {
            return this._selection;
        }
        get target() {
            return this._target;
        }
        get indices() {
            return this._indices;
        }
        execute() {
            return true;
        }
        redo() {
            const shapes = this._selection.get();
            const indices = this._indices;
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                const index = indices[i];
                const mapping = shape.data.getMapping();
                if (mapping && 0 <= index && index < mapping.size() - 1) {
                    mapping.swap(index + 1, index);
                }
            }
            this._selection.update("PROPERTY");
            return true;
        }
        undo() {
            return this.redo();
        }
    }

    class ECommandShapeDataValueAdd extends wcardinalUi.DCommandBase {
        constructor(value, selection) {
            super();
            this._selection = selection;
            this._value = value;
        }
        get selection() {
            return this._selection;
        }
        get value() {
            return this._value;
        }
        execute() {
            return this.redo();
        }
        redo() {
            const value = this._value;
            const shapes = this._selection.get();
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                shapes[i].data.add(value);
            }
            this._selection.update("PROPERTY");
            return true;
        }
        undo() {
            const shapes = this._selection.get();
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                shape.data.remove(shape.data.size() - 1);
            }
            this._selection.update("PROPERTY");
            return true;
        }
    }

    class ECommandShapeDataValueBringForward extends wcardinalUi.DCommandBase {
        constructor(target, selection) {
            super();
            this._selection = selection;
            this._target = target;
            const indices = [];
            const shapes = this._selection.get();
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                const index = shape.data.indexOf(target);
                indices.push(index);
                if (0 < index) {
                    shape.data.swap(index - 1, index);
                }
            }
            this._indices = indices;
            this._selection.update("PROPERTY");
        }
        get selection() {
            return this._selection;
        }
        get target() {
            return this._target;
        }
        get indices() {
            return this._indices;
        }
        execute() {
            return true;
        }
        redo() {
            const shapes = this._selection.get();
            const indices = this._indices;
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                const index = indices[i];
                if (0 < index) {
                    shape.data.swap(index - 1, index);
                }
            }
            this._selection.update("PROPERTY");
            return true;
        }
        undo() {
            return this.redo();
        }
    }

    class ECommandShapeDataValueRemove extends wcardinalUi.DCommandBase {
        constructor(target, selection) {
            super();
            this._selection = selection;
            this._target = target;
            const indices = [];
            const shapes = this._selection.get();
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                const index = shape.data.indexOf(target);
                indices.push(index);
                if (0 <= index) {
                    shape.data.remove(index);
                }
            }
            this._indices = indices;
            this._selection.update("PROPERTY");
        }
        get selection() {
            return this._selection;
        }
        get target() {
            return this._target;
        }
        get indices() {
            return this._indices;
        }
        execute() {
            return true;
        }
        redo() {
            const indices = this._indices;
            const shapes = this._selection.get();
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                const index = indices[i];
                if (0 <= index) {
                    shape.data.remove(index);
                }
            }
            this._selection.update("PROPERTY");
            return true;
        }
        undo() {
            const target = this._target;
            const indices = this._indices;
            const shapes = this._selection.get();
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                const index = indices[i];
                if (0 <= index) {
                    shape.data.add(target, index);
                }
            }
            this._selection.update("PROPERTY");
            return true;
        }
    }

    class ECommandShapeDataValueReplace extends wcardinalUi.DCommandBase {
        constructor(oldValue, newValue, selection, list) {
            super();
            this._selection = selection;
            this._oldValue = oldValue;
            this._newValue = newValue;
            this._list = list;
            const indices = [];
            const oldValues = [];
            const shapes = this._selection.get();
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                const index = shape.data.indexOf(oldValue);
                indices.push(index);
                if (0 <= index) {
                    oldValues.push(shape.data.get(index));
                    shape.data.set(index, newValue);
                }
                else {
                    oldValues.push(newValue);
                }
            }
            this._indices = indices;
            this._oldValues = oldValues;
            if (list.data.selection.contains(oldValue)) {
                list.data.selection.clearAndAdd(newValue);
            }
            this._selection.update("PROPERTY");
        }
        get selection() {
            return this._selection;
        }
        get oldValue() {
            return this._oldValue;
        }
        get newValue() {
            return this._newValue;
        }
        get indices() {
            return this._indices;
        }
        get oldValues() {
            return this._oldValues;
        }
        get list() {
            return this._list;
        }
        execute() {
            return true;
        }
        redo() {
            const newValue = this._newValue;
            const indices = this._indices;
            const shapes = this._selection.get();
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const index = indices[i];
                if (0 <= index) {
                    shapes[i].data.set(index, newValue);
                }
            }
            const list = this._list;
            if (list.data.selection.contains(this._oldValue)) {
                list.data.selection.clearAndAdd(newValue);
            }
            this._selection.update("PROPERTY");
            return true;
        }
        undo() {
            const indices = this._indices;
            const oldValues = this._oldValues;
            const shapes = this._selection.get();
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const index = indices[i];
                if (0 <= index) {
                    shapes[i].data.set(index, oldValues[i]);
                }
            }
            const list = this._list;
            if (list.data.selection.contains(this._newValue)) {
                list.data.selection.clearAndAdd(this._oldValue);
            }
            this._selection.update("PROPERTY");
            return true;
        }
    }

    class ECommandShapeDataValueSendBackward extends wcardinalUi.DCommandBase {
        constructor(target, selection) {
            super();
            this._selection = selection;
            this._target = target;
            const indices = [];
            const shapes = this._selection.get();
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                const data = shape.data;
                const index = data.indexOf(target);
                indices.push(index);
                if (0 <= index && index < data.size() - 1) {
                    data.swap(index + 1, index);
                }
            }
            this._indices = indices;
            this._selection.update("PROPERTY");
        }
        get selection() {
            return this._selection;
        }
        get target() {
            return this._target;
        }
        get indices() {
            return this._indices;
        }
        execute() {
            return true;
        }
        redo() {
            const shapes = this._selection.get();
            const indices = this._indices;
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                const data = shape.data;
                const index = indices[i];
                if (0 <= index && index < data.size() - 1) {
                    data.swap(index + 1, index);
                }
            }
            this._selection.update("PROPERTY");
            return true;
        }
        undo() {
            return this.redo();
        }
    }

    /**
     * {@link EShape} search utility.
     */
    class UtilShapeSearch {
        /**
         * Returns indices of the given shapes.
         *
         * @param shapes shapes
         * @return indices
         */
        static toIndices(shapes) {
            const result = [];
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                result.push(shapes[i].index);
            }
            return result;
        }
        /**
         * Returns a depth of the given shape.
         *
         * @param shape a shape
         * @return a depth
         */
        static toDepth(shape) {
            let result = 0;
            let parent = shape.parent;
            while (parent instanceof wcardinalUi.EShapeBase) {
                result += 1;
                parent = parent.parent;
            }
            return result;
        }
        /**
         * Returns a deepest shape on the path to the given shapes.
         *
         * @param shapeA a shape
         * @param shapeB a shape
         * @return a found shape
         */
        static toSharedParent(shapeA, shapeB) {
            const depthA = this.toDepth(shapeA);
            const depthB = this.toDepth(shapeB);
            if (depthA < depthB) {
                let parent = shapeA.parent;
                while (parent instanceof wcardinalUi.EShapeBase) {
                    if (this.isParent(shapeB, parent)) {
                        return parent;
                    }
                    parent = parent.parent;
                }
                return parent;
            }
            else {
                let parent = shapeB.parent;
                while (parent instanceof wcardinalUi.EShapeBase) {
                    if (this.isParent(shapeA, parent)) {
                        return parent;
                    }
                    parent = parent.parent;
                }
                return parent;
            }
        }
        /**
         * Returns a shape on the path to the given shape whose parent is equals to the given parent.
         * If there is no such shape, returns a root shape on the path.
         *
         * @param shape a shape
         * @param parent a parent
         * @returns a found shape
         */
        static toOfParent(shape, parent) {
            let shapeParent = shape.parent;
            while (shapeParent !== parent && shapeParent instanceof wcardinalUi.EShapeBase) {
                shape = shapeParent;
                shapeParent = shapeParent.parent;
            }
            return shape;
        }
        /**
         * Returns true if the given target is on the path to the given shape.
         *
         * @param shape a shape
         * @param target a check target
         * @return true if the given target is on the path to the given shape
         */
        static isParent(shape, target) {
            let parent = shape.parent;
            while (parent instanceof wcardinalUi.EShapeBase) {
                if (parent === target) {
                    return true;
                }
                parent = parent.parent;
            }
            return false;
        }
        /**
         * Returns a selected shape on the path to the given shape.
         * If there are more than one selected shapes, returns a deepest selected shape.
         *
         * @param shape a shape
         * @return a found selected shape or null
         */
        static toSelected(shape) {
            let target = shape;
            while (target instanceof wcardinalUi.EShapeBase) {
                if (target.selected) {
                    return target;
                }
                target = target.parent;
            }
            return null;
        }
        static findChildById(shape, id, recursively) {
            const children = shape.children;
            for (let i = 0, imax = children.length; i < imax; ++i) {
                const child = children[i];
                if (child.id === id) {
                    return child;
                }
                if (recursively === true) {
                    const result = UtilShapeSearch.findChildById(child, id, recursively);
                    if (result != null) {
                        return result;
                    }
                }
            }
            return null;
        }
        static findChildByType(shape, type, recursively) {
            const children = shape.children;
            for (let i = 0, imax = children.length; i < imax; ++i) {
                const child = children[i];
                if (child.type === type) {
                    return child;
                }
                if (recursively === true) {
                    const result = UtilShapeSearch.findChildByType(child, type, recursively);
                    if (result != null) {
                        return result;
                    }
                }
            }
            return null;
        }
        static findChild(shape, matcher, recursively) {
            const children = shape.children;
            for (let i = 0, imax = children.length; i < imax; ++i) {
                const child = children[i];
                if (matcher(child)) {
                    return child;
                }
                if (recursively === true) {
                    const result = UtilShapeSearch.findChild(child, matcher, recursively);
                    if (result != null) {
                        return result;
                    }
                }
            }
            return null;
        }
        static findChildrenByType(shape, type, recursively, result) {
            result = result || [];
            const children = shape.children;
            for (let i = 0, imax = children.length; i < imax; ++i) {
                const child = children[i];
                if (child.type === type) {
                    result.push(child);
                }
                if (recursively === true) {
                    UtilShapeSearch.findChildrenByType(child, type, recursively, result);
                }
            }
            return result;
        }
        static findChildren(shape, matcher, recursively, result) {
            result = result || [];
            const children = shape.children;
            for (let i = 0, imax = children.length; i < imax; ++i) {
                const child = children[i];
                if (matcher(child)) {
                    result.push(child);
                }
                if (recursively === true) {
                    UtilShapeSearch.findChildren(child, matcher, recursively, result);
                }
            }
            return result;
        }
    }
    UtilShapeSearch.COMPARATOR_INDEX = (a, b) => {
        return a.index - b.index;
    };

    class UtilShapeDeleter {
        static addAll(shapes, result) {
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                result.add(shape);
                this.addAll(shape.children, result);
            }
            return result;
        }
        static delete(parent, shapes, generateDeletedShapeList, deletedShapeSet) {
            var _a;
            const children = parent.children;
            const length = children.length;
            // Update indices
            deletedShapeSet !== null && deletedShapeSet !== void 0 ? deletedShapeSet : (deletedShapeSet = (_a = UtilShapeDeleter.EXCEPTIONS) !== null && _a !== void 0 ? _a : (UtilShapeDeleter.EXCEPTIONS = new Set()));
            for (let i = 0; i < length; ++i) {
                const child = children[i];
                if (child.selected) {
                    child.index = length + i;
                    deletedShapeSet.add(child);
                    this.addAll(child.children, deletedShapeSet);
                }
                else {
                    child.index = i;
                }
            }
            // Sort
            children.sort(UtilShapeSearch.COMPARATOR_INDEX);
            // Detach
            if (generateDeletedShapeList === true) {
                for (let i = length - 1; 0 <= i; --i) {
                    const child = children[i];
                    if (child.selected) {
                        child.index -= length;
                        child.parent = null;
                        child.selected = false;
                        child.uploaded = undefined;
                        child.onDetach(deletedShapeSet);
                    }
                    else {
                        if (UtilShapeDeleter.EXCEPTIONS === deletedShapeSet) {
                            deletedShapeSet.clear();
                        }
                        const size = children.length - (i + 1);
                        if (0 < size) {
                            const result = children.splice(i + 1, size);
                            if (shapes != null) {
                                shapes.length = 0;
                            }
                            parent.onChildTransformChange();
                            parent.toDirty();
                            return result;
                        }
                        else {
                            if (shapes != null) {
                                shapes.length = 0;
                            }
                            return null;
                        }
                    }
                }
                if (UtilShapeDeleter.EXCEPTIONS === deletedShapeSet) {
                    deletedShapeSet.clear();
                }
                if (0 < children.length) {
                    const result = children.splice(0, children.length);
                    if (shapes != null) {
                        shapes.length = 0;
                    }
                    parent.onChildTransformChange();
                    parent.toDirty();
                    return result;
                }
                else {
                    if (shapes != null) {
                        shapes.length = 0;
                    }
                    return null;
                }
            }
            else {
                for (let i = length - 1; 0 <= i; --i) {
                    const child = children[i];
                    if (child.selected) {
                        child.parent = null;
                        child.selected = false;
                        child.uploaded = undefined;
                        child.onDetach(deletedShapeSet);
                    }
                    else {
                        if (UtilShapeDeleter.EXCEPTIONS === deletedShapeSet) {
                            deletedShapeSet.clear();
                        }
                        children.length = i + 1;
                        if (shapes != null) {
                            shapes.length = 0;
                        }
                        parent.onChildTransformChange();
                        parent.toDirty();
                        return null;
                    }
                }
                if (UtilShapeDeleter.EXCEPTIONS === deletedShapeSet) {
                    deletedShapeSet.clear();
                }
                if (0 < children.length) {
                    children.length = 0;
                    if (shapes != null) {
                        shapes.length = 0;
                    }
                    parent.onChildTransformChange();
                    parent.toDirty();
                }
                else {
                    if (shapes != null) {
                        shapes.length = 0;
                    }
                }
                return null;
            }
        }
    }

    class ECommandShapeDelete extends wcardinalUi.DCommandBase {
        constructor(shapes, indices, parent, selection, select) {
            super();
            this._shapes = shapes;
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                shapes[i].reference += 1;
            }
            this._indices = indices;
            this._parent = parent;
            this._selection = selection;
            this._select = select;
        }
        get parent() {
            return this._parent;
        }
        get shapes() {
            return this._shapes;
        }
        get indices() {
            return this._indices;
        }
        get selection() {
            return this._selection;
        }
        get select() {
            return this._select;
        }
        execute() {
            return true;
        }
        redo() {
            const selection = this._selection;
            if (this._select) {
                selection.delete(false);
            }
            else {
                const shapes = this._shapes;
                for (let i = 0, imax = shapes.length; i < imax; ++i) {
                    shapes[i].selected = true;
                }
                UtilShapeDeleter.delete(this._parent, undefined, false);
                selection.update("TREE");
            }
            return true;
        }
        undo() {
            const shapes = this._shapes;
            const indices = this._indices;
            const parent = this._parent;
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                shapes[i].attach(parent, indices[i]);
            }
            const selection = this._selection;
            selection.lock();
            if (this._select) {
                selection.clearAndAddAll(shapes);
            }
            selection.update("TREE");
            selection.unlock();
            return true;
        }
        destroy() {
            const shapes = this._shapes;
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                shape.reference -= 1;
                if (shape.parent == null && shape.reference <= 0) {
                    shape.destroy();
                }
            }
            shapes.length = 0;
        }
    }

    class ECommandShapeGroup extends wcardinalUi.DCommandBase {
        constructor(parent, selection) {
            super();
            this._parent = parent;
            this._selection = selection;
            this._before = [];
            this._deleteds = [];
            this._indices = [];
            this._createds = [];
        }
        get parent() {
            return this._parent;
        }
        get selection() {
            return this._selection;
        }
        get before() {
            return this._before;
        }
        get deleteds() {
            return this._deleteds;
        }
        get indices() {
            return this._indices;
        }
        get createds() {
            return this._createds;
        }
        execute() {
            // Save the current selection
            const selection = this._selection;
            this._before = selection.store();
            selection.lock();
            // Unselect shapes that do not have the grouping capability
            const shapes = selection.get();
            for (let i = shapes.length - 1; 0 <= i; --i) {
                const shape = shapes[i];
                if (!wcardinalUi.EShapeCapabilities.contains(shape, wcardinalUi.EShapeCapability.GROUPING)) {
                    shape.selected = false;
                    shapes.splice(i, 1);
                }
            }
            // Delete selected shapes
            const parent = this._parent;
            const deletedSet = new Set();
            const deleteds = UtilShapeDeleter.delete(parent, shapes, true, deletedSet) || [];
            this._deleteds = deleteds;
            for (let i = 0, imax = deleteds.length; i < imax; ++i) {
                deleteds[i].reference += 1;
            }
            // Create a new group
            const modifier = selection.modifier;
            const x = modifier.position.x + modifier.width * 0.5;
            const y = modifier.position.y + modifier.height * 0.5;
            const w = modifier.width;
            const h = modifier.height;
            const group = new wcardinalUi.EShapeGroup(wcardinalUi.EShapeResourceManagerDeserializationMode.EDITOR);
            group.transform.position.set(x, y);
            group.size.set(w, h);
            group.attach(parent);
            const groupChildren = group.children;
            for (let i = 0, imax = deleteds.length; i < imax; ++i) {
                const clone = deleteds[i].clone();
                clone.lock(wcardinalUi.EShapeLockPart.ALL);
                const clonePosition = clone.transform.position;
                clonePosition.set(clonePosition.x - x, clonePosition.y - y);
                if (clone instanceof wcardinalUi.EShapeConnectorLine) {
                    const edge = clone.edge;
                    const tail = edge.tail;
                    const tailAcceptor = tail.acceptor;
                    const tailAcceptorShape = tailAcceptor.shape;
                    const tailLocal = tail.local;
                    if (tailAcceptorShape == null) {
                        tailLocal.set(tailLocal.x - x, tailLocal.y - y);
                    }
                    else if (!deletedSet.has(tailAcceptorShape)) {
                        tailAcceptor.shape = null;
                        tailLocal.set(tailLocal.x - x, tailLocal.y - y);
                    }
                    const head = edge.head;
                    const headAcceptor = head.acceptor;
                    const headAcceptorShape = headAcceptor.shape;
                    const headLocal = head.local;
                    if (headAcceptorShape == null) {
                        headLocal.set(headLocal.x - x, headLocal.y - y);
                    }
                    else if (!deletedSet.has(headAcceptorShape)) {
                        headAcceptor.shape = null;
                        headLocal.set(headLocal.x - x, headLocal.y - y);
                    }
                }
                clone.parent = group;
                groupChildren.push(clone);
            }
            wcardinalUi.EShapeConnectors.moveAll(deleteds, groupChildren, deleteds, groupChildren);
            for (let i = 0, imax = groupChildren.length; i < imax; ++i) {
                groupChildren[i].unlock(wcardinalUi.EShapeLockPart.ALL, true);
            }
            group.onChildTransformChange();
            group.toDirty();
            group.onAttach();
            group.reference += 1;
            this._createds = [group];
            deletedSet.clear();
            // Indices
            this._indices = UtilShapeSearch.toIndices(deleteds);
            // Select a group
            selection.clearAndAddAll(this._createds);
            selection.update("TREE");
            selection.unlock();
            return true;
        }
        redo() {
            // Delete shapes
            const selection = this._selection;
            selection.lock();
            selection.clearAndAddAll(this._deleteds);
            selection.delete(false);
            // Add a group and select it
            const parent = this._parent;
            const createds = this._createds;
            for (let i = 0, imax = createds.length; i < imax; ++i) {
                createds[i].attach(parent);
            }
            // Select created shapes
            selection.update("TREE");
            selection.unlock();
            return true;
        }
        undo() {
            // Delete a group
            const parent = this._parent;
            const selection = this._selection;
            selection.lock();
            const createds = this._createds;
            for (let i = createds.length - 1; 0 <= i; --i) {
                createds[i].detach();
            }
            // Restore deleted shapes
            const deleteds = this._deleteds;
            const indices = this._indices;
            for (let i = 0, imax = deleteds.length; i < imax; ++i) {
                deleteds[i].attach(parent, indices[i]);
            }
            // Restore the selection
            this._selection.restore(this._before);
            selection.update("TREE");
            selection.unlock();
            return true;
        }
        destroy() {
            // Stored selection
            this._before.length = 0;
            // Deleted shapes
            const deleteds = this._deleteds;
            for (let i = 0, imax = deleteds.length; i < imax; ++i) {
                const deleted = deleteds[i];
                deleted.reference -= 1;
                if (deleted.parent == null && deleted.reference <= 0) {
                    deleted.destroy();
                }
            }
            deleteds.length = 0;
            // Created shapes
            const createds = this._createds;
            for (let i = 0, imax = createds.length; i < imax; ++i) {
                const created = createds[i];
                created.reference -= 1;
                if (created.parent == null && created.reference <= 0) {
                    created.destroy();
                }
            }
            createds.length = 0;
        }
    }

    const NONE = 0;
    const PROPERTY = 1;
    const PROPERTY_ID = 2;
    const SELECTION = 4;
    const TREE = 8;
    const EToolSelectSelectionUpdatedPart = {
        NONE,
        PROPERTY,
        PROPERTY_ID,
        SELECTION,
        TREE,
        ALL: PROPERTY | PROPERTY_ID | SELECTION | TREE
    };

    class ECommandShapeProperty extends wcardinalUi.DCommandBase {
        constructor(selection, property, targets = selection.get()) {
            super();
            this._selection = selection;
            this._shapes = [];
            this._capabilities = [];
            this._data = [];
            this._property = property;
            this._targets = targets;
            this._isMerged = false;
        }
        get selection() {
            return this._selection;
        }
        get shapes() {
            return this._shapes;
        }
        get capabilities() {
            return this._capabilities;
        }
        get data() {
            return this._data;
        }
        toCapability(shape) {
            return wcardinalUi.EShapeCapability.ALL;
        }
        isRecursive() {
            return false;
        }
        isMergeable() {
            return false;
        }
        isClassMergeable(target) {
            return target.constructor === this.constructor;
        }
        execute() {
            const shapes = this._shapes;
            const capabilities = this._capabilities;
            const property = this._property;
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                this.initProperty(shapes[i], capabilities[i], property);
            }
            this._selection.update(this.getParts());
            return true;
        }
        init(targets, shapes, capabilities, data, recursive) {
            for (let i = 0, imax = targets.length; i < imax; ++i) {
                const target = targets[i];
                if (recursive && target instanceof wcardinalUi.EShapeGroup) {
                    if (wcardinalUi.EShapeCapabilities.contains(target, wcardinalUi.EShapeCapability.CHILDREN)) {
                        this.init(target.children, shapes, capabilities, data, recursive);
                    }
                }
                else {
                    const capability = this.toCapability(target);
                    if (capability !== wcardinalUi.EShapeCapability.NONE) {
                        shapes.push(target);
                        data.push(this.getProperty(target, capability));
                        capabilities.push(capability);
                    }
                }
            }
        }
        merge(target) {
            if (this.isMergeable() && this.isClassMergeable(target)) {
                this._isMerged = true;
                this._shapes = target.shapes;
                this._capabilities = target.capabilities;
                this._data = target.data;
                return true;
            }
            this.init(this._targets, this._shapes, this._capabilities, this._data, this.isRecursive());
            return false;
        }
        isMerged() {
            return this._isMerged;
        }
        redo() {
            const shapes = this._shapes;
            const data = this._data;
            const capabilities = this._capabilities;
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                const datum = data[i];
                const capability = capabilities[i];
                data[i] = this.getProperty(shape, capability);
                this.setProperty(shape, capability, datum);
            }
            this._selection.update(this.getParts());
            return true;
        }
        undo() {
            return this.redo();
        }
        destroy() {
            this._shapes.length = 0;
            this._data.length = 0;
        }
        getParts() {
            return EToolSelectSelectionUpdatedPart.PROPERTY;
        }
    }

    class ECommandShapePropertyAll extends ECommandShapeProperty {
        constructor(selection) {
            super(selection, undefined);
        }
        toCapability(shape) {
            if (shape instanceof wcardinalUi.EShapeConnectorLine) {
                const edge = shape.edge;
                if (edge.tail.acceptor.shape == null && edge.head.acceptor.shape == null) {
                    return wcardinalUi.EShapeCapability.ALL;
                }
                return wcardinalUi.EShapeCapability.NONE;
            }
            else {
                let result = wcardinalUi.EShapeCapability.NONE;
                if (wcardinalUi.EShapeCapabilities.contains(shape, wcardinalUi.EShapeCapability.POSITION)) {
                    result |= wcardinalUi.EShapeCapability.POSITION;
                }
                if (wcardinalUi.EShapeCapabilities.contains(shape, wcardinalUi.EShapeCapability.WIDTH)) {
                    result |= wcardinalUi.EShapeCapability.WIDTH;
                }
                if (wcardinalUi.EShapeCapabilities.contains(shape, wcardinalUi.EShapeCapability.HEIGHT)) {
                    result |= wcardinalUi.EShapeCapability.HEIGHT;
                }
                if (wcardinalUi.EShapeCapabilities.contains(shape, wcardinalUi.EShapeCapability.ROTATION)) {
                    result |= wcardinalUi.EShapeCapability.ROTATION;
                }
                if (wcardinalUi.EShapeCapabilities.contains(shape, wcardinalUi.EShapeCapability.SKEW)) {
                    result |= wcardinalUi.EShapeCapability.SKEW;
                }
                return result;
            }
        }
        getProperty(shape, capability) {
            if (shape instanceof wcardinalUi.EShapeConnectorLine) {
                const edge = shape.edge;
                const tailLocal = edge.tail.local;
                const headLocal = edge.head.local;
                return [tailLocal.x, tailLocal.y, headLocal.x, headLocal.y, 0, 0];
            }
            else {
                const transform = shape.transform;
                const position = transform.position;
                const size = shape.size;
                const skew = transform.skew;
                return [position.x, position.y, size.x, size.y, transform.rotation, skew.x];
            }
        }
        setProperty(shape, capability, property) {
            if (shape instanceof wcardinalUi.EShapeConnectorLine) {
                const edge = shape.edge;
                edge.tail.local.set(property[0], property[1]);
                edge.head.local.set(property[2], property[3]);
            }
            else {
                const transform = shape.transform;
                if (capability & wcardinalUi.EShapeCapability.POSITION) {
                    transform.position.set(property[0], property[1]);
                }
                if (capability & wcardinalUi.EShapeCapability.HEIGHT) {
                    if (capability & wcardinalUi.EShapeCapability.WIDTH) {
                        shape.size.set(property[2], property[3]);
                    }
                    else {
                        shape.size.y = property[3];
                    }
                }
                else if (capability & wcardinalUi.EShapeCapability.WIDTH) {
                    shape.size.x = property[2];
                }
                if (capability & wcardinalUi.EShapeCapability.ROTATION) {
                    transform.rotation = property[4];
                }
                if (capability & wcardinalUi.EShapeCapability.SKEW) {
                    transform.skew.set(property[5], property[5]);
                }
            }
        }
        initProperty(shape, capability, property) {
            // DO NOTHING
        }
    }

    class ECommandShapePropertyCapability extends ECommandShapeProperty {
        getProperty(shape, capability) {
            const shapeCapability = shape.getCapability();
            if (shapeCapability != null) {
                return shapeCapability.locked;
            }
            return wcardinalUi.EShapeCapability.NONE;
        }
        setProperty(shape, capability, property) {
            if (property !== wcardinalUi.EShapeCapability.NONE) {
                shape.capability.locked = property;
            }
            else {
                const shapeCapability = shape.getCapability();
                if (shapeCapability != null) {
                    shapeCapability.locked = property;
                }
            }
        }
    }

    class ECommandShapePropertyCapabilityLock extends ECommandShapePropertyCapability {
        initProperty(shape, capability, property) {
            shape.capability.locked |= property;
        }
    }

    class ECommandShapePropertyCapabilityUnlock extends ECommandShapePropertyCapability {
        initProperty(shape, capability, property) {
            shape.capability.locked &= ~property;
        }
    }

    class ECommandShapePropertyCornerOff extends ECommandShapeProperty {
        getProperty(shape, capability) {
            return shape.corner;
        }
        setProperty(shape, capability, property) {
            shape.corner = property;
        }
        initProperty(shape, capability, property) {
            shape.corner &= ~property;
        }
    }

    class ECommandShapePropertyCornerOn extends ECommandShapeProperty {
        getProperty(shape, capability) {
            return shape.corner;
        }
        setProperty(shape, capability, property) {
            shape.corner = property;
        }
        initProperty(shape, capability, property) {
            shape.corner |= property;
        }
    }

    class ECommandShapePropertySimple extends ECommandShapeProperty {
        initProperty(shape, capability, property) {
            this.setProperty(shape, capability, property);
        }
    }

    class ECommandShapePropertyCursor extends ECommandShapePropertySimple {
        getProperty(shape, capability) {
            return shape.cursor;
        }
        setProperty(shape, capability, property) {
            shape.cursor = property;
        }
    }

    class ECommandShapePropertyRecursive extends ECommandShapeProperty {
        constructor(selection, property) {
            super(selection, property);
        }
        isRecursive() {
            return true;
        }
    }

    class ECommandShapePropertyRecursiveSimple extends ECommandShapePropertyRecursive {
        initProperty(shape, capability, property) {
            this.setProperty(shape, capability, property);
        }
    }

    class ECommandShapePropertyFillColor extends ECommandShapePropertyRecursiveSimple {
        getProperty(shape, capability) {
            return [shape.fill.color, shape.fill.alpha];
        }
        setProperty(shape, capability, property) {
            shape.fill.set(undefined, property[0], property[1]);
        }
    }

    class ECommandShapePropertyFillEnable extends ECommandShapePropertyRecursiveSimple {
        getProperty(shape, capability) {
            return shape.fill.enable;
        }
        setProperty(shape, capability, property) {
            shape.fill.enable = property;
        }
    }

    class ECommandShapePropertyFocusable extends ECommandShapePropertySimple {
        getProperty(shape, capability) {
            return shape.state.isFocusable;
        }
        setProperty(shape, capability, property) {
            shape.state.isFocusable = property;
        }
    }

    class ECommandShapePropertyId extends ECommandShapePropertySimple {
        getProperty(shape, capability) {
            return shape.id;
        }
        setProperty(shape, capability, property) {
            shape.id = property;
        }
        getParts() {
            return EToolSelectSelectionUpdatedPart.PROPERTY_ID;
        }
    }

    class ECommandShapePropertyImageClear extends ECommandShapeProperty {
        constructor(selection) {
            super(selection, undefined);
        }
        getProperty(shape, capability) {
            return shape.image;
        }
        setProperty(shape, capability, property) {
            shape.image = property;
        }
        initProperty(shape, capability, property) {
            shape.image = undefined;
            shape.gradient = undefined;
        }
    }

    class ECommandShapePropertyImageFitTo extends ECommandShapePropertyRecursive {
        constructor(selection) {
            super(selection, undefined);
        }
        getProperty(shape, capability) {
            const size = shape.size;
            return [size.x, size.y];
        }
        setProperty(shape, capability, property) {
            shape.size.set(property[0], property[1]);
        }
        initProperty(shape, capability, property) {
            const image = shape.image;
            if (image) {
                shape.size.set(image.width, image.height);
            }
        }
    }

    class ECommandShapePropertyImage extends ECommandShapeProperty {
        constructor(selection, image, gradient) {
            super(selection, [image, gradient]);
        }
        getProperty(shape, capability) {
            return shape.image;
        }
        setProperty(shape, capability, property) {
            shape.image = property;
        }
        initProperty(shape, capability, property) {
            shape.image = property[0];
            shape.gradient = property[1];
        }
    }

    class ECommandShapePropertyInteractive extends ECommandShapePropertySimple {
        getProperty(shape, capability) {
            return shape.interactive;
        }
        setProperty(shape, capability, property) {
            shape.interactive = property;
        }
    }

    class ECommandShapePropertyLineHeadColor extends ECommandShapePropertyRecursiveSimple {
        toCapability(shape) {
            if (wcardinalUi.EShapeCapabilities.contains(shape, wcardinalUi.EShapeCapability.LINE_HEAD)) {
                return wcardinalUi.EShapeCapability.LINE_HEAD;
            }
            return wcardinalUi.EShapeCapability.NONE;
        }
        getProperty(shape, capability) {
            const points = shape.points;
            if (points) {
                const fill = points.marker.head.fill;
                return [fill.color, fill.alpha];
            }
            return [0, 0];
        }
        setProperty(shape, capability, property) {
            const points = shape.points;
            if (points) {
                points.marker.head.fill.set(undefined, property[0], property[1]);
            }
        }
    }

    class ECommandShapePropertyLineHeadMargin extends ECommandShapePropertyRecursiveSimple {
        toCapability(shape) {
            if (wcardinalUi.EShapeCapabilities.contains(shape, wcardinalUi.EShapeCapability.LINE_HEAD)) {
                return wcardinalUi.EShapeCapability.LINE_HEAD;
            }
            return wcardinalUi.EShapeCapability.NONE;
        }
        getProperty(shape, capability) {
            if (shape instanceof wcardinalUi.EShapeConnectorLine) {
                return shape.edge.head.margin;
            }
            return 0;
        }
        setProperty(shape, capability, property) {
            if (shape instanceof wcardinalUi.EShapeConnectorLine) {
                shape.edge.head.margin = property;
            }
        }
    }

    class ECommandShapePropertyLineHeadSizeX extends ECommandShapePropertyRecursiveSimple {
        toCapability(shape) {
            if (wcardinalUi.EShapeCapabilities.contains(shape, wcardinalUi.EShapeCapability.LINE_HEAD)) {
                return wcardinalUi.EShapeCapability.LINE_HEAD;
            }
            return wcardinalUi.EShapeCapability.NONE;
        }
        getProperty(shape, capability) {
            const points = shape.points;
            if (points) {
                return points.marker.head.size.x;
            }
            return 0;
        }
        setProperty(shape, capability, property) {
            const points = shape.points;
            if (points) {
                points.marker.head.size.x = property;
            }
        }
    }

    class ECommandShapePropertyLineHeadSizeY extends ECommandShapePropertyRecursiveSimple {
        toCapability(shape) {
            if (wcardinalUi.EShapeCapabilities.contains(shape, wcardinalUi.EShapeCapability.LINE_HEAD)) {
                return wcardinalUi.EShapeCapability.LINE_HEAD;
            }
            return wcardinalUi.EShapeCapability.NONE;
        }
        getProperty(shape, capability) {
            const points = shape.points;
            if (points) {
                return points.marker.head.size.y;
            }
            return 0;
        }
        setProperty(shape, capability, property) {
            const points = shape.points;
            if (points) {
                points.marker.head.size.y = property;
            }
        }
    }

    class ECommandShapePropertyLineHeadType extends ECommandShapePropertyRecursiveSimple {
        toCapability(shape) {
            if (wcardinalUi.EShapeCapabilities.contains(shape, wcardinalUi.EShapeCapability.LINE_HEAD)) {
                return wcardinalUi.EShapeCapability.LINE_HEAD;
            }
            return wcardinalUi.EShapeCapability.NONE;
        }
        getProperty(shape, capability) {
            const points = shape.points;
            if (points) {
                return points.marker.head.type;
            }
            return wcardinalUi.EShapePointsMarkerType.NONE;
        }
        setProperty(shape, capability, property) {
            const points = shape.points;
            if (points) {
                points.marker.head.type = property;
            }
        }
    }

    class ECommandShapePropertyLineTailColor extends ECommandShapePropertyRecursiveSimple {
        toCapability(shape) {
            if (wcardinalUi.EShapeCapabilities.contains(shape, wcardinalUi.EShapeCapability.LINE_TAIL)) {
                return wcardinalUi.EShapeCapability.LINE_TAIL;
            }
            return wcardinalUi.EShapeCapability.NONE;
        }
        getProperty(shape, capability) {
            const points = shape.points;
            if (points) {
                const fill = points.marker.tail.fill;
                return [fill.color, fill.alpha];
            }
            return [0, 0];
        }
        setProperty(shape, capability, property) {
            const points = shape.points;
            if (points) {
                points.marker.tail.fill.set(undefined, property[0], property[1]);
            }
        }
    }

    class ECommandShapePropertyLineTailMargin extends ECommandShapePropertyRecursiveSimple {
        toCapability(shape) {
            if (wcardinalUi.EShapeCapabilities.contains(shape, wcardinalUi.EShapeCapability.LINE_TAIL)) {
                return wcardinalUi.EShapeCapability.LINE_TAIL;
            }
            return wcardinalUi.EShapeCapability.NONE;
        }
        getProperty(shape, capability) {
            if (shape instanceof wcardinalUi.EShapeConnectorLine) {
                return shape.edge.tail.margin;
            }
            return 0;
        }
        setProperty(shape, capability, property) {
            if (shape instanceof wcardinalUi.EShapeConnectorLine) {
                shape.edge.tail.margin = property;
            }
        }
    }

    class ECommandShapePropertyLineTailSizeX extends ECommandShapePropertyRecursiveSimple {
        toCapability(shape) {
            if (wcardinalUi.EShapeCapabilities.contains(shape, wcardinalUi.EShapeCapability.LINE_TAIL)) {
                return wcardinalUi.EShapeCapability.LINE_TAIL;
            }
            return wcardinalUi.EShapeCapability.NONE;
        }
        getProperty(shape, capability) {
            const points = shape.points;
            if (points) {
                return points.marker.tail.size.x;
            }
            return 0;
        }
        setProperty(shape, capability, property) {
            const points = shape.points;
            if (points) {
                points.marker.tail.size.x = property;
            }
        }
    }

    class ECommandShapePropertyLineTailSizeY extends ECommandShapePropertyRecursiveSimple {
        toCapability(shape) {
            if (wcardinalUi.EShapeCapabilities.contains(shape, wcardinalUi.EShapeCapability.LINE_TAIL)) {
                return wcardinalUi.EShapeCapability.LINE_TAIL;
            }
            return wcardinalUi.EShapeCapability.NONE;
        }
        getProperty(shape, capability) {
            const points = shape.points;
            if (points) {
                return points.marker.tail.size.y;
            }
            return 0;
        }
        setProperty(shape, capability, property) {
            const points = shape.points;
            if (points) {
                points.marker.tail.size.y = property;
            }
        }
    }

    class ECommandShapePropertyLineTailType extends ECommandShapePropertyRecursiveSimple {
        toCapability(shape) {
            if (wcardinalUi.EShapeCapabilities.contains(shape, wcardinalUi.EShapeCapability.LINE_TAIL)) {
                return wcardinalUi.EShapeCapability.LINE_TAIL;
            }
            return wcardinalUi.EShapeCapability.NONE;
        }
        getProperty(shape, capability) {
            const points = shape.points;
            if (points) {
                return points.marker.tail.type;
            }
            return wcardinalUi.EShapePointsMarkerType.NONE;
        }
        setProperty(shape, capability, property) {
            const points = shape.points;
            if (points) {
                points.marker.tail.type = property;
            }
        }
    }

    class ECommandShapePropertyPointsStyle extends ECommandShapeProperty {
        constructor(selection, added, removed) {
            super(selection, [added, removed]);
        }
        toCapability(shape) {
            if (wcardinalUi.EShapeCapabilities.contains(shape, wcardinalUi.EShapeCapability.LINE)) {
                return wcardinalUi.EShapeCapability.LINE;
            }
            return wcardinalUi.EShapeCapability.NONE;
        }
        getProperty(shape, capability) {
            const points = shape.points;
            if (points != null) {
                return points.style;
            }
            return wcardinalUi.EShapePointsStyle.NONE;
        }
        setProperty(shape, capability, property) {
            const points = shape.points;
            if (points != null) {
                points.style = property;
            }
        }
        initProperty(shape, capability, property) {
            const points = shape.points;
            if (points != null) {
                points.style = (points.style & ~property[1]) | property[0];
            }
        }
    }

    class ECommandShapePropertyPositionAndRotate extends ECommandShapeProperty {
        constructor(selection) {
            super(selection, undefined);
        }
        toCapability(shape) {
            if (shape instanceof wcardinalUi.EShapeConnectorLine) {
                const edge = shape.edge;
                if (edge.tail.acceptor.shape == null && edge.head.acceptor.shape == null) {
                    return wcardinalUi.EShapeCapability.ALL;
                }
                return wcardinalUi.EShapeCapability.NONE;
            }
            else {
                let result = wcardinalUi.EShapeCapability.NONE;
                if (wcardinalUi.EShapeCapabilities.contains(shape, wcardinalUi.EShapeCapability.POSITION)) {
                    result |= wcardinalUi.EShapeCapability.POSITION;
                }
                if (wcardinalUi.EShapeCapabilities.contains(shape, wcardinalUi.EShapeCapability.ROTATION)) {
                    result |= wcardinalUi.EShapeCapability.ROTATION;
                }
                return result;
            }
        }
        getProperty(shape, capability) {
            if (shape instanceof wcardinalUi.EShapeConnectorLine) {
                const edge = shape.edge;
                const tailLocal = edge.tail.local;
                const headLocal = edge.head.local;
                return [tailLocal.x, tailLocal.y, headLocal.x, headLocal.y];
            }
            else {
                const transform = shape.transform;
                const position = transform.position;
                return [position.x, position.y, transform.rotation, 0];
            }
        }
        setProperty(shape, capability, property) {
            if (shape instanceof wcardinalUi.EShapeConnectorLine) {
                const edge = shape.edge;
                edge.tail.local.set(property[0], property[1]);
                edge.head.local.set(property[2], property[3]);
            }
            else {
                const transform = shape.transform;
                if (capability & wcardinalUi.EShapeCapability.POSITION) {
                    transform.position.set(property[0], property[1]);
                }
                if (capability & wcardinalUi.EShapeCapability.ROTATION) {
                    transform.rotation = property[2];
                }
            }
        }
        initProperty(shape, capability, property) {
            // DO NOTHING
        }
    }

    class ECommandShapePropertyPositionLeft extends ECommandShapeProperty {
        toCapability(shape) {
            if (wcardinalUi.EShapeCapabilities.contains(shape, wcardinalUi.EShapeCapability.POSITION)) {
                return wcardinalUi.EShapeCapability.POSITION;
            }
            return wcardinalUi.EShapeCapability.NONE;
        }
        getProperty(shape, capability) {
            return shape.transform.position.x;
        }
        setProperty(shape, capability, property) {
            shape.transform.position.x = property;
        }
        initProperty(shape, capability, property) {
            var _a;
            const rectangle = ((_a = ECommandShapePropertyPositionLeft.WORK) !== null && _a !== void 0 ? _a : (ECommandShapePropertyPositionLeft.WORK = new pixi_js.Rectangle()));
            shape.getBoundsLocal(false, rectangle);
            shape.transform.position.x += property - rectangle.x;
        }
        isMergeable() {
            return true;
        }
    }

    class ECommandShapePropertyPositionTop extends ECommandShapeProperty {
        toCapability(shape) {
            if (wcardinalUi.EShapeCapabilities.contains(shape, wcardinalUi.EShapeCapability.POSITION)) {
                return wcardinalUi.EShapeCapability.POSITION;
            }
            return wcardinalUi.EShapeCapability.NONE;
        }
        getProperty(shape, capability) {
            return shape.transform.position.y;
        }
        setProperty(shape, capability, property) {
            shape.transform.position.y = property;
        }
        initProperty(shape, capability, property) {
            var _a;
            const rectangle = ((_a = ECommandShapePropertyPositionTop.WORK) !== null && _a !== void 0 ? _a : (ECommandShapePropertyPositionTop.WORK = new pixi_js.Rectangle()));
            shape.getBoundsLocal(false, rectangle);
            shape.transform.position.y += property - rectangle.y;
        }
        isMergeable() {
            return true;
        }
    }

    class ECommandShapePropertyPositionX extends ECommandShapePropertySimple {
        toCapability(shape) {
            if (wcardinalUi.EShapeCapabilities.contains(shape, wcardinalUi.EShapeCapability.POSITION)) {
                return wcardinalUi.EShapeCapability.POSITION;
            }
            return wcardinalUi.EShapeCapability.NONE;
        }
        getProperty(shape, capability) {
            return shape.transform.position.x;
        }
        setProperty(shape, capability, property) {
            shape.transform.position.x = property;
        }
        isMergeable() {
            return true;
        }
    }

    class ECommandShapePropertyPositionY extends ECommandShapePropertySimple {
        toCapability(shape) {
            if (wcardinalUi.EShapeCapabilities.contains(shape, wcardinalUi.EShapeCapability.POSITION)) {
                return wcardinalUi.EShapeCapability.POSITION;
            }
            return wcardinalUi.EShapeCapability.NONE;
        }
        getProperty(shape, capability) {
            return shape.transform.position.y;
        }
        setProperty(shape, capability, property) {
            shape.transform.position.y = property;
        }
        isMergeable() {
            return true;
        }
    }

    class ECommandShapePropertyPosition extends ECommandShapeProperty {
        constructor(selection) {
            super(selection, undefined);
        }
        toCapability(shape) {
            if (shape instanceof wcardinalUi.EShapeConnectorLine) {
                const edge = shape.edge;
                if (edge.tail.acceptor.shape == null && edge.head.acceptor.shape == null) {
                    return wcardinalUi.EShapeCapability.POSITION;
                }
                return wcardinalUi.EShapeCapability.NONE;
            }
            else {
                if (wcardinalUi.EShapeCapabilities.contains(shape, wcardinalUi.EShapeCapability.POSITION)) {
                    return wcardinalUi.EShapeCapability.POSITION;
                }
                return wcardinalUi.EShapeCapability.NONE;
            }
        }
        getProperty(shape, capability) {
            if (shape instanceof wcardinalUi.EShapeConnectorLine) {
                const edge = shape.edge;
                const tailLocal = edge.tail.local;
                const headLocal = edge.head.local;
                return [tailLocal.x, tailLocal.y, headLocal.x, headLocal.y];
            }
            else {
                const position = shape.transform.position;
                return [position.x, position.y, 0, 0];
            }
        }
        setProperty(shape, capability, property) {
            if (shape instanceof wcardinalUi.EShapeConnectorLine) {
                const edge = shape.edge;
                edge.tail.local.set(property[0], property[1]);
                edge.head.local.set(property[2], property[3]);
            }
            else {
                shape.transform.position.set(property[0], property[1]);
            }
        }
        initProperty(shape, capability, property) {
            // DO NOTHING
        }
    }

    class ECommandShapePropertyRadius extends ECommandShapePropertySimple {
        getProperty(shape, capability) {
            return shape.radius;
        }
        setProperty(shape, capability, property) {
            shape.radius = property;
        }
        isMergeable() {
            return true;
        }
    }

    class ECommandShapePropertyRotation extends ECommandShapePropertySimple {
        toCapability(shape) {
            if (wcardinalUi.EShapeCapabilities.contains(shape, wcardinalUi.EShapeCapability.ROTATION)) {
                return wcardinalUi.EShapeCapability.ROTATION;
            }
            return wcardinalUi.EShapeCapability.NONE;
        }
        getProperty(shape, capability) {
            return shape.transform.rotation;
        }
        setProperty(shape, capability, property) {
            shape.transform.rotation = property;
        }
        isMergeable() {
            return true;
        }
    }

    class ECommandShapePropertyShortcut extends ECommandShapePropertySimple {
        getProperty(shape, capability) {
            return shape.shortcut;
        }
        setProperty(shape, capability, property) {
            shape.shortcut = property;
        }
    }

    class ECommandShapePropertySizeX extends ECommandShapePropertySimple {
        toCapability(shape) {
            if (wcardinalUi.EShapeCapabilities.contains(shape, wcardinalUi.EShapeCapability.WIDTH)) {
                return wcardinalUi.EShapeCapability.WIDTH;
            }
            return wcardinalUi.EShapeCapability.NONE;
        }
        getProperty(shape, capability) {
            return shape.size.x;
        }
        setProperty(shape, capability, property) {
            shape.size.x = property;
        }
        isMergeable() {
            return true;
        }
    }

    class ECommandShapePropertySizeY extends ECommandShapePropertySimple {
        toCapability(shape) {
            if (wcardinalUi.EShapeCapabilities.contains(shape, wcardinalUi.EShapeCapability.HEIGHT)) {
                return wcardinalUi.EShapeCapability.HEIGHT;
            }
            return wcardinalUi.EShapeCapability.NONE;
        }
        getProperty(shape, capability) {
            return shape.size.y;
        }
        setProperty(shape, capability, property) {
            shape.size.y = property;
        }
        isMergeable() {
            return true;
        }
    }

    class ECommandShapePropertySkew extends ECommandShapePropertySimple {
        toCapability(shape) {
            if (wcardinalUi.EShapeCapabilities.contains(shape, wcardinalUi.EShapeCapability.SKEW)) {
                return wcardinalUi.EShapeCapability.SKEW;
            }
            return wcardinalUi.EShapeCapability.NONE;
        }
        getProperty(shape, capability) {
            return shape.transform.skew.x;
        }
        setProperty(shape, capability, property) {
            shape.transform.skew.set(property, property);
        }
        isMergeable() {
            return true;
        }
    }

    class ECommandShapePropertyStrokeAlign extends ECommandShapePropertyRecursiveSimple {
        getProperty(shape, capability) {
            return shape.stroke.align;
        }
        setProperty(shape, capability, property) {
            shape.stroke.align = property;
        }
        isMergeable() {
            return true;
        }
    }

    class ECommandShapePropertyStrokeColor extends ECommandShapePropertyRecursiveSimple {
        getProperty(shape, capability) {
            return [shape.stroke.color, shape.stroke.alpha];
        }
        setProperty(shape, capability, property) {
            shape.stroke.set(undefined, property[0], property[1]);
        }
    }

    class ECommandShapePropertyStrokeEnable extends ECommandShapePropertyRecursiveSimple {
        getProperty(shape, capability) {
            return shape.stroke.enable;
        }
        setProperty(shape, capability, property) {
            shape.stroke.enable = property;
        }
    }

    class ECommandShapePropertyStrokeSideOff extends ECommandShapePropertyRecursive {
        getProperty(shape, capability) {
            return shape.stroke.side;
        }
        setProperty(shape, capability, property) {
            shape.stroke.side = property;
        }
        initProperty(shape, capability, property) {
            shape.stroke.side &= ~property;
        }
    }

    class ECommandShapePropertyStrokeSideOn extends ECommandShapePropertyRecursive {
        getProperty(shape, capability) {
            return shape.stroke.side;
        }
        setProperty(shape, capability, property) {
            shape.stroke.side = property;
        }
        initProperty(shape, capability, property) {
            shape.stroke.side |= property;
        }
    }

    class ECommandShapePropertyStrokeStyle extends ECommandShapeProperty {
        constructor(selection, added, removed) {
            super(selection, [added, removed]);
        }
        getProperty(shape, capability) {
            return shape.stroke.style;
        }
        setProperty(shape, capability, property) {
            shape.stroke.style = property;
        }
        initProperty(shape, capability, property) {
            const stroke = shape.stroke;
            stroke.style = (stroke.style & ~property[1]) | property[0];
        }
    }

    class ECommandShapePropertyStrokeWidth extends ECommandShapePropertyRecursiveSimple {
        getProperty(shape, capability) {
            return shape.stroke.width;
        }
        setProperty(shape, capability, property) {
            shape.stroke.width = property;
        }
        isMergeable() {
            return true;
        }
    }

    class ECommandShapePropertyTextAlignHorizontal extends ECommandShapePropertySimple {
        getProperty(shape, capability) {
            return shape.text.align.horizontal;
        }
        setProperty(shape, capability, property) {
            shape.text.align.horizontal = property;
        }
    }

    class ECommandShapePropertyTextAlignVertical extends ECommandShapePropertySimple {
        getProperty(shape, capability) {
            return shape.text.align.vertical;
        }
        setProperty(shape, capability, property) {
            shape.text.align.vertical = property;
        }
    }

    class ECommandShapePropertyTextClipping extends ECommandShapePropertySimple {
        getProperty(shape, capability) {
            return shape.text.clipping;
        }
        setProperty(shape, capability, property) {
            shape.text.clipping = property;
        }
    }

    class ECommandShapePropertyTextColor extends ECommandShapePropertySimple {
        getProperty(shape, capability) {
            const text = shape.text;
            return [text.color, text.alpha];
        }
        setProperty(shape, capability, property) {
            const text = shape.text;
            text.color = property[0];
            text.alpha = property[1];
        }
    }

    class ECommandShapePropertyTextDirection extends ECommandShapePropertySimple {
        getProperty(shape, capability) {
            return shape.text.direction;
        }
        setProperty(shape, capability, property) {
            shape.text.direction = property;
        }
    }

    class ECommandShapePropertyTextFamily extends ECommandShapePropertySimple {
        getProperty(shape, capability) {
            return shape.text.family;
        }
        setProperty(shape, capability, property) {
            shape.text.family = property;
        }
    }

    class ECommandShapePropertyTextFitting extends ECommandShapePropertySimple {
        getProperty(shape, capability) {
            return shape.text.fitting;
        }
        setProperty(shape, capability, property) {
            shape.text.fitting = property;
        }
    }

    class ECommandShapePropertyTextOffsetHorizontal extends ECommandShapePropertySimple {
        getProperty(shape, capability) {
            return shape.text.offset.horizontal;
        }
        setProperty(shape, capability, property) {
            shape.text.offset.horizontal = property;
        }
    }

    class ECommandShapePropertyTextOffsetVertical extends ECommandShapePropertySimple {
        getProperty(shape, capability) {
            return shape.text.offset.vertical;
        }
        setProperty(shape, capability, property) {
            shape.text.offset.vertical = property;
        }
    }

    class ECommandShapePropertyTextOutlineColor extends ECommandShapePropertySimple {
        getProperty(shape, capability) {
            const outline = shape.text.outline;
            return [outline.color, outline.alpha];
        }
        setProperty(shape, capability, property) {
            const outline = shape.text.outline;
            outline.color = property[0];
            outline.alpha = property[1];
        }
    }

    class ECommandShapePropertyTextOutlineEnable extends ECommandShapePropertySimple {
        getProperty(shape, capability) {
            return shape.text.outline.enable;
        }
        setProperty(shape, capability, property) {
            shape.text.outline.enable = property;
        }
    }

    class ECommandShapePropertyTextOutlineWidth extends ECommandShapePropertySimple {
        getProperty(shape, capability) {
            return shape.text.outline.width;
        }
        setProperty(shape, capability, property) {
            shape.text.outline.width = property;
        }
        isMergeable() {
            return true;
        }
    }

    class ECommandShapePropertyTextPaddingHorizontal extends ECommandShapePropertySimple {
        getProperty(shape, capability) {
            return shape.text.padding.horizontal;
        }
        setProperty(shape, capability, property) {
            shape.text.padding.horizontal = property;
        }
    }

    class ECommandShapePropertyTextPaddingVertical extends ECommandShapePropertySimple {
        getProperty(shape, capability) {
            return shape.text.padding.vertical;
        }
        setProperty(shape, capability, property) {
            shape.text.padding.vertical = property;
        }
    }

    class ECommandShapePropertyTextSizeDelta extends ECommandShapeProperty {
        getProperty(shape, capability) {
            return shape.text.size;
        }
        setProperty(shape, capability, property) {
            shape.text.size = property;
        }
        initProperty(shape, capability, property) {
            const text = shape.text;
            text.size = Math.max(0, text.size + property);
        }
    }

    class ECommandShapePropertyTextSize extends ECommandShapePropertySimple {
        getProperty(shape, capability) {
            return shape.text.size;
        }
        setProperty(shape, capability, property) {
            shape.text.size = property;
        }
    }

    class ECommandShapePropertyTextSpacingHorizontal extends ECommandShapePropertySimple {
        getProperty(shape, capability) {
            return shape.text.spacing.horizontal;
        }
        setProperty(shape, capability, property) {
            shape.text.spacing.horizontal = property;
        }
        isMergeable() {
            return true;
        }
    }

    class ECommandShapePropertyTextSpacingVertical extends ECommandShapePropertySimple {
        getProperty(shape, capability) {
            return shape.text.spacing.vertical;
        }
        setProperty(shape, capability, property) {
            shape.text.spacing.vertical = property;
        }
        isMergeable() {
            return true;
        }
    }

    class ECommandShapePropertyTextStyle extends ECommandShapePropertySimple {
        getProperty(shape, capability) {
            return shape.text.style;
        }
        setProperty(shape, capability, property) {
            shape.text.style = property;
        }
    }

    class ECommandShapePropertyTextValue extends ECommandShapePropertySimple {
        getProperty(shape, capability) {
            return shape.text.value;
        }
        setProperty(shape, capability, property) {
            shape.text.value = property;
        }
        isMergeable() {
            return true;
        }
    }

    class ECommandShapePropertyTextWeight extends ECommandShapePropertySimple {
        getProperty(shape, capability) {
            return shape.text.weight;
        }
        setProperty(shape, capability, property) {
            shape.text.weight = property;
        }
    }

    class ECommandShapePropertyTitle extends ECommandShapePropertySimple {
        getProperty(shape, capability) {
            return shape.title;
        }
        setProperty(shape, capability, property) {
            shape.title = property;
        }
    }

    class ECommandShapeReplaceOne extends wcardinalUi.DCommandBase {
        constructor(newShape, oldShape, parent, selection) {
            super();
            this._parent = parent;
            this._newShape = newShape;
            this._oldShape = oldShape;
            this._selection = selection;
            this._index = parent.children.indexOf(oldShape);
            newShape.reference += 1;
            oldShape.reference += 1;
        }
        get parent() {
            return this._parent;
        }
        get oldShape() {
            return this._oldShape;
        }
        get newShape() {
            return this._newShape;
        }
        get index() {
            return this._index;
        }
        get selection() {
            return this._selection;
        }
        execute() {
            this._oldShape.detach();
            this._newShape.attach(this._parent, this._index);
            this._selection.swapLast(this._oldShape, this._newShape);
            return true;
        }
        redo() {
            this._newShape.attach(this._parent, this._index);
            this._oldShape.detach();
            this._selection.swapLast(this._oldShape, this._newShape);
            return true;
        }
        undo() {
            this._newShape.detach();
            this._oldShape.attach(this._parent, this._index);
            this._selection.swapLast(this._newShape, this._oldShape);
            return true;
        }
        destroy() {
            // Destroy new shapes
            const newShape = this._newShape;
            newShape.reference -= 1;
            if (newShape.parent == null && newShape.reference <= 0) {
                newShape.destroy();
            }
            // Destroy old shapes
            const oldShape = this._oldShape;
            oldShape.reference -= 1;
            if (oldShape.parent == null && oldShape.reference <= 0) {
                oldShape.destroy();
            }
        }
    }

    class ECommandShapeReplace extends wcardinalUi.DCommandBase {
        constructor(parent, factory, selection) {
            super();
            this._parent = parent;
            this._factory = factory;
            this._selection = selection;
            this._newShapes = [];
            this._oldShapes = [];
            this._indices = [];
        }
        get parent() {
            return this._parent;
        }
        get oldShapes() {
            return this._oldShapes;
        }
        get newShapes() {
            return this._newShapes;
        }
        get indices() {
            return this._indices;
        }
        get selection() {
            return this._selection;
        }
        execute() {
            const parent = this._parent;
            const indices = this._indices;
            const newShapes = this._newShapes;
            const oldShapes = this._oldShapes;
            const children = parent.children;
            const factory = this._factory;
            for (let i = 0, imax = children.length; i < imax; ++i) {
                const child = children[i];
                if (child.selected) {
                    let newShape;
                    if (wcardinalUi.EShapeCapabilities.contains(child, wcardinalUi.EShapeCapability.REPLACING)) {
                        if (child instanceof wcardinalUi.EShapeGroup) {
                            const pivot = child.transform.pivot;
                            const pivotX = pivot.x;
                            const pivotY = pivot.y;
                            if (pivotX !== 0 || pivotY !== 0) {
                                child.lock(wcardinalUi.EShapeLockPart.TRANSFORM);
                                pivot.set(0, 0);
                                newShape = factory(child) || child;
                                pivot.set(pivotX, pivotY);
                                child.unlock(wcardinalUi.EShapeLockPart.TRANSFORM, false);
                            }
                            else {
                                newShape = factory(child) || child;
                            }
                        }
                        else {
                            newShape = factory(child) || child;
                        }
                        if (newShape !== child) {
                            child.reference += 1;
                            newShape.reference += 1;
                            child.detach();
                            newShape.attach(parent, i);
                        }
                    }
                    else {
                        newShape = child;
                    }
                    indices.push(i);
                    newShapes.push(newShape);
                    oldShapes.push(child);
                }
            }
            const selection = this._selection;
            selection.lock();
            selection.clearAndAddAll(newShapes);
            selection.update(EToolSelectSelectionUpdatedPart.TREE | EToolSelectSelectionUpdatedPart.SELECTION);
            selection.unlock();
            return true;
        }
        redo() {
            const parent = this._parent;
            const indices = this._indices;
            const oldShapes = this._oldShapes;
            const newShapes = this._newShapes;
            for (let i = 0, imax = newShapes.length; i < imax; ++i) {
                const oldShape = oldShapes[i];
                const newShape = newShapes[i];
                if (oldShape !== newShape) {
                    oldShape.detach();
                    newShape.attach(parent, indices[i]);
                }
            }
            const selection = this._selection;
            selection.lock();
            selection.clearAndAddAll(newShapes);
            selection.update(EToolSelectSelectionUpdatedPart.TREE | EToolSelectSelectionUpdatedPart.SELECTION);
            selection.unlock();
            return true;
        }
        undo() {
            const parent = this._parent;
            const indices = this._indices;
            const oldShapes = this._oldShapes;
            const newShapes = this._newShapes;
            for (let i = 0, imax = newShapes.length; i < imax; ++i) {
                const oldShape = oldShapes[i];
                const newShape = newShapes[i];
                if (oldShape !== newShape) {
                    newShape.detach();
                    oldShape.attach(parent, indices[i]);
                }
            }
            const selection = this._selection;
            selection.lock();
            selection.clearAndAddAll(oldShapes);
            selection.update(EToolSelectSelectionUpdatedPart.TREE | EToolSelectSelectionUpdatedPart.SELECTION);
            selection.unlock();
            return true;
        }
        destroy() {
            // Destroy Shapes
            const oldShapes = this._oldShapes;
            const newShapes = this._newShapes;
            for (let i = 0, imax = newShapes.length; i < imax; ++i) {
                const oldShape = oldShapes[i];
                const newShape = newShapes[i];
                if (oldShape !== newShape) {
                    newShape.reference -= 1;
                    if (newShape.parent == null && newShape.reference <= 0) {
                        newShape.destroy();
                    }
                    oldShape.reference -= 1;
                    if (oldShape.parent == null && oldShape.reference <= 0) {
                        oldShape.destroy();
                    }
                }
            }
            oldShapes.length = 0;
            newShapes.length = 0;
            this.indices.length = 0;
        }
    }

    class ECommandShapeSelect extends wcardinalUi.DCommandBase {
        constructor(before, after, selection) {
            super();
            this._before = before;
            this._after = after;
            this._selection = selection;
        }
        get before() {
            return this._before;
        }
        get after() {
            return this._after;
        }
        get selection() {
            return this._selection;
        }
        isClean() {
            return true;
        }
        execute() {
            return true;
        }
        redo() {
            this._selection.restore(this._after);
            return true;
        }
        undo() {
            this._selection.restore(this._before);
            return true;
        }
        destroy() {
            this._before.length = 0;
            this._after.length = 0;
        }
    }

    class ECommandShapeTreeBringForward extends wcardinalUi.DCommandBase {
        /**
         *
         * @param indices indices of moved children sorted in the "descending" order
         * @param parent
         * @param selection
         */
        constructor(indices, parent, selection) {
            super();
            this._indices = indices;
            this._parent = parent;
            this._selection = selection;
        }
        get indices() {
            return this._indices;
        }
        get parent() {
            return this._parent;
        }
        get selection() {
            return this._selection;
        }
        execute() {
            return true;
        }
        redo() {
            const indices = this._indices;
            const parent = this._parent;
            const children = parent.children;
            for (let i = 0, imax = indices.length; i < imax; ++i) {
                const index = indices[i];
                const child = children[index];
                children[index] = children[index + 1];
                children[index + 1] = child;
            }
            parent.toDirty();
            this._selection.update(EToolSelectSelectionUpdatedPart.TREE);
            return true;
        }
        undo() {
            const indices = this._indices;
            const parent = this._parent;
            const children = parent.children;
            for (let i = indices.length - 1; 0 <= i; --i) {
                const index = indices[i];
                const child = children[index + 1];
                children[index + 1] = children[index];
                children[index] = child;
            }
            parent.toDirty();
            this._selection.update(EToolSelectSelectionUpdatedPart.TREE);
            return true;
        }
        destroy() {
            this._indices.length = 0;
        }
    }

    const SHAPE_COMPARATOR$1 = (a, b) => {
        return a.index - b.index;
    };
    class ECommandShapeTreeBringToFront extends wcardinalUi.DCommandBase {
        /**
         *
         * @param indices indices of moved children sorted in the "descending" order
         * @param parent
         * @param selection
         */
        constructor(indices, parent, selection) {
            super();
            this._indices = indices;
            this._parent = parent;
            this._selection = selection;
        }
        get indices() {
            return this._indices;
        }
        get parent() {
            return this._parent;
        }
        get selection() {
            return this._selection;
        }
        execute() {
            return true;
        }
        redo() {
            const indices = this._indices;
            const parent = this._parent;
            const children = parent.children;
            const offset = children.length;
            for (let i = 0; i < offset; ++i) {
                children[i].index = i;
            }
            for (let i = 0, imax = indices.length; i < imax; ++i) {
                const index = indices[i];
                const child = children[index];
                child.index = offset + index;
            }
            children.sort(SHAPE_COMPARATOR$1);
            parent.toDirty();
            this._selection.update(EToolSelectSelectionUpdatedPart.TREE);
            return true;
        }
        undo() {
            const indices = this._indices;
            const parent = this._parent;
            const children = parent.children;
            const offset = children.length;
            const indexSize = indices.length;
            for (let i = 0, imax = indexSize; i < imax; ++i) {
                const index = indices[i];
                const child = children[offset - 1 - i];
                child.index = index;
            }
            let indexIndex = indexSize - 1;
            let indexCurrent = indices[indexIndex];
            let indexOffset = 0;
            for (let i = 0, imax = offset - indexSize; i < imax; ++i) {
                const child = children[i];
                const index = i + indexOffset;
                if (index < indexCurrent) {
                    child.index = index;
                }
                else {
                    indexOffset += 1;
                    indexIndex -= 1;
                    if (0 <= indexIndex) {
                        indexCurrent = indices[indexIndex];
                    }
                    else {
                        indexCurrent = Number.MAX_SAFE_INTEGER;
                    }
                    i -= 1;
                }
            }
            children.sort(SHAPE_COMPARATOR$1);
            parent.toDirty();
            this._selection.update(EToolSelectSelectionUpdatedPart.TREE);
            return true;
        }
        destroy() {
            this._indices.length = 0;
        }
    }

    class ECommandShapeTreeSendBackward extends wcardinalUi.DCommandBase {
        /**
         * @param indices indices of moved children sorted in the "ascending" order
         * @param parent
         * @param selection
         */
        constructor(indices, parent, selection) {
            super();
            this._indices = indices;
            this._parent = parent;
            this._selection = selection;
        }
        get indices() {
            return this._indices;
        }
        get parent() {
            return this._parent;
        }
        get selection() {
            return this._selection;
        }
        execute() {
            return true;
        }
        redo() {
            const indices = this._indices;
            const parent = this._parent;
            const children = parent.children;
            for (let i = 0, imax = indices.length; i < imax; ++i) {
                const index = indices[i];
                const child = children[index];
                children[index] = children[index - 1];
                children[index - 1] = child;
            }
            parent.toDirty();
            this._selection.update(EToolSelectSelectionUpdatedPart.TREE);
            return true;
        }
        undo() {
            const indices = this._indices;
            const parent = this._parent;
            const children = parent.children;
            for (let i = indices.length - 1; 0 <= i; --i) {
                const index = indices[i];
                const child = children[index - 1];
                children[index - 1] = children[index];
                children[index] = child;
            }
            parent.toDirty();
            this._selection.update(EToolSelectSelectionUpdatedPart.TREE);
            return true;
        }
        destroy() {
            this._indices.length = 0;
        }
    }

    const SHAPE_COMPARATOR = (a, b) => {
        return a.index - b.index;
    };
    class ECommandShapeTreeSendToBack extends wcardinalUi.DCommandBase {
        /**
         * @param indices indices of moved children sorted in the "ascending" order
         * @param parent
         * @param selection
         */
        constructor(indices, parent, selection) {
            super();
            this._indices = indices;
            this._parent = parent;
            this._selection = selection;
        }
        get indices() {
            return this._indices;
        }
        get parent() {
            return this._parent;
        }
        get selection() {
            return this._selection;
        }
        execute() {
            return true;
        }
        redo() {
            const indices = this._indices;
            const parent = this._parent;
            const children = parent.children;
            const offset = children.length;
            for (let i = 0; i < offset; ++i) {
                children[i].index = i;
            }
            for (let i = 0, imax = indices.length; i < imax; ++i) {
                const index = indices[i];
                const child = children[index];
                child.index = index - offset;
            }
            children.sort(SHAPE_COMPARATOR);
            parent.toDirty();
            this._selection.update(EToolSelectSelectionUpdatedPart.TREE);
            return true;
        }
        undo() {
            const indices = this._indices;
            const parent = this._parent;
            const children = parent.children;
            const indexSize = indices.length;
            for (let i = 0, imax = indexSize; i < imax; ++i) {
                const index = indices[i];
                const child = children[i];
                child.index = index;
            }
            let indexIndex = 0;
            let indexCurrent = indices[indexIndex];
            let indexOffset = -indexSize;
            const offset = children.length;
            for (let i = indexSize; i < offset; ++i) {
                const child = children[i];
                const index = i + indexOffset;
                if (index < indexCurrent) {
                    child.index = index;
                }
                else {
                    indexOffset += 1;
                    indexIndex += 1;
                    if (indexIndex < indexSize) {
                        indexCurrent = indices[indexIndex];
                    }
                    else {
                        indexCurrent = Number.MAX_SAFE_INTEGER;
                    }
                    i -= 1;
                }
            }
            children.sort(SHAPE_COMPARATOR);
            parent.toDirty();
            this._selection.update(EToolSelectSelectionUpdatedPart.TREE);
            return true;
        }
        destroy() {
            this._indices.length = 0;
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class UtilShapeTransforms {
        static prepare(shape) {
            let editor = shape.editor;
            if (editor == null) {
                editor = new wcardinalUi.EShapeEditor();
                shape.editor = editor;
            }
            // Transform
            shape.updateTransform();
            const parent = shape.parent;
            if (parent instanceof wcardinalUi.EShapeBase) {
                parent.transform.internalTransform
                    .copyTo(editor.internalTransformParentInverse)
                    .invert();
            }
            else {
                editor.internalTransformParentInverse.identity();
            }
            shape.transform.internalTransform.copyTo(editor.internalTransform);
            // Rotation
            editor.rotation = shape.transform.rotation;
            // Size
            editor.size.copyFrom(shape.size);
            //
            shape.lock(wcardinalUi.EShapeLockPart.TRANSFORM_CHILD);
        }
        static finalize(shape) {
            shape.unlock(wcardinalUi.EShapeLockPart.TRANSFORM_CHILD, true);
        }
        static apply(shape, transform, capability) {
            const editor = shape.editor;
            if (editor != null) {
                const newLocalTransform = editor.localTransform;
                editor.internalTransformParentInverse
                    .copyTo(newLocalTransform)
                    .append(transform)
                    .append(editor.internalTransform);
                this.applyLocal(shape, newLocalTransform, capability, editor.size);
            }
        }
        static applyLocal(shape, localTransform, capability, size) {
            // Reconstruct the position, the rotation and the size
            const a = localTransform.a;
            const b = localTransform.b;
            const c = localTransform.c;
            const d = localTransform.d;
            const tx = localTransform.tx;
            const ty = localTransform.ty;
            shape.lock(wcardinalUi.EShapeLockPart.UPLOADED);
            // Transform
            const transform = shape.transform;
            // Capability
            const cposition = !!(capability & wcardinalUi.EShapeCapability.POSITION);
            const crotation = !!(capability & wcardinalUi.EShapeCapability.ROTATION);
            const cskew = !!(capability & wcardinalUi.EShapeCapability.SKEW);
            const cwidth = !!(capability & wcardinalUi.EShapeCapability.WIDTH);
            const cheight = !!(capability & wcardinalUi.EShapeCapability.HEIGHT);
            // Rotation and skew
            if (crotation || cskew) {
                // Rotation
                const rx = Math.atan2(-c, d); // rotation - skewX
                const ry = Math.atan2(+b, a); // rotation + skewY
                if (crotation) {
                    transform.rotation = (rx + ry) * 0.5; // Here, assumes `skewX` === `skewY`
                }
                // Skew
                if (cskew) {
                    const skew = (ry - rx) * 0.5;
                    transform.skew.set(skew, skew);
                }
            }
            // Position
            if (cposition) {
                // Assumes the pivot is invariant.
                // tx = position.x - (a * px + c * py)
                // ty = position.y - (b * px + d * py)
                //
                // Thus,
                // position.x = tx + (a * px + c * py)
                // position.y = ty + (b * px + d * py)
                const pivot = transform.pivot;
                const px = pivot.x;
                const py = pivot.y;
                transform.position.set(tx + (a * px + c * py), ty + (b * px + d * py));
            }
            // Scale
            if (size != null && (cwidth || cheight)) {
                const w = wcardinalUi.toSizeNormalized(size.x * Math.sqrt(a * a + b * b));
                const h = wcardinalUi.toSizeNormalized(size.y * Math.sqrt(c * c + d * d));
                const s = shape.size;
                if (cwidth && cheight) {
                    s.set(w, h);
                }
                else if (cwidth) {
                    s.x = w;
                }
                else {
                    s.y = h;
                }
            }
            //
            shape.unlock(wcardinalUi.EShapeLockPart.UPLOADED, true);
        }
    }

    class ECommandShapeUngroup extends wcardinalUi.DCommandBase {
        constructor(parent, selection) {
            super();
            this._parent = parent;
            this._selection = selection;
            this._before = [];
            this._deleteds = [];
            this._indices = [];
            this._createds = [];
        }
        get parent() {
            return this._parent;
        }
        get selection() {
            return this._selection;
        }
        get before() {
            return this._before;
        }
        get deleteds() {
            return this._deleteds;
        }
        get indices() {
            return this._indices;
        }
        get createds() {
            return this._createds;
        }
        execute() {
            // Save the current selection
            const selection = this._selection;
            selection.lock();
            this._before = selection.store();
            // Unselect non-group shapes
            const shapes = selection.get();
            for (let i = shapes.length - 1; 0 <= i; --i) {
                const shape = shapes[i];
                if (!this.isUngroupable(shape)) {
                    shape.selected = false;
                    shapes.splice(i, 1);
                }
            }
            // Delete groups
            const parent = this._parent;
            const deleteds = UtilShapeDeleter.delete(parent, shapes, true) || [];
            this._deleteds = deleteds;
            for (let i = 0, imax = deleteds.length; i < imax; ++i) {
                deleteds[i].reference += 1;
            }
            // Create shapes
            const createds = [];
            for (let i = 0, imax = deleteds.length; i < imax; ++i) {
                const target = deleteds[i];
                const targetLocalTransform = target.transform.localTransform;
                const a = targetLocalTransform.a;
                const b = targetLocalTransform.b;
                const c = targetLocalTransform.c;
                const d = targetLocalTransform.d;
                const tx = targetLocalTransform.tx;
                const ty = targetLocalTransform.ty;
                const targetChildren = target.children;
                const clones = [];
                for (let j = 0, jmax = targetChildren.length; j < jmax; ++j) {
                    const clone = targetChildren[j].clone();
                    clone.lock(wcardinalUi.EShapeLockPart.ALL);
                    clone.parent = null;
                    clone.updateTransform();
                    const localTransform = clone.transform.localTransform;
                    localTransform.prepend(targetLocalTransform);
                    let capability = wcardinalUi.EShapeCapability.NONE;
                    if (wcardinalUi.EShapeCapabilities.contains(clone, wcardinalUi.EShapeCapability.POSITION)) {
                        capability |= wcardinalUi.EShapeCapability.POSITION;
                    }
                    if (wcardinalUi.EShapeCapabilities.contains(clone, wcardinalUi.EShapeCapability.ROTATION)) {
                        capability |= wcardinalUi.EShapeCapability.ROTATION;
                    }
                    if (wcardinalUi.EShapeCapabilities.contains(clone, wcardinalUi.EShapeCapability.SKEW)) {
                        capability |= wcardinalUi.EShapeCapability.SKEW;
                    }
                    if (capability !== wcardinalUi.EShapeCapability.NONE) {
                        UtilShapeTransforms.applyLocal(clone, localTransform, capability);
                    }
                    if (clone instanceof wcardinalUi.EShapeConnectorLine) {
                        const edge = clone.edge;
                        const tail = edge.tail;
                        if (tail.acceptor.shape == null) {
                            // Local
                            const tailLocal = tail.local;
                            const tailLocalX = tailLocal.x;
                            const tailLocalY = tailLocal.y;
                            tailLocal.set(a * tailLocalX + c * tailLocalY + tx, b * tailLocalX + d * tailLocalY + ty);
                            // Normal
                            const tailNormal = tail.normal;
                            const tailNormalX = tailNormal.x;
                            const tailNormalY = tailNormal.y;
                            const ndx = a * tailNormalX + c * tailNormalY;
                            const ndy = b * tailNormalX + d * tailNormalY;
                            const nd = ndx * ndx + ndy * ndy;
                            if (0.000001 < nd) {
                                const f = Math.sqrt(1 / nd);
                                tailNormal.set(ndx * f, ndy * f);
                            }
                        }
                        const head = edge.head;
                        if (head.acceptor.shape == null) {
                            // Local
                            const headLocal = head.local;
                            const headLocalX = headLocal.x;
                            const headLocalY = headLocal.y;
                            headLocal.set(a * headLocalX + c * headLocalY + tx, b * headLocalX + d * headLocalY + ty);
                            // Normal
                            const headNormal = head.normal;
                            const headNormalX = headNormal.x;
                            const headNormalY = headNormal.y;
                            const ndx = a * headNormalX + c * headNormalY;
                            const ndy = b * headNormalX + d * headNormalY;
                            const nd = ndx * ndx + ndy * ndy;
                            if (0.000001 < nd) {
                                const f = Math.sqrt(1 / nd);
                                headNormal.set(ndx * f, ndy * f);
                            }
                        }
                    }
                    clones.push(clone);
                }
                wcardinalUi.EShapeConnectors.moveAll(targetChildren, clones, targetChildren, clones);
                for (let j = 0, jmax = clones.length; j < jmax; ++j) {
                    const clone = clones[j];
                    clone.unlock(wcardinalUi.EShapeLockPart.ALL, true);
                    clone.attach(parent);
                    clone.reference += 1;
                    createds.push(clone);
                }
            }
            this._createds = createds;
            // Indices
            this._indices = UtilShapeSearch.toIndices(deleteds);
            // Select created shapes
            selection.clearAndAddAll(createds);
            selection.update("TREE");
            selection.unlock();
            return true;
        }
        isUngroupable(shape) {
            return (shape instanceof wcardinalUi.EShapeGroup &&
                wcardinalUi.EShapeCapabilities.contains(shape, wcardinalUi.EShapeCapability.CHILDREN) &&
                wcardinalUi.EShapeCapabilities.contains(shape, wcardinalUi.EShapeCapability.UNGROUPING));
        }
        redo() {
            // Delete shapes
            const selection = this._selection;
            selection.lock();
            selection.clearAndAddAll(this._deleteds);
            selection.delete(false);
            // Add created shapes
            const parent = this._parent;
            const createds = this._createds;
            for (let i = 0, imax = createds.length; i < imax; ++i) {
                createds[i].attach(parent);
            }
            // Select created shapes
            selection.clearAndAddAll(createds);
            selection.update("TREE");
            selection.unlock();
            return true;
        }
        undo() {
            // Delete created shapes
            const parent = this._parent;
            const selection = this._selection;
            selection.lock();
            const createds = this._createds;
            for (let i = createds.length - 1; 0 <= i; --i) {
                createds[i].detach();
            }
            // Restore deleted shapes
            const deleteds = this._deleteds;
            const indices = this._indices;
            for (let i = 0, imax = deleteds.length; i < imax; ++i) {
                deleteds[i].attach(parent, indices[i]);
            }
            // Restore the selection
            this._selection.restore(this._before);
            selection.update("TREE");
            selection.unlock();
            return true;
        }
        destroy() {
            // Stored selection
            this._before.length = 0;
            // Deleted shapes
            const deleteds = this._deleteds;
            for (let i = 0, imax = deleteds.length; i < imax; ++i) {
                const deleted = deleteds[i];
                deleted.reference -= 1;
                if (deleted.parent == null && deleted.reference <= 0) {
                    deleted.destroy();
                }
            }
            deleteds.length = 0;
            // Created shapes
            const createds = this._createds;
            for (let i = 0, imax = createds.length; i < imax; ++i) {
                const created = createds[i];
                created.reference -= 1;
                if (created.parent == null && created.reference <= 0) {
                    created.destroy();
                }
            }
            createds.length = 0;
        }
    }

    function newGraphicTester(name, graphic) {
        return {
            id: undefined,
            graphicId: graphic.id,
            name,
            mappings: new Map()
        };
    }

    class UtilCsvState {
        constructor(lines) {
            this.lines = lines;
            this.linesLength = lines.length;
            this.cursor = -1;
            this.line = "";
            this.lineLength = 0;
        }
        next() {
            const newCursor = this.cursor + 1;
            if (newCursor < this.linesLength) {
                this.cursor = newCursor;
                const nextLine = this.lines[newCursor];
                this.line = nextLine;
                this.lineLength = nextLine.length;
                return true;
            }
            return false;
        }
    }
    class UtilCsv {
        static parseLine(state) {
            const result = [];
            let icomma = -1;
            let line = state.line;
            let length = state.lineLength;
            for (let i = 0; i < length; ++i) {
                if (line.charAt(i) === '"') {
                    // Find the corresponding double quote
                    for (let j = i + 1; j < length; ++j) {
                        const k = line.indexOf('"', j);
                        if (k < 0) {
                            // Not found.
                            if (state.next()) {
                                // Consumes the next line
                                line += "\n" + state.line;
                                length += 1 + state.lineLength;
                                // And try again
                                j -= 1;
                                continue;
                            }
                            else {
                                // Skip to the end.
                                j = length + 1;
                                result.push(this.unescape(line.substring(i + 1, j - 1)));
                                i = j;
                            }
                        }
                        else {
                            j = k + 1;
                            // If the next character is a double quote, then continues.
                            if (j < length && line.charAt(j) === '"') {
                                continue;
                            }
                            // The next character isn't a double quote
                            result.push(this.unescape(line.substring(i + 1, j - 1)));
                            i = j;
                        }
                        break;
                    }
                }
                else {
                    if (icomma < i) {
                        icomma = line.indexOf(",", i);
                        if (icomma < 0) {
                            icomma = length;
                        }
                    }
                    result.push(line.substring(i, icomma));
                    i = icomma;
                }
            }
            return result;
        }
        static parse(str) {
            const lines = str.split(/(?:\r\n?|\n)/g);
            const result = [];
            const state = new UtilCsvState(lines);
            while (state.next()) {
                const row = this.parseLine(state);
                if (0 < row.length) {
                    result.push(row);
                }
            }
            return result;
        }
        static stringifyLine(line) {
            let result = "";
            let delimiter = "";
            for (let i = 0, imax = line.length; i < imax; ++i) {
                result += delimiter + this.escape(String(line[i]));
                delimiter = ",";
            }
            return result;
        }
        static stringify(lines) {
            let result = "";
            let delimiter = "";
            for (let i = 0, imax = lines.length; i < imax; ++i) {
                result += delimiter + this.stringifyLine(lines[i]);
                delimiter = "\n";
            }
            return result;
        }
        static escape(target) {
            const result = target.replace(/"/g, '""');
            if (result.length !== target.length ||
                0 <= target.indexOf(",") ||
                0 <= target.indexOf("\n") ||
                0 <= target.indexOf("\r")) {
                return `"${result}"`;
            }
            return target;
        }
        static unescape(target) {
            return target.replace(/""/g, '"');
        }
    }

    function toGraphicTesterObject(data) {
        const rows = UtilCsv.parse(data);
        const result = new Map();
        for (let i = 0, imax = rows.length; i < imax; ++i) {
            const row = rows[i];
            const uuid = parseInt(row[0], 10);
            if (uuid === uuid) {
                const original = row[1] || "";
                const value = row[2] || "";
                if (0 < original.length && 0 < value.length) {
                    let object = result.get(uuid);
                    if (object == null) {
                        object = {};
                        result.set(uuid, object);
                    }
                    object[original] = value;
                }
            }
        }
        return result;
    }

    function toGraphicTesterSerialized(simple) {
        const parsed = JSON.parse(simple.mappings);
        const uuids = parsed[0];
        const objects = parsed[1];
        const mappings = new Map();
        for (let i = 0, imax = Math.min(uuids.length, objects.length); i < imax; ++i) {
            mappings.set(uuids[i], objects[i]);
        }
        return {
            id: simple.id,
            graphicId: simple.graphicId,
            name: simple.name,
            mappings
        };
    }

    function toGraphicTesterSimple(serialized) {
        const mappings = serialized.mappings;
        const uuids = [];
        const objects = [];
        mappings.forEach((object, key) => {
            uuids.push(key);
            objects.push(object);
        });
        return {
            id: serialized.id,
            graphicId: serialized.graphicId,
            name: serialized.name,
            mappings: JSON.stringify([uuids, objects])
        };
    }

    class EShapeActionExtensions {
        static add(extension) {
            var _a, _b;
            ((_a = this._typeToExtension) !== null && _a !== void 0 ? _a : (this._typeToExtension = new Map())).set(extension.type, extension);
            ((_b = this._extensions) !== null && _b !== void 0 ? _b : (this._extensions = [])).push(extension);
            wcardinalUi.EShapeActionValueDeserializers[extension.type] = extension.deserializer;
        }
        static get(type) {
            const typeToExtension = this._typeToExtension;
            if (typeToExtension != null) {
                return typeToExtension.get(type);
            }
        }
        static each(iteratee) {
            const extensions = this._extensions;
            if (extensions != null) {
                for (let i = 0, imax = extensions.length; i < imax; ++i) {
                    const extension = extensions[i];
                    iteratee(extension);
                }
            }
        }
    }

    const EShapeActionExtensionInputType = {
        TEXT: 0
    };

    class EDialogActionExtension {
        constructor(extension, dialog, condition, layout) {
            this._extension = extension;
            this._dialog = dialog;
            this._condition = condition;
            this._layout = layout;
        }
        get select() {
            let result = this._select;
            if (result === undefined) {
                result = this.newSelect();
                this._select = result;
            }
            return result;
        }
        newSelect() {
            const extensionItems = this._extension.items;
            if (extensionItems != null && 0 < extensionItems.length) {
                const result = new wcardinalUi.DSelect({
                    weight: 1,
                    value: extensionItems[0].type,
                    menu: {
                        items: this.newSelectMenuItems(extensionItems)
                    }
                });
                return result;
            }
            return null;
        }
        newSelectMenuItems(items) {
            const result = [];
            for (let i = 0, imax = items.length; i < imax; ++i) {
                const item = items[i];
                result.push({
                    value: item.type,
                    text: {
                        value: item.label
                    }
                });
            }
            return result;
        }
        get selectLayout() {
            let result = this._selectLayout;
            if (result === undefined) {
                result = this.newSelectLayout();
                if (result != null) {
                    const layout = this._layout;
                    const conditionIndex = layout.getChildIndex(this._condition);
                    if (0 <= conditionIndex) {
                        layout.addChildAt(result, conditionIndex);
                    }
                    else {
                        layout.addChild(result);
                    }
                }
                this._selectLayout = result;
            }
            return result;
        }
        newSelectLayout() {
            const select = this.select;
            if (select != null) {
                return this.newLabeled("", select);
            }
            return null;
        }
        get inputs() {
            let result = this._inputs;
            if (result === undefined) {
                result = this.newInputs();
                this._inputs = result;
            }
            return result;
        }
        newInputs() {
            const result = [];
            const extensionInputs = this._extension.inputs;
            if (extensionInputs != null) {
                for (let i = 0, imax = extensionInputs.length; i < imax; ++i) {
                    const input = extensionInputs[i];
                    switch (input.type) {
                        case EShapeActionExtensionInputType.TEXT:
                            const inputText = this.newInputText();
                            result.push(inputText);
                            break;
                    }
                }
            }
            return result;
        }
        newInputText() {
            return new wcardinalUi.DInputText({
                weight: 1,
                on: {
                    enter: () => {
                        this.ok();
                    }
                }
            });
        }
        newLabel(label) {
            return new wcardinalUi.DInputLabel({
                width: 60,
                text: {
                    value: label
                }
            });
        }
        newSpace() {
            return new wcardinalUi.DLayoutSpace({
                width: 60
            });
        }
        newLabeled(label, input) {
            return new wcardinalUi.DLayoutHorizontal({
                width: "padding",
                height: "auto",
                children: [
                    label != null ? this.newLabel(label) : this.newSpace(),
                    input,
                    this.newSpace()
                ]
            });
        }
        get inputLayouts() {
            let result = this._inputLayouts;
            if (result === undefined) {
                result = this.newInputLayouts();
                this._inputLayouts = result;
            }
            return result;
        }
        newInputLayouts() {
            const result = [];
            const inputs = this.inputs;
            const layout = this._layout;
            const extensionInputs = this._extension.inputs;
            if (extensionInputs != null) {
                const conditionIndex = layout.getChildIndex(this._condition);
                for (let i = 0, imax = inputs.length; i < imax; ++i) {
                    const labeled = this.newLabeled(extensionInputs[i].label, inputs[i]);
                    result.push(labeled);
                    if (0 <= conditionIndex) {
                        layout.addChildAt(labeled, conditionIndex + 1 + i);
                    }
                    else {
                        layout.addChild(labeled);
                    }
                }
            }
            return result;
        }
        get value() {
            return this._extension.toValue(this.select, this._condition.input, this.inputs);
        }
        set value(value) {
            if (value != null) {
                this._extension.fromValue(value, this.select, this._condition.input, this.inputs);
            }
        }
        show() {
            // Select
            const selectLayout = this.selectLayout;
            if (selectLayout != null) {
                selectLayout.show();
            }
            // Inputs
            const inputLayouts = this.inputLayouts;
            if (0 < inputLayouts.length) {
                const extension = this._extension;
                if (extension.onShow != null) {
                    extension.onShow(inputLayouts);
                }
                else {
                    for (let i = 0, imax = inputLayouts.length; i < imax; ++i) {
                        inputLayouts[i].show();
                    }
                }
            }
        }
        hide() {
            // Select
            const selectLayout = this._selectLayout;
            if (selectLayout != null) {
                selectLayout.hide();
            }
            // Inputs
            const inputLayouts = this._inputLayouts;
            if (inputLayouts != null) {
                for (let i = 0, imax = inputLayouts.length; i < imax; ++i) {
                    inputLayouts[i].hide();
                }
            }
        }
        reset() {
            // Select
            const select = this._select;
            if (select) {
                const items = this._extension.items;
                if (items != null && 0 < items.length) {
                    select.value = items[0].type;
                }
                else {
                    select.value = null;
                }
            }
            // Inputs
            const inputs = this._inputs;
            if (inputs) {
                const extensionInputs = this._extension.inputs;
                if (extensionInputs != null) {
                    for (let i = 0, imax = inputs.length; i < imax; ++i) {
                        inputs[i].value = extensionInputs[i].initial || "";
                    }
                }
            }
        }
        ok() {
            this._dialog.ok();
        }
    }

    class EDialogActionExtensionContainer {
        constructor(dialog, condition, layout) {
            this._data = new Map();
            this._dialog = dialog;
            this._condition = condition;
            this._layout = layout;
        }
        get value() {
            const selected = this._selected;
            if (selected) {
                return selected.value;
            }
            return null;
        }
        set value(value) {
            if (value != null) {
                const datum = this._data.get(value.type);
                if (datum != null) {
                    datum.value = value;
                }
            }
        }
        get(type) {
            const data = this._data;
            let result = data.get(type);
            if (result != null) {
                return result;
            }
            const e = EShapeActionExtensions.get(type);
            if (e == null) {
                return null;
            }
            result = new EDialogActionExtension(e, this._dialog, this._condition, this._layout);
            data.set(type, result);
            return result;
        }
        show(type) {
            if (type != null) {
                const datum = this.get(type);
                if (datum != null) {
                    const selected = this._selected;
                    if (selected !== datum) {
                        if (selected != null) {
                            selected.hide();
                        }
                        this._selected = datum;
                        datum.show();
                    }
                }
                else {
                    this.hide();
                }
            }
            else {
                this.hide();
            }
        }
        hide() {
            const selected = this._selected;
            if (selected != null) {
                selected.hide();
                this._selected = null;
            }
        }
        reset() {
            this._data.forEach((datum) => {
                datum.reset();
            });
        }
        onChange(type) {
            this.show(type);
        }
    }

    const toIconName$1 = (index) => {
        return `extension_icon_${index}`;
    };
    class EShapeExtensions {
        static add(extension) {
            var _a, _b;
            if ("type" in extension) {
                const type = extension.type;
                // Name
                ((_a = this._typeToExtension) !== null && _a !== void 0 ? _a : (this._typeToExtension = new Map())).set(type, extension);
                // Deserializer
                const deserializer = extension.deserializer;
                if (deserializer != null) {
                    wcardinalUi.EShapeDeserializers[type] = deserializer;
                }
                // OnDeserialized
                const onDeserialized = extension.onDeserialized;
                if (onDeserialized != null) {
                    wcardinalUi.EShapeOnDeserializeds[type] = onDeserialized;
                }
                // Runtime
                const runtime = extension.runtime;
                if (runtime) {
                    wcardinalUi.EShapeRuntimes[type] = runtime;
                }
                // Capability
                const capability = extension.capability;
                if (capability != null) {
                    wcardinalUi.EShapeCapabilities.set(type, capability);
                }
                // Uploaded
                const uploaded = extension.uploaded;
                if (uploaded != null) {
                    wcardinalUi.EShapeUploadeds[type] = uploaded;
                }
                else {
                    if (wcardinalUi.EShapeUploadeds[type] == null) {
                        wcardinalUi.EShapeUploadeds[type] = wcardinalUi.createGroupUploaded;
                    }
                }
            }
            ((_b = this._extensions) !== null && _b !== void 0 ? _b : (this._extensions = [])).push(extension);
        }
        static get(type) {
            const typeToExtension = this._typeToExtension;
            if (typeToExtension != null) {
                return typeToExtension.get(type);
            }
        }
        static each(iteratee) {
            const extensions = this._extensions;
            if (extensions != null) {
                for (let i = 0, imax = extensions.length; i < imax; ++i) {
                    const extension = extensions[i];
                    iteratee(extension);
                }
            }
        }
        static merge(iconBuilder) {
            const extensions = this._extensions;
            if (extensions != null) {
                for (let i = 0, imax = extensions.length; i < imax; ++i) {
                    const extension = extensions[i];
                    if ("icon" in extension) {
                        const icon = extension.icon;
                        iconBuilder.add(toIconName$1(i), icon.width, icon.height, icon.svg);
                    }
                }
            }
        }
        static build(icons) {
            const extensions = this._extensions;
            if (extensions != null) {
                for (let i = 0, imax = extensions.length; i < imax; ++i) {
                    const extension = extensions[i];
                    if ("icon" in extension) {
                        extension.icon.texture = icons[toIconName$1(i)];
                    }
                }
            }
        }
    }

    class ECommandShapeEmbeddedAcceptorEdgePropertySide extends ECommandShapePropertySimple {
        getProperty(shape, capability) {
            if (shape instanceof wcardinalUi.EShapeEmbeddedAcceptorEdge) {
                return shape.side;
            }
            return wcardinalUi.EShapeAcceptorEdgeSide.NONE;
        }
        setProperty(shape, capability, property) {
            if (shape instanceof wcardinalUi.EShapeEmbeddedAcceptorEdge) {
                shape.side = property;
            }
        }
    }

    class ECommandShapeEmbeddedAcceptorEdgePropertySubtype extends ECommandShapePropertySimple {
        getProperty(shape, capability) {
            if (shape instanceof wcardinalUi.EShapeEmbeddedAcceptorEdge) {
                return shape.subtype;
            }
            return wcardinalUi.EShapeAcceptorEdgeType.HEAD;
        }
        setProperty(shape, capability, property) {
            if (shape instanceof wcardinalUi.EShapeEmbeddedAcceptorEdge) {
                shape.subtype = property;
            }
        }
    }

    class ECommandShapeEmbeddedAcceptorEdgePropertyVvisible extends ECommandShapePropertySimple {
        getProperty(shape, capability) {
            if (shape instanceof wcardinalUi.EShapeEmbeddedAcceptorEdge) {
                return shape.vvisible;
            }
            return false;
        }
        setProperty(shape, capability, property) {
            if (shape instanceof wcardinalUi.EShapeEmbeddedAcceptorEdge) {
                shape.vvisible = property;
            }
        }
    }

    class EEditorShapeEmbeddedAcceptorEdge extends wcardinalUi.DPane {
        constructor(options) {
            super(options);
            this._icons = options.icons;
            const selection = options.selection;
            this._selection = selection;
            this._diagram = options.diagram;
            // Layout
            this.initLayout();
        }
        initLayout() {
            // Content height
            this.content.setHeight("padding");
            // Layout
            new wcardinalUi.DLayoutVertical({
                parent: this.content,
                x: "padding",
                y: "padding",
                width: "padding",
                height: "padding",
                children: [this.newTextLabel(), this.selectSubtype, this.selectSide, this.checkVvisible]
            });
            // Selection
            const selection = this._selection;
            this.state.isDisabled = selection.isEmpty();
            selection.on("change", () => {
                this.state.isDisabled = selection.isEmpty();
                this.onSelectionChange(selection);
            });
            this.onSelectionChange(selection);
        }
        newTextLabel() {
            return new wcardinalUi.DText({
                width: "100%",
                text: {
                    value: this.subtheme.getLabel()
                }
            });
        }
        get selectSubtype() {
            var _a;
            return ((_a = this._selectSubtype) !== null && _a !== void 0 ? _a : (this._selectSubtype = this.newSelectSubtype()));
        }
        newSelectSubtype() {
            const subtheme = this.subtheme;
            return new wcardinalUi.DSelect({
                width: "padding",
                value: wcardinalUi.EShapeAcceptorEdgeType.HEAD,
                menu: {
                    items: [
                        {
                            value: wcardinalUi.EShapeAcceptorEdgeType.HEAD,
                            text: {
                                value: subtheme.toSelectSubtypeLabel(wcardinalUi.EShapeAcceptorEdgeType.HEAD)
                            }
                        },
                        {
                            value: wcardinalUi.EShapeAcceptorEdgeType.TAIL,
                            text: {
                                value: subtheme.toSelectSubtypeLabel(wcardinalUi.EShapeAcceptorEdgeType.TAIL)
                            }
                        },
                        {
                            value: wcardinalUi.EShapeAcceptorEdgeType.ALL,
                            text: {
                                value: subtheme.toSelectSubtypeLabel(wcardinalUi.EShapeAcceptorEdgeType.ALL)
                            }
                        }
                    ]
                },
                on: {
                    change: (value) => {
                        this.onSelectSubtypeChanged(value);
                    }
                }
            });
        }
        onSelectSubtypeChanged(value) {
            wcardinalUi.DControllers.getCommandController().push(new ECommandShapeEmbeddedAcceptorEdgePropertySubtype(this._selection, value));
        }
        get selectSide() {
            var _a;
            return ((_a = this._selectSide) !== null && _a !== void 0 ? _a : (this._selectSide = this.newSelectSide()));
        }
        newSelectSide() {
            const subtheme = this.subtheme;
            return new wcardinalUi.DSelectMultiple({
                width: "padding",
                values: [wcardinalUi.EShapeAcceptorEdgeSide.LEFT],
                menu: {
                    items: [
                        {
                            value: wcardinalUi.EShapeAcceptorEdgeSide.LEFT,
                            text: {
                                value: subtheme.toSelectSideLabel(wcardinalUi.EShapeAcceptorEdgeSide.LEFT)
                            },
                            check: true
                        },
                        {
                            value: wcardinalUi.EShapeAcceptorEdgeSide.TOP,
                            text: {
                                value: subtheme.toSelectSideLabel(wcardinalUi.EShapeAcceptorEdgeSide.TOP)
                            },
                            check: true
                        },
                        {
                            value: wcardinalUi.EShapeAcceptorEdgeSide.RIGHT,
                            text: {
                                value: subtheme.toSelectSideLabel(wcardinalUi.EShapeAcceptorEdgeSide.RIGHT)
                            },
                            check: true
                        },
                        {
                            value: wcardinalUi.EShapeAcceptorEdgeSide.BOTTOM,
                            text: {
                                value: subtheme.toSelectSideLabel(wcardinalUi.EShapeAcceptorEdgeSide.BOTTOM)
                            },
                            check: true
                        }
                    ]
                },
                on: {
                    change: (values) => {
                        this.onSelectSideChange(values);
                    }
                }
            });
        }
        onSelectSideChange(values) {
            wcardinalUi.DControllers.getCommandController().push(new ECommandShapeEmbeddedAcceptorEdgePropertySide(this._selection, this.fromSelectSideValues(values)));
        }
        toSelectSideValues(value) {
            const result = [];
            if (value & wcardinalUi.EShapeAcceptorEdgeSide.LEFT) {
                result.push(wcardinalUi.EShapeAcceptorEdgeSide.LEFT);
            }
            if (value & wcardinalUi.EShapeAcceptorEdgeSide.TOP) {
                result.push(wcardinalUi.EShapeAcceptorEdgeSide.TOP);
            }
            if (value & wcardinalUi.EShapeAcceptorEdgeSide.RIGHT) {
                result.push(wcardinalUi.EShapeAcceptorEdgeSide.RIGHT);
            }
            if (value & wcardinalUi.EShapeAcceptorEdgeSide.BOTTOM) {
                result.push(wcardinalUi.EShapeAcceptorEdgeSide.BOTTOM);
            }
            return result;
        }
        fromSelectSideValues(values) {
            let result = wcardinalUi.EShapeAcceptorEdgeSide.NONE;
            for (let i = 0, imax = values.length; i < imax; ++i) {
                result |= values[i];
            }
            return result;
        }
        get checkVvisible() {
            var _a;
            return ((_a = this._checkVvisible) !== null && _a !== void 0 ? _a : (this._checkVvisible = this.newCheckIsVvisible()));
        }
        newCheckIsVvisible() {
            return new wcardinalUi.DButtonCheckRight({
                width: "padding",
                text: {
                    value: this.subtheme.getCheckIsVvisibleLabel()
                },
                on: {
                    active: () => {
                        this.onCheckVvisibleChanged(true);
                    },
                    inactive: () => {
                        this.onCheckVvisibleChanged(false);
                    }
                }
            });
        }
        onCheckVvisibleChanged(isVvisible) {
            wcardinalUi.DControllers.getCommandController().push(new ECommandShapeEmbeddedAcceptorEdgePropertyVvisible(this._selection, isVvisible));
        }
        onSelectionChange(selection) {
            const selectSubtype = this.selectSubtype;
            const selectSide = this.selectSide;
            const checkVvisible = this.checkVvisible;
            const last = selection.last();
            if (last instanceof wcardinalUi.EShapeEmbeddedAcceptorEdge) {
                selectSubtype.value = last.subtype;
                selectSubtype.state.isEnabled = true;
                selectSide.values = this.toSelectSideValues(last.side);
                selectSide.state.isEnabled = true;
                checkVvisible.state.isActive = last.vvisible;
                checkVvisible.state.isEnabled = true;
            }
            else {
                selectSubtype.state.isEnabled = false;
                selectSide.state.isEnabled = false;
                checkVvisible.state.isEnabled = false;
            }
        }
        get subtheme() {
            var _a;
            return ((_a = this._subtheme) !== null && _a !== void 0 ? _a : (this._subtheme = this.newSubtheme()));
        }
        newSubtheme() {
            return wcardinalUi.DThemes.get("EEditorShapeEmbeddedAcceptorEdge");
        }
    }

    class EShapeEmbeddedAcceptorEdges {
        static getTheme() {
            return wcardinalUi.DThemes.get("EShapeEmbeddedAcceptorEdge");
        }
        static create(existing) {
            const result = new wcardinalUi.EShapeEmbeddedAcceptorEdge();
            if (existing) {
                result.copy(existing);
            }
            else {
                result.subtype = wcardinalUi.EShapeAcceptorEdgeType.HEAD; // Connectable to heads only
                result.side = wcardinalUi.EShapeAcceptorEdgeSide.LEFT; // Connectable from the left side
                result.vvisible = true; // True if visible in the viewer mode
                result.stroke.set(false, 0x3399ff, 1);
                result.fill.set(true, 0x3399ff, 1);
            }
            return result;
        }
        static load() {
            const theme = this.getTheme();
            const name = theme.getName();
            EShapeExtensions.add({
                type: wcardinalUi.EShapeType.EMBEDDED_ACCEPTOR_EDGE,
                name,
                icon: {
                    width: 24,
                    height: 24,
                    // Material Icons https://material.io/tools/icons/
                    // Available under Apache license version 2.0
                    svg: `<g transform="scale(0.667,0.667) translate(480, 480) rotate(+90) translate(-480, 480)" fill="#fff" stroke="none">` +
                        `<path d="M480-640 280-440l56 56 104-103v407h80v-407l104 103 56-56-200-200ZM146-260q-32-49-49-105T80-480q0-83 31.5` +
                        `-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 59-17 115t-49 105l-58-58q22-37` +
                        ` 33-78t11-84q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 43 11 84t33 78l-58 58Z"/>` +
                        `</g>`
                },
                title: name,
                creator: (existing) => EShapeEmbeddedAcceptorEdges.create(existing),
                editor: EEditorShapeEmbeddedAcceptorEdge
            });
        }
    }

    const loadShapeExtensionEmbeddedAcceptorEdge = () => {
        EShapeEmbeddedAcceptorEdges.load();
    };

    class ECommandShapeButtonPropertyIsActive extends ECommandShapePropertySimple {
        getProperty(shape, capability) {
            if (shape instanceof wcardinalUi.EShapeButton) {
                return shape.state.isActive;
            }
            return false;
        }
        setProperty(shape, capability, property) {
            if (shape instanceof wcardinalUi.EShapeButton) {
                shape.state.isActive = property;
            }
        }
    }

    class ECommandShapeButtonPropertyIsGrouped extends ECommandShapePropertySimple {
        getProperty(shape, capability) {
            if (shape instanceof wcardinalUi.EShapeButton) {
                return shape.isGrouped;
            }
            return false;
        }
        setProperty(shape, capability, property) {
            if (shape instanceof wcardinalUi.EShapeButton) {
                shape.isGrouped = property;
            }
        }
    }

    class ECommandShapeButtonPropertyIsToggle extends ECommandShapePropertySimple {
        getProperty(shape, capability) {
            if (shape instanceof wcardinalUi.EShapeButton) {
                return shape.isToggle;
            }
            return false;
        }
        setProperty(shape, capability, property) {
            if (shape instanceof wcardinalUi.EShapeButton) {
                shape.isToggle = property;
            }
        }
    }

    class EEditorShapeButton extends wcardinalUi.DPane {
        constructor(options) {
            super(options);
            this._icons = options.icons;
            const selection = options.selection;
            this._selection = selection;
            this._diagram = options.diagram;
            // Layout
            this.initLayout();
        }
        initLayout() {
            // Content height
            this.content.setHeight("padding");
            // Layout
            new wcardinalUi.DLayoutVertical({
                parent: this.content,
                x: "padding",
                y: "padding",
                width: "padding",
                height: "padding",
                children: [
                    this.newTextLabel(),
                    this.checkIsToggle,
                    this.checkIsGrouped,
                    this.checkIsActive
                ]
            });
            // Selection
            const selection = this._selection;
            this.state.isDisabled = selection.isEmpty();
            selection.on("change", () => {
                this.state.isDisabled = selection.isEmpty();
                this.onSelectionChange(selection);
            });
            this.onSelectionChange(selection);
        }
        newTextLabel() {
            return new wcardinalUi.DText({
                width: "100%",
                text: {
                    value: this.subtheme.getLabel()
                }
            });
        }
        get checkIsToggle() {
            var _a;
            return ((_a = this._checkIsToggle) !== null && _a !== void 0 ? _a : (this._checkIsToggle = this.newCheckIsToggle()));
        }
        newCheckIsToggle() {
            return new wcardinalUi.DButtonCheckRight({
                width: "padding",
                text: {
                    value: this.subtheme.getCheckIsToggleLabel()
                },
                on: {
                    active: () => {
                        this.onCheckIsToggleChanged(true);
                    },
                    inactive: () => {
                        this.onCheckIsToggleChanged(false);
                    }
                }
            });
        }
        onCheckIsToggleChanged(isActive) {
            wcardinalUi.DControllers.getCommandController().push(new ECommandShapeButtonPropertyIsToggle(this._selection, isActive));
        }
        onSelectionChangeCheckIsToggle(selection) {
            const state = this.checkIsToggle.state;
            const last = selection.last();
            if (last instanceof wcardinalUi.EShapeButton) {
                state.lock();
                state.isActive = last.isToggle;
                state.isDisabled = false;
                state.unlock();
            }
            else {
                state.isDisabled = true;
            }
        }
        get checkIsGrouped() {
            var _a;
            return ((_a = this._checkIsGrouped) !== null && _a !== void 0 ? _a : (this._checkIsGrouped = this.newCheckIsGrouped()));
        }
        newCheckIsGrouped() {
            return new wcardinalUi.DButtonCheckRight({
                width: "padding",
                text: {
                    value: this.subtheme.getCheckIsGroupedLabel()
                },
                on: {
                    active: () => {
                        this.onCheckIsGroupedChanged(true);
                    },
                    inactive: () => {
                        this.onCheckIsGroupedChanged(false);
                    }
                }
            });
        }
        onCheckIsGroupedChanged(isActive) {
            wcardinalUi.DControllers.getCommandController().push(new ECommandShapeButtonPropertyIsGrouped(this._selection, isActive));
        }
        onSelectionChangeCheckIsGrouped(selection) {
            const state = this.checkIsGrouped.state;
            const last = selection.last();
            if (last instanceof wcardinalUi.EShapeButton) {
                state.lock();
                state.isActive = last.isGrouped;
                state.isDisabled = false;
                state.unlock();
            }
            else {
                state.isDisabled = true;
            }
        }
        get checkIsActive() {
            var _a;
            return ((_a = this._checkIsActive) !== null && _a !== void 0 ? _a : (this._checkIsActive = this.newCheckIsActive()));
        }
        newCheckIsActive() {
            return new wcardinalUi.DButtonCheckRight({
                width: "padding",
                text: {
                    value: this.subtheme.getCheckIsActiveLabel()
                },
                on: {
                    active: () => {
                        this.onCheckIsActiveChanged(true);
                    },
                    inactive: () => {
                        this.onCheckIsActiveChanged(false);
                    }
                }
            });
        }
        onCheckIsActiveChanged(isActive) {
            wcardinalUi.DControllers.getCommandController().push(new ECommandShapeButtonPropertyIsActive(this._selection, isActive));
        }
        onSelectionChangeCheckIsActive(selection) {
            const state = this.checkIsActive.state;
            const last = selection.last();
            if (last instanceof wcardinalUi.EShapeButton) {
                state.lock();
                state.isActive = last.state.isActive;
                state.isDisabled = false;
                state.unlock();
            }
            else {
                state.isDisabled = true;
            }
        }
        onSelectionChange(selection) {
            this.onSelectionChangeCheckIsToggle(selection);
            this.onSelectionChangeCheckIsGrouped(selection);
            this.onSelectionChangeCheckIsActive(selection);
        }
        get subtheme() {
            var _a;
            return ((_a = this._subtheme) !== null && _a !== void 0 ? _a : (this._subtheme = this.newSubtheme()));
        }
        newSubtheme() {
            return wcardinalUi.DThemes.get("EEditorShapeButton");
        }
    }

    class EShapeButtons {
        static getTheme() {
            return wcardinalUi.DThemes.get("EShapeButton");
        }
        static create(existing) {
            const result = new wcardinalUi.EShapeButton();
            if (existing) {
                result.copy(existing);
            }
            else {
                const label = this.getTheme().getLabel();
                result.stroke.set(false, 0x3399ff, 1);
                result.fill.set(true, 0x3399ff, 1);
                result.text.set(label, 0xffffff, 1);
                result.cursor = "pointer";
                result.state.isFocusable = true;
                result.interactive = true;
            }
            return result;
        }
        static load() {
            const theme = this.getTheme();
            const name = theme.getName();
            EShapeExtensions.add({
                type: wcardinalUi.EShapeType.BUTTON,
                name,
                icon: {
                    width: 24,
                    height: 24,
                    // Material Icons https://material.io/tools/icons/
                    // Available under Apache license version 2.0
                    svg: `<g transform="scale(26.6666)" fill="#fff" stroke="none">` +
                        `<path d="M22,9v6c0,1.1-0.9,2-2,2h-1l0-2h1V9H4v6h6v2H4c-1.1,0-2` +
                        `-0.9-2-2V9c0-1.1,0.9-2,2-2h16C21.1,7,22,7.9,22,9z M14.5,19 l1.` +
                        `09-2.41L18,15.5l-2.41-1.09L14.5,12l-1.09,2.41L11,15.5l2.41,1.0` +
                        `9L14.5,19z M17,14l0.62-1.38L19,12l-1.38-0.62L17,10l-0.62,1.38 ` +
                        `L15,12l1.38,0.62L17,14z M14.5,19l1.09-2.41L18,15.5l-2.41-1.09L` +
                        `14.5,12l-1.09,2.41L11,15.5l2.41,1.09L14.5,19z M17,14l0.62-1.38` +
                        ` L19,12l-1.38-0.62L17,10l-0.62,1.38L15,12l1.38,0.62L17,14z"/>` +
                        `</g>`
                },
                title: name,
                creator: (existing) => EShapeButtons.create(existing),
                editor: EEditorShapeButton
            });
        }
    }

    const loadShapeExtensionButton = () => {
        EShapeButtons.load();
    };

    class EShapeButtonLayerButtonValue {
        constructor(label, weight, layers, bringToFront, isGrouped, isActive) {
            this.label = label;
            this.weight = weight;
            this.layers = layers;
            this.bringToFront = bringToFront;
            this.isGrouped = isGrouped;
            this.isActive = isActive;
            this.action = new wcardinalUi.EShapeActionValueShowHideLayer("isActive", layers, bringToFront);
        }
        isEquals(target) {
            if (this.label !== target.label) {
                return false;
            }
            if (this.weight !== target.weight) {
                return false;
            }
            if (this.bringToFront !== target.bringToFront) {
                return false;
            }
            if (this.isGrouped !== target.isGrouped) {
                return false;
            }
            if (this.isActive !== target.isActive) {
                return false;
            }
            const layers = this.layers;
            const layersLength = layers.length;
            const targetLayers = target.layers;
            if (layersLength !== targetLayers.length) {
                return false;
            }
            for (let i = 0; i < layersLength; ++i) {
                if (layers[i] !== targetLayers[i]) {
                    return false;
                }
            }
            return true;
        }
        serizlize(manager) {
            const layersId = this.serializedLayers(manager);
            const bringToFront = this.bringToFront ? 1 : 0;
            const isGrouped = this.isGrouped ? 2 : 0;
            const isActive = this.isActive ? 4 : 0;
            const type = bringToFront | isGrouped | isActive;
            return manager.addResource(`[${manager.addResource(this.label)},${this.weight},${layersId},${type}]`);
        }
        serializedLayers(manager) {
            const layers = this.layers;
            let serialized = "[";
            let delimiter = "";
            for (let i = 0, imax = layers.length; i < imax; ++i) {
                serialized += delimiter + layers[i];
                delimiter = ",";
            }
            serialized += "]";
            return manager.addResource(serialized);
        }
        static deserialize(target, manager) {
            const resources = manager.resources;
            if (0 <= target && target < resources.length) {
                let parsed = manager.getExtension(target);
                if (parsed == null) {
                    parsed = JSON.parse(resources[target]);
                    manager.setExtension(target, parsed);
                }
                return new EShapeButtonLayerButtonValue(resources[parsed[0]], parsed[1], this.deserializeLayers(parsed[2], manager), !!(parsed[3] & 0x1), !!(parsed[3] & 0x2), !!(parsed[3] & 0x4));
            }
            return null;
        }
        static deserializeLayers(target, manager) {
            const result = [];
            const resources = manager.resources;
            const resourcesLength = resources.length;
            if (0 <= target && target < resourcesLength) {
                let parsed = manager.getExtension(target);
                if (parsed == null) {
                    parsed = JSON.parse(resources[target]);
                    manager.setExtension(target, parsed);
                }
                for (let i = 0, imax = parsed.length; i < imax; ++i) {
                    result.push(parsed[i]);
                }
            }
            return result;
        }
    }

    class EShapeButtonLayerButtonValueContainer {
        constructor(onChange) {
            this._values = [];
            this._sizeX = 1;
            this._margin = 2;
            this._onChange = onChange;
        }
        get values() {
            return this._values;
        }
        get margin() {
            return this._margin;
        }
        set margin(margin) {
            if (this._margin !== margin) {
                this._margin = margin;
                this._onChange();
            }
        }
        add(value, at) {
            if (at != null) {
                this._values.splice(at, 0, value);
            }
            else {
                this._values.push(value);
            }
            this._onChange();
        }
        remove(index) {
            const values = this._values;
            if (0 <= index && index < values.length) {
                const result = values.splice(index, 1)[0];
                this._onChange();
                return result;
            }
            return null;
        }
        indexOf(target) {
            const values = this._values;
            // Instance-based matching
            for (let i = 0, imax = values.length; i < imax; ++i) {
                const value = values[i];
                if (value === target) {
                    return i;
                }
            }
            // Data-based matching
            for (let i = 0, imax = values.length; i < imax; ++i) {
                const value = values[i];
                if (value.isEquals(target)) {
                    return i;
                }
            }
            return -1;
        }
        get(index) {
            const result = this._values[index];
            if (result != null) {
                return result;
            }
            return null;
        }
        set(index, value) {
            this._values[index] = value;
            this._onChange();
        }
        swap(indexA, indexB) {
            const values = this._values;
            const tmp = values[indexB];
            values[indexB] = values[indexA];
            values[indexA] = tmp;
            this._onChange();
        }
        size() {
            return this._values.length;
        }
        copy(source) {
            // Values
            const values = this._values;
            const sourceValues = source._values;
            const sourceValuesLength = sourceValues.length;
            for (let i = 0; i < sourceValuesLength; ++i) {
                values[i] = sourceValues[i];
            }
            if (values.length !== sourceValuesLength) {
                values.length = sourceValuesLength;
            }
            //
            this._sizeX = source._sizeX;
            this._onChange();
            return this;
        }
        serialize(manager) {
            let serialized = "";
            let delimiter = "[";
            const values = this._values;
            for (let i = 0, imax = values.length; i < imax; ++i) {
                serialized += delimiter + values[i].serizlize(manager);
                delimiter = ",";
            }
            serialized += delimiter + this._margin + "]";
            return manager.addResource(serialized);
        }
        deserialize(target, manager) {
            const resources = manager.resources;
            if (0 <= target && target < resources.length) {
                let parsed = manager.getExtension(target);
                if (parsed == null) {
                    parsed = JSON.parse(resources[target]);
                    manager.setExtension(target, parsed);
                }
                let isChanged = false;
                const values = this._values;
                if (0 < values.length) {
                    values.length = 0;
                    isChanged = true;
                }
                for (let i = 0, imax = parsed.length - 1; i < imax; ++i) {
                    const value = EShapeButtonLayerButtonValue.deserialize(parsed[i], manager);
                    if (value != null) {
                        values.push(value);
                    }
                }
                const margin = parsed[parsed.length - 1];
                if (this._margin !== margin) {
                    this._margin = margin;
                    isChanged = true;
                }
                if (0 < values.length) {
                    isChanged = true;
                }
                if (isChanged) {
                    this._onChange();
                }
            }
        }
    }

    class EShapeButtonLayerIds {
    }
    EShapeButtonLayerIds.ID = wcardinalUi.EShapeType.EXTENSION + 200;

    class EShapeButtonLayer extends wcardinalUi.EShapeGroupShadowed {
        constructor(mode, type = EShapeButtonLayerIds.ID) {
            super(mode, type);
            this._button = new EShapeButtonLayerButtonValueContainer(() => {
                this.onButtonValueChange();
            });
            this._corner = wcardinalUi.EShapeCorner.ALL;
        }
        get button() {
            return this._button;
        }
        get corner() {
            return this._corner;
        }
        set corner(corner) {
            if (this._corner !== corner) {
                this._corner = corner;
                this.updateUploaded();
            }
        }
        onButtonValueChange() {
            this.newButtons();
            this.layoutButtons();
        }
        onSizeChange() {
            super.onSizeChange();
            this.layoutButtons();
        }
        newButtons() {
            const shapeButton = this.button;
            const buttonCount = shapeButton.size();
            const values = shapeButton.values;
            const children = this.children;
            const childrenLength = children.length;
            // Create / delete children
            if (childrenLength < buttonCount) {
                const master = 0 < childrenLength ? children[childrenLength - 1] : null;
                for (let i = childrenLength; i < buttonCount; ++i) {
                    const button = new wcardinalUi.EShapeButton();
                    const value = values[i];
                    if (master != null) {
                        button.copy(master);
                        button.text.value = value.label;
                    }
                    else {
                        button.stroke.set(false, 0x3399ff, 1);
                        button.fill.set(true, 0x3399ff, 1);
                        button.text.set(value.label, 0xffffff, 1);
                        button.state.isFocusable = true;
                        button.interactive = true;
                    }
                    if (0 < button.action.size()) {
                        button.action.set(0, value.action);
                    }
                    else {
                        button.action.add(value.action);
                    }
                    button.isToggle = true;
                    button.isGrouped = true;
                    button.attach(this);
                }
            }
            else if (buttonCount < childrenLength) {
                for (let i = childrenLength - 1; buttonCount <= i; --i) {
                    children[i].detach();
                }
            }
            // Update corner, action and state
            const corner = this.corner;
            for (let i = 0; i < buttonCount; ++i) {
                const child = children[i];
                const value = values[i];
                child.corner = this.toCorner(i, buttonCount, corner);
                child.text.value = value.label;
                if (0 < child.action.size()) {
                    child.action.set(0, value.action);
                }
                else {
                    child.action.add(value.action);
                }
                child.state.isActive = value.isActive;
            }
        }
        layoutButtons() {
            const button = this.button;
            const buttonValues = button.values;
            const buttonValuesLength = buttonValues.length;
            const buttonMargin = button.margin;
            const size = this.size;
            const sizeX = size.x;
            const sizeY = size.y;
            const children = this.children;
            const childrenLength = children.length;
            // Total weight
            let totalWeight = 0;
            for (let i = 0; i < buttonValuesLength; ++i) {
                totalWeight += buttonValues[i].weight;
            }
            totalWeight = Math.max(0.0001, totalWeight);
            const buttonSpace = Math.max(0, sizeX - (buttonValuesLength - 1) * buttonMargin);
            const buttonSpaceFactor = buttonSpace / totalWeight;
            // Update
            let x = -sizeX * 0.5;
            for (let i = 0; i < childrenLength; ++i) {
                const buttonValue = buttonValues[i];
                const width = buttonValue.weight * buttonSpaceFactor;
                const child = children[i];
                child.lock(wcardinalUi.EShapeLockPart.ALL);
                child.size.set(width, sizeY);
                child.transform.position.set(x + width * 0.5, 0);
                child.unlock(wcardinalUi.EShapeLockPart.ALL, true);
                x += width + buttonMargin;
            }
        }
        toCorner(index, size, corner) {
            let result = wcardinalUi.EShapeCorner.NONE;
            if (index === 0) {
                result |= wcardinalUi.EShapeCorner.LEFT & corner;
            }
            if (index === size - 1) {
                result |= wcardinalUi.EShapeCorner.RIGHT & corner;
            }
            return result;
        }
        copy(source, part = wcardinalUi.EShapeCopyPart.ALL) {
            const result = super.copy(source, part);
            if (source instanceof EShapeButtonLayer) {
                this._button.copy(source.button);
            }
            return result;
        }
        serialize(manager) {
            const result = super.serialize(manager);
            const resource = result[15];
            result[15] = manager.addResource(`[${this._button.serialize(manager)},${resource}]`);
            return result;
        }
    }

    class ECommandShapeButtonLayerValueAdd extends wcardinalUi.DCommandBase {
        constructor(value, selection) {
            super();
            this._selection = selection;
            this._value = value;
        }
        execute() {
            return this.redo();
        }
        redo() {
            const value = this._value;
            const shapes = this._selection.get();
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                if (shape instanceof EShapeButtonLayer) {
                    shape.button.add(value);
                }
            }
            this._selection.update("PROPERTY");
            return true;
        }
        undo() {
            const shapes = this._selection.get();
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                if (shape instanceof EShapeButtonLayer) {
                    shape.button.remove(shape.button.size() - 1);
                }
            }
            this._selection.update("PROPERTY");
            return true;
        }
    }

    class ECommandShapeButtonLayerValueBringForward extends wcardinalUi.DCommandBase {
        constructor(target, selection) {
            super();
            this._selection = selection;
            this._target = target;
            const indices = [];
            const shapes = this._selection.get();
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                if (shape instanceof EShapeButtonLayer) {
                    const index = shape.button.indexOf(target);
                    indices.push(index);
                    if (0 < index) {
                        shape.button.swap(index - 1, index);
                    }
                }
            }
            this._indices = indices;
            this._selection.update("PROPERTY");
        }
        execute() {
            return true;
        }
        redo() {
            const shapes = this._selection.get();
            const indices = this._indices;
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                if (shape instanceof EShapeButtonLayer) {
                    const index = indices[i];
                    if (0 < index) {
                        shape.button.swap(index - 1, index);
                    }
                }
            }
            this._selection.update("PROPERTY");
            return true;
        }
        undo() {
            return this.redo();
        }
    }

    class ECommandShapeButtonLayerValueMargin extends wcardinalUi.DCommandBase {
        constructor(value, selection) {
            super();
            const shapes = selection.get();
            const values = [];
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                if (shape instanceof EShapeButtonLayer) {
                    values.push(shape.button.margin);
                    shape.button.margin = value;
                }
                else {
                    values.push(0);
                }
            }
            this._values = values;
            this._selection = selection;
        }
        execute() {
            return true;
        }
        redo() {
            const selection = this._selection;
            const shapes = selection.get();
            const values = [];
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                if (shape instanceof EShapeButtonLayer) {
                    const value = values[i];
                    values[i] = shape.button.margin;
                    shape.button.margin = value;
                }
            }
            selection.update("PROPERTY");
            return true;
        }
        undo() {
            return this.redo();
        }
    }

    class ECommandShapeButtonLayerValueRemove extends wcardinalUi.DCommandBase {
        constructor(target, selection) {
            super();
            this._selection = selection;
            this._target = target;
            const indices = [];
            const shapes = this._selection.get();
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                if (shape instanceof EShapeButtonLayer) {
                    const index = shape.button.indexOf(target);
                    indices.push(index);
                    if (0 <= index) {
                        shape.button.remove(index);
                    }
                }
            }
            this._indices = indices;
            this._selection.update("PROPERTY");
        }
        execute() {
            return true;
        }
        redo() {
            const indices = this._indices;
            const shapes = this._selection.get();
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                if (shape instanceof EShapeButtonLayer) {
                    const index = indices[i];
                    if (0 <= index) {
                        shape.button.remove(index);
                    }
                }
            }
            this._selection.update("PROPERTY");
            return true;
        }
        undo() {
            const target = this._target;
            const indices = this._indices;
            const shapes = this._selection.get();
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                if (shape instanceof EShapeButtonLayer) {
                    const index = indices[i];
                    if (0 <= index) {
                        shape.button.add(target, index);
                    }
                }
            }
            this._selection.update("PROPERTY");
            return true;
        }
    }

    class ECommandShapeButtonLayerValueReplace extends wcardinalUi.DCommandBase {
        constructor(oldValue, newValue, selection, list) {
            super();
            this._selection = selection;
            this._oldValue = oldValue;
            this._newValue = newValue;
            this._list = list;
            const indices = [];
            const oldValues = [];
            const shapes = this._selection.get();
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                if (shape instanceof EShapeButtonLayer) {
                    const index = shape.button.indexOf(oldValue);
                    indices.push(index);
                    if (0 <= index) {
                        oldValues.push(shape.button.get(index));
                        shape.button.set(index, newValue);
                    }
                    else {
                        oldValues.push(newValue);
                    }
                }
                else {
                    indices.push(-1);
                    oldValues.push(newValue);
                }
            }
            this._indices = indices;
            this._oldValues = oldValues;
            if (list.data.selection.contains(oldValue)) {
                list.data.selection.clearAndAdd(newValue);
            }
            this._selection.update("PROPERTY");
        }
        execute() {
            return true;
        }
        redo() {
            const newValue = this._newValue;
            const indices = this._indices;
            const shapes = this._selection.get();
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                if (shape instanceof EShapeButtonLayer) {
                    const index = indices[i];
                    if (0 <= index) {
                        shape.button.set(index, newValue);
                    }
                }
            }
            const list = this._list;
            if (list.data.selection.contains(this._oldValue)) {
                list.data.selection.clearAndAdd(newValue);
            }
            this._selection.update("PROPERTY");
            return true;
        }
        undo() {
            const indices = this._indices;
            const oldValues = this._oldValues;
            const shapes = this._selection.get();
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                if (shape instanceof EShapeButtonLayer) {
                    const index = indices[i];
                    if (0 <= index) {
                        shape.button.set(index, oldValues[i]);
                    }
                }
            }
            const list = this._list;
            if (list.data.selection.contains(this._newValue)) {
                list.data.selection.clearAndAdd(this._oldValue);
            }
            this._selection.update("PROPERTY");
            return true;
        }
    }

    class ECommandShapeButtonLayerValueSendBackward extends wcardinalUi.DCommandBase {
        constructor(target, selection) {
            super();
            this._selection = selection;
            this._target = target;
            const indices = [];
            const shapes = this._selection.get();
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                if (shape instanceof EShapeButtonLayer) {
                    const button = shape.button;
                    const index = button.indexOf(target);
                    indices.push(index);
                    if (0 <= index && index < button.size() - 1) {
                        button.swap(index + 1, index);
                    }
                }
                else {
                    indices.push(-1);
                }
            }
            this._indices = indices;
            this._selection.update("PROPERTY");
        }
        execute() {
            return true;
        }
        redo() {
            const shapes = this._selection.get();
            const indices = this._indices;
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                if (shape instanceof EShapeButtonLayer) {
                    const button = shape.button;
                    const index = indices[i];
                    if (0 <= index && index < button.size() - 1) {
                        button.swap(index + 1, index);
                    }
                }
            }
            this._selection.update("PROPERTY");
            return true;
        }
        undo() {
            return this.redo();
        }
    }

    class EDialogShapeButtonLayerValue extends wcardinalUi.DDialogLayered {
        newContentChildren(theme, options) {
            const result = super.newContentChildren(theme, options);
            result.push(this.inputLabel, this.inputWidth, this.newLayoutOf(theme.getSelectLayerLabel(), this.selectLayer), this.newLayoutOf(null, this.checkBringToFront), this.newLayoutOf(null, this.checkIsGrouped), this.newLayoutOf(null, this.checkIsActive));
            return result;
        }
        newLayoutOf(label, target) {
            return new wcardinalUi.DLayoutHorizontal({
                width: "padding",
                height: "auto",
                children: [this.newLayoutLabel(label), target, this.newLayoutSpace()]
            });
        }
        newLayoutLabel(label) {
            if (label != null) {
                return new wcardinalUi.DInputLabel({
                    width: 60,
                    text: {
                        value: label
                    }
                });
            }
            else {
                return this.newLayoutSpace();
            }
        }
        newLayoutSpace() {
            return new wcardinalUi.DLayoutSpace({
                width: 60
            });
        }
        get inputLabel() {
            var _a;
            return ((_a = this._inputLabel) !== null && _a !== void 0 ? _a : (this._inputLabel = this.newInputLabel()));
        }
        newInputLabel() {
            return new wcardinalUi.DInputTextAndLabel({
                width: "padding",
                height: "auto",
                label: {
                    width: 60,
                    text: {
                        value: this.theme.getInputLabelLabel()
                    }
                },
                input: {
                    weight: 1,
                    text: {
                        value: ""
                    },
                    on: {
                        enter: () => {
                            this.ok();
                        }
                    }
                },
                space: {
                    width: 60
                }
            });
        }
        get inputWidth() {
            var _a;
            return ((_a = this._inputWidth) !== null && _a !== void 0 ? _a : (this._inputWidth = this.newInputWidth()));
        }
        newInputWidth() {
            return new wcardinalUi.DInputRealAndLabel({
                width: "padding",
                height: "auto",
                label: {
                    width: 60,
                    text: {
                        value: this.theme.getInputWidthLabel()
                    }
                },
                input: {
                    weight: 1,
                    text: {
                        value: 0
                    },
                    min: 0,
                    on: {
                        enter: () => {
                            this.ok();
                        }
                    }
                },
                space: {
                    width: 60
                }
            });
        }
        get selectLayer() {
            var _a;
            return ((_a = this._selectLayer) !== null && _a !== void 0 ? _a : (this._selectLayer = this.newSelectLayer()));
        }
        newSelectLayer() {
            return new wcardinalUi.DSelectMultiple({
                weight: 1
            });
        }
        newSelectLayerMenuItemOptions() {
            var _a;
            const diagram = (_a = this.options) === null || _a === void 0 ? void 0 : _a.diagram;
            if (diagram != null) {
                const canvas = diagram.canvas;
                if (canvas != null) {
                    const result = [];
                    const layers = canvas.layer.children;
                    for (let i = layers.length - 1; 0 <= i; --i) {
                        const layer = layers[i];
                        result.push({
                            value: i,
                            text: {
                                value: layer.name
                            },
                            check: true
                        });
                    }
                    return result;
                }
            }
            return [];
        }
        get checkBringToFront() {
            var _a;
            return ((_a = this._checkBringToFront) !== null && _a !== void 0 ? _a : (this._checkBringToFront = this.newCheckBringToFront()));
        }
        newCheckBringToFront() {
            return new wcardinalUi.DButtonCheck({
                weight: 1,
                text: {
                    value: this.theme.getCheckBringToFromLabel(),
                    align: {
                        horizontal: "LEFT"
                    }
                }
            });
        }
        get checkIsGrouped() {
            var _a;
            return ((_a = this._checkIsGrouped) !== null && _a !== void 0 ? _a : (this._checkIsGrouped = this.newCheckIsGrouped()));
        }
        newCheckIsGrouped() {
            return new wcardinalUi.DButtonCheck({
                weight: 1,
                text: {
                    value: this.theme.getCheckIsGroupedLabel(),
                    align: {
                        horizontal: "LEFT"
                    }
                }
            });
        }
        get checkIsActive() {
            var _a;
            return ((_a = this._checkIsActive) !== null && _a !== void 0 ? _a : (this._checkIsActive = this.newCheckIsActive()));
        }
        newCheckIsActive() {
            return new wcardinalUi.DButtonCheck({
                weight: 1,
                text: {
                    value: this.theme.getCheckIsActiveLabel(),
                    align: {
                        horizontal: "LEFT"
                    }
                }
            });
        }
        reset() {
            this.inputLabel.input.value = this.theme.newInputLabel();
            this.inputWidth.input.value = 1;
            this.selectLayer.values = [];
            this.selectLayer.menu = new wcardinalUi.DMenu({
                fit: true,
                items: this.newSelectLayerMenuItemOptions()
            });
            this.checkBringToFront.state.isActive = false;
            this.checkIsGrouped.state.isActive = true;
            return this;
        }
        get value() {
            return new EShapeButtonLayerButtonValue(this.inputLabel.input.value, this.inputWidth.input.value, this.selectLayer.values.slice(0), this.checkBringToFront.state.isActive, this.checkIsGrouped.state.isActive, this.checkIsActive.state.isActive);
        }
        set value(value) {
            this.selectLayer.menu = new wcardinalUi.DMenu({
                fit: true,
                items: this.newSelectLayerMenuItemOptions()
            });
            if (value != null) {
                this.inputLabel.input.value = value.label;
                this.inputWidth.input.value = value.weight;
                this.selectLayer.values = value.layers;
                this.checkBringToFront.state.isActive = value.bringToFront;
                this.checkIsGrouped.state.isActive = value.isGrouped;
                this.checkIsActive.state.isActive = value.isActive;
            }
        }
        getResolvedValue() {
            return this.value;
        }
        getType() {
            return "EDialogShapeButtonLayerValue";
        }
    }

    class EEditorShapeButtonLayer extends wcardinalUi.DPane {
        constructor(options) {
            super(options);
            this._icons = options.icons;
            const selection = options.selection;
            this._selection = selection;
            this._diagram = options.diagram;
            // Layout
            this.initLayout();
        }
        initLayout() {
            // Content height
            this.content.setHeight("padding");
            // Layout
            new wcardinalUi.DLayoutVertical({
                parent: this.content,
                x: "padding",
                y: "padding",
                width: "padding",
                height: "padding",
                children: [
                    new wcardinalUi.DLayoutHorizontal({
                        width: "100%",
                        height: "auto",
                        children: [
                            this.newTextLabel(),
                            this.buttonNew,
                            this.buttonDelete,
                            this.buttonBringForward,
                            this.buttonSendBackward
                        ]
                    }),
                    this.columnList,
                    this.inputMargin
                ]
            });
            // Selection
            const selection = this._selection;
            this.state.isDisabled = selection.isEmpty();
            selection.on("change", () => {
                this.state.isDisabled = selection.isEmpty();
                this.onSelectionChange(selection);
            });
            const columnList = this.columnList;
            columnList.data.selection.on("change", () => {
                this.onListSelectionChange(columnList);
            });
            this.onSelectionChange(selection);
        }
        newTextLabel() {
            return new wcardinalUi.DText({
                weight: 1,
                text: {
                    value: this.subtheme.getLabel()
                }
            });
        }
        get buttonNew() {
            var _a;
            return ((_a = this._buttonNew) !== null && _a !== void 0 ? _a : (this._buttonNew = this.newButtonNew()));
        }
        newButtonNew() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.new
                },
                title: this.subtheme.getButtonNewTitle(),
                on: {
                    active: (emitter) => {
                        this.onButtonNewActive(emitter);
                    }
                }
            });
        }
        onButtonNewActive(opener) {
            this.dialogButton
                .reset()
                .open(opener)
                .then((value) => {
                if (value != null) {
                    wcardinalUi.DControllers.getCommandController().push(new ECommandShapeButtonLayerValueAdd(value, this._selection));
                }
            });
        }
        onSelectionChangeButtonNew(selection) {
            const buttonNew = this.buttonNew;
            if (selection.last() instanceof EShapeButtonLayer) {
                buttonNew.state.isDisabled = false;
            }
            else {
                buttonNew.state.isDisabled = true;
            }
        }
        get buttonDelete() {
            var _a;
            return ((_a = this._buttonDelete) !== null && _a !== void 0 ? _a : (this._buttonDelete = this.newButtonDelete()));
        }
        newButtonDelete() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.delete
                },
                title: this.subtheme.getButtonDeleteTitle(),
                on: {
                    active: () => {
                        const columnList = this.columnList;
                        const first = columnList.data.selection.first;
                        if (first != null && 1 < columnList.data.size()) {
                            wcardinalUi.DControllers.getCommandController().push(new ECommandShapeButtonLayerValueRemove(first, this._selection));
                        }
                    }
                }
            });
        }
        onListSelectionChangeButtonDelete(columnList) {
            this.buttonDelete.state.isDisabled =
                columnList.data.size() <= 1 || columnList.data.selection.isEmpty();
        }
        get buttonBringForward() {
            var _a;
            return ((_a = this._buttonBringForward) !== null && _a !== void 0 ? _a : (this._buttonBringForward = this.newButtonBringForward()));
        }
        newButtonBringForward() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.arrow_up
                },
                title: this.subtheme.getButtonBringForwardTitle(),
                on: {
                    active: () => {
                        const columnList = this.columnList;
                        const first = columnList.selection.first;
                        if (first != null && columnList.data.items[0] !== first) {
                            wcardinalUi.DControllers.getCommandController().push(new ECommandShapeButtonLayerValueBringForward(first, this._selection));
                        }
                    }
                }
            });
        }
        onListSelectionChangeButtonBringForward(columnList) {
            const first = columnList.data.selection.first;
            const items = columnList.data.items;
            this.buttonBringForward.state.isDisabled = first == null || items[0] === first;
        }
        get buttonSendBackward() {
            var _a;
            return ((_a = this._buttonSendBackward) !== null && _a !== void 0 ? _a : (this._buttonSendBackward = this.newButtonSendBackward()));
        }
        newButtonSendBackward() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.arrow_down
                },
                title: this.subtheme.getButtonSendBackwardTitle(),
                on: {
                    active: () => {
                        const columnList = this.columnList;
                        const first = columnList.selection.first;
                        const items = columnList.data.items;
                        if (first != null && items[items.length - 1] !== first) {
                            wcardinalUi.DControllers.getCommandController().push(new ECommandShapeButtonLayerValueSendBackward(first, this._selection));
                        }
                    }
                }
            });
        }
        onListSelectionChangeButtonSendBackward(columnList) {
            const first = columnList.selection.first;
            const items = columnList.data.items;
            this.buttonSendBackward.state.isDisabled =
                first == null || items[items.length - 1] === first;
        }
        get dialogButton() {
            var _a;
            return ((_a = this._dialogButton) !== null && _a !== void 0 ? _a : (this._dialogButton = this.newDialogButton()));
        }
        newDialogButton() {
            return new EDialogShapeButtonLayerValue({
                diagram: this._diagram
            });
        }
        get columnList() {
            var _a;
            return ((_a = this._columnList) !== null && _a !== void 0 ? _a : (this._columnList = this.newColumnList()));
        }
        newColumnList() {
            const result = new wcardinalUi.DList({
                width: "100%",
                weight: 1,
                data: {
                    toLabel: (value) => {
                        return value.label;
                    }
                },
                updater: {
                    newItem: (data) => {
                        return new wcardinalUi.DListItem(data, {
                            on: {
                                dblclick: (e, _, item) => {
                                    this.onColumnListDblClick(e, _, item, result);
                                }
                            }
                        });
                    }
                }
            });
            return result;
        }
        onColumnListDblClick(e, _, item, list) {
            const oldValue = item.value;
            if (oldValue != null) {
                const columnDialog = this.dialogButton;
                columnDialog.value = oldValue;
                columnDialog.open(item).then((newValue) => {
                    if (newValue != null) {
                        wcardinalUi.DControllers.getCommandController().push(new ECommandShapeButtonLayerValueReplace(oldValue, newValue, this._selection, list));
                    }
                });
            }
        }
        onSelectionChangeColumnList(selection) {
            const last = selection.last();
            const columnList = this.columnList;
            columnList.data.items = last instanceof EShapeButtonLayer ? last.button.values : [];
            this.onListSelectionChange(columnList);
        }
        get inputMargin() {
            var _a;
            return ((_a = this._inputMargin) !== null && _a !== void 0 ? _a : (this._inputMargin = this.newInputMargin()));
        }
        newInputMargin() {
            return new wcardinalUi.DInputRealAndLabel({
                width: "100%",
                label: {
                    text: {
                        value: this.subtheme.getInputMarginLabel()
                    }
                },
                input: {
                    weight: 1,
                    on: {
                        change: (value) => {
                            wcardinalUi.DControllers.getCommandController().push(new ECommandShapeButtonLayerValueMargin(value, this._selection));
                        }
                    }
                }
            });
        }
        onSelectionChangeInputRowHeight(selection) {
            const last = selection.last();
            const input = this.inputMargin;
            if (last instanceof EShapeButtonLayer) {
                input.input.value = last.button.margin;
                input.state.isDisabled = false;
            }
            else {
                input.state.isDisabled = true;
            }
        }
        onSelectionChange(selection) {
            this.onSelectionChangeButtonNew(selection);
            this.onSelectionChangeColumnList(selection);
        }
        onListSelectionChange(columnList) {
            this.onListSelectionChangeButtonDelete(columnList);
            this.onListSelectionChangeButtonBringForward(columnList);
            this.onListSelectionChangeButtonSendBackward(columnList);
        }
        get subtheme() {
            var _a;
            return ((_a = this._subtheme) !== null && _a !== void 0 ? _a : (this._subtheme = this.newSubtheme()));
        }
        newSubtheme() {
            return wcardinalUi.DThemes.get("EEditorShapeButtonLayer");
        }
    }

    class EShapeButtonLayers {
        static getTheme() {
            return wcardinalUi.DThemes.get("EShapeButtonLayer");
        }
        static create(existing) {
            const result = new EShapeButtonLayer(wcardinalUi.EShapeResourceManagerDeserializationMode.EDITOR);
            if (existing) {
                result.copy(existing);
                if (!(existing instanceof EShapeButtonLayer)) {
                    const label = this.getTheme().getLabel();
                    result.button.add(new EShapeButtonLayerButtonValue(label, 1, [], false, true, false));
                }
            }
            else {
                const label = this.getTheme().getLabel();
                result.button.add(new EShapeButtonLayerButtonValue(label, 1, [], false, true, false));
            }
            result.onSizeChange();
            return result;
        }
        static load() {
            const theme = this.getTheme();
            const name = theme.getName();
            EShapeExtensions.add({
                type: EShapeButtonLayerIds.ID,
                name: name,
                icon: {
                    width: 24,
                    height: 24,
                    // Material Icons https://material.io/tools/icons/
                    // Available under Apache license version 2.0
                    svg: `<g transform="scale(26.6666)" fill="#fff" stroke="none">` +
                        `<path d="M22,9v6c0,1.1-0.9,2-2,2h-1l0-2h1V9H4v6h6v2H4c-1.1,0-2` +
                        `-0.9-2-2V9c0-1.1,0.9-2,2-2h16C21.1,7,22,7.9,22,9z"/>` +
                        `<path d="M11.99 18.54l-7.37-5.73L3 14.07l9 7 9-7-1.63-1.27zM12 16l7` +
                        `.36-5.73L21 9l-9-7-9 7 1.63 1.27L12 16zm0-11.47L17.74 9 12 13.47 6.` +
                        `26 9 12 4.53z" transform="translate(7.25,8) scale(0.6)"/>` +
                        `</g>`
                },
                title: name,
                creator: (existing) => EShapeButtonLayers.create(existing),
                deserializer: (item, manager) => EShapeButtonLayers.deserialize(item, manager),
                editor: EEditorShapeButtonLayer,
                uploaded: wcardinalUi.createGroupUploaded,
                capability: (wcardinalUi.EShapeCapability.PRIMITIVE |
                    wcardinalUi.EShapeCapability.STROKE_SIDE |
                    wcardinalUi.EShapeCapability.BORDER_RADIUS) &
                    ~wcardinalUi.EShapeCapability.CHILDREN
            });
        }
        static deserialize(item, manager) {
            const shape = new EShapeButtonLayer(manager.mode);
            const index = item[15];
            const resources = manager.resources;
            if (0 <= index && index < resources.length) {
                let parsed = manager.getExtension(index);
                if (parsed == null) {
                    parsed = JSON.parse(resources[index]);
                    manager.setExtension(index, parsed);
                }
                shape.button.deserialize(parsed[0], manager);
                item[15] = parsed[parsed.length - 1];
            }
            const result = wcardinalUi.deserializeBase(item, manager, shape);
            shape.size.init();
            return result;
        }
    }

    const loadShapeExtensionButtonLayer = () => {
        EShapeButtonLayers.load();
    };

    class EShapeChartTick {
        constructor(major, minor) {
            this.major = major;
            this.minor = minor;
        }
        copy(source) {
            this.major.copy(source.major);
            this.minor.copy(source.minor);
            return this;
        }
        serialize(manager) {
            return manager.addResource(`[${this.major.serialize(manager)},${this.minor.serialize(manager)}]`);
        }
        deserialize(target, manager) {
            const resources = manager.resources;
            if (0 <= target && target < resources.length) {
                let parsed = manager.getExtension(target);
                if (parsed == null) {
                    parsed = JSON.parse(resources[target]);
                    manager.setExtension(target, parsed);
                }
                this.major.deserialize(parsed[0], manager);
                this.minor.deserialize(parsed[1], manager);
            }
        }
    }

    class EShapeChartTickMajor {
        constructor(count) {
            this.count = count;
        }
        copy(source) {
            this.count = source.count;
            return this;
        }
        serialize(manager) {
            return manager.addResource(`${this.count}`);
        }
        deserialize(target, manager) {
            const resources = manager.resources;
            if (0 <= target && target < resources.length) {
                let parsed = manager.getExtension(target);
                if (parsed == null) {
                    parsed = JSON.parse(resources[target]);
                    manager.setExtension(target, parsed);
                }
                this.count = parsed;
            }
        }
    }

    class EShapeChartTickMinor {
        constructor(count) {
            this.count = count;
        }
        copy(source) {
            this.count = source.count;
            return this;
        }
        serialize(manager) {
            return manager.addResource(`${this.count}`);
        }
        deserialize(target, manager) {
            const resources = manager.resources;
            if (0 <= target && target < resources.length) {
                let parsed = manager.getExtension(target);
                if (parsed == null) {
                    parsed = JSON.parse(resources[target]);
                    manager.setExtension(target, parsed);
                }
                this.count = parsed;
            }
        }
    }

    class EShapeChartAxisX {
        constructor() {
            this.padding = 10;
            this.tick = new EShapeChartTick(new EShapeChartTickMajor(3), new EShapeChartTickMinor(3));
        }
        copy(source) {
            this.padding = source.padding;
            this.tick.copy(source.tick);
            return this;
        }
        serialize(manager) {
            return manager.addResource(`[${this.padding},${this.tick.serialize(manager)}]`);
        }
        deserialize(target, manager) {
            const resources = manager.resources;
            if (0 <= target && target < resources.length) {
                let parsed = manager.getExtension(target);
                if (parsed == null) {
                    parsed = JSON.parse(resources[target]);
                    manager.setExtension(target, parsed);
                }
                this.padding = parsed[0];
                this.tick.deserialize(parsed[1], manager);
            }
        }
    }

    class EShapeChartAxisY extends EShapeChartAxisX {
    }

    class EShapeChartAxis {
        constructor() {
            this.x = new EShapeChartAxisX();
            this.y = new EShapeChartAxisY();
        }
        copy(source) {
            this.x.copy(source.x);
            this.y.copy(source.y);
            return this;
        }
        serialize(manager) {
            return manager.addResource(`[${this.x.serialize(manager)},${this.y.serialize(manager)}]`);
        }
        deserialize(target, manager) {
            const resources = manager.resources;
            if (0 <= target && target < resources.length) {
                let parsed = manager.getExtension(target);
                if (parsed == null) {
                    parsed = JSON.parse(resources[target]);
                    manager.setExtension(target, parsed);
                }
                this.x.deserialize(parsed[0], manager);
                this.y.deserialize(parsed[1], manager);
            }
        }
    }

    class EShapeChartLineIds {
    }
    EShapeChartLineIds.ID = wcardinalUi.EShapeType.EXTENSION + 0;
    EShapeChartLineIds.PLOT_AREA_ID = "plot-area";
    EShapeChartLineIds.LINE_ID = "line";
    EShapeChartLineIds.X_AXIS_ID = "x-axis";
    EShapeChartLineIds.X_AXIS_TICK_MAJOR_ID = "x-axis-tick-major";
    EShapeChartLineIds.X_AXIS_TICK_MINOR_ID = "x-axis-tick-minor";
    EShapeChartLineIds.Y_AXIS_ID = "y-axis";
    EShapeChartLineIds.Y_AXIS_TICK_MAJOR_ID = "y-axis-tick-major";
    EShapeChartLineIds.Y_AXIS_TICK_MINOR_ID = "y-axis-tick-minor";

    class EShapeChartLine extends wcardinalUi.EShapeGroup {
        constructor(mode, type = EShapeChartLineIds.ID) {
            super(mode, type);
            this.axis = new EShapeChartAxis();
        }
        copy(source, part = wcardinalUi.EShapeCopyPart.ALL) {
            const result = super.copy(source, part);
            if (source instanceof EShapeChartLine) {
                this.axis.copy(source.axis);
            }
            return result;
        }
        serialize(manager) {
            const result = super.serialize(manager);
            const resource = result[15];
            result[15] = manager.addResource(`[${this.axis.serialize(manager)},${resource}]`);
            return result;
        }
    }

    class ECommandChartAxisXPadding extends ECommandShapePropertySimple {
        getProperty(shape, capability) {
            if (shape instanceof EShapeChartLine) {
                return shape.axis.x.padding;
            }
            return 0;
        }
        setProperty(shape, capability, property) {
            if (shape instanceof EShapeChartLine) {
                shape.axis.x.padding = property;
            }
        }
        isMergeable() {
            return true;
        }
    }

    class ECommandChartAxisYPadding extends ECommandShapePropertySimple {
        getProperty(shape, capability) {
            if (shape instanceof EShapeChartLine) {
                return shape.axis.y.padding;
            }
            return 0;
        }
        setProperty(shape, capability, property) {
            if (shape instanceof EShapeChartLine) {
                shape.axis.y.padding = property;
            }
        }
        isMergeable() {
            return true;
        }
    }

    class ECommandChartTickXMajorCount extends ECommandShapePropertySimple {
        getProperty(shape, capability) {
            if (shape instanceof EShapeChartLine) {
                return shape.axis.x.tick.major.count;
            }
            return 0;
        }
        setProperty(shape, capability, property) {
            if (shape instanceof EShapeChartLine) {
                shape.axis.x.tick.major.count = property;
            }
        }
        isMergeable() {
            return true;
        }
    }

    class ECommandChartTickXMinorCount extends ECommandShapePropertySimple {
        getProperty(shape, capability) {
            if (shape instanceof EShapeChartLine) {
                return shape.axis.x.tick.minor.count;
            }
            return 0;
        }
        setProperty(shape, capability, property) {
            if (shape instanceof EShapeChartLine) {
                shape.axis.x.tick.minor.count = property;
            }
        }
        isMergeable() {
            return true;
        }
    }

    class ECommandChartTickYMajorCount extends ECommandShapePropertySimple {
        getProperty(shape, capability) {
            if (shape instanceof EShapeChartLine) {
                return shape.axis.y.tick.major.count;
            }
            return 0;
        }
        setProperty(shape, capability, property) {
            if (shape instanceof EShapeChartLine) {
                shape.axis.y.tick.major.count = property;
            }
        }
        isMergeable() {
            return true;
        }
    }

    class ECommandChartTickYMinorCount extends ECommandShapePropertySimple {
        getProperty(shape, capability) {
            if (shape instanceof EShapeChartLine) {
                return shape.axis.y.tick.minor.count;
            }
            return 0;
        }
        setProperty(shape, capability, property) {
            if (shape instanceof EShapeChartLine) {
                shape.axis.y.tick.minor.count = property;
            }
        }
        isMergeable() {
            return true;
        }
    }

    class EShapeChartAxes {
        static getTheme() {
            return wcardinalUi.DThemes.get("EShapeChartLine");
        }
        static getPlotArea(shape) {
            return UtilShapeSearch.findChildById(shape, EShapeChartLineIds.PLOT_AREA_ID);
        }
        static newPlotArea(shape) {
            const result = new wcardinalUi.EShapeRectangle();
            result.id = EShapeChartLineIds.PLOT_AREA_ID;
            result.size.set(shape.size.x, shape.size.y);
            result.stroke.enable = false;
            result.fill.alpha = wcardinalUi.EShapeDefaults.FILL_ALPHA * 0.5;
            result.text.value = this.getTheme().newPlotAreaLabel();
            result.text.align.vertical = wcardinalUi.EShapeTextAlignVertical.OUTSIDE_TOP;
            result.attach(shape);
            return result;
        }
        static getLine(shape) {
            return UtilShapeSearch.findChildById(shape, EShapeChartLineIds.LINE_ID);
        }
        static newLine(shape) {
            const sx = 0.8 * shape.size.x;
            const sy = 0.8 * shape.size.y;
            const sxh = sx * 0.5;
            const syh = sy * 0.5;
            const result = wcardinalUi.createLine([-sxh, +syh, +sxh, -syh], [], wcardinalUi.EShapeDefaults.STROKE_WIDTH, wcardinalUi.EShapePointsStyle.NONE);
            result.id = EShapeChartLineIds.LINE_ID;
            result.attach(shape);
            return result;
        }
        static getXAxis(shape) {
            return UtilShapeSearch.findChildById(shape, EShapeChartLineIds.X_AXIS_ID);
        }
        static getXAxisTickMajor(shape) {
            return UtilShapeSearch.findChildById(shape, EShapeChartLineIds.X_AXIS_TICK_MAJOR_ID);
        }
        static getXAxisTickMinor(shape) {
            return UtilShapeSearch.findChildById(shape, EShapeChartLineIds.X_AXIS_TICK_MINOR_ID);
        }
        static newXAxis(shape) {
            const result = new wcardinalUi.EShapeBar();
            result.id = EShapeChartLineIds.X_AXIS_ID;
            result.size.set(shape.size.x, 0);
            result.transform.position.set(0, shape.size.y * 0.5);
            result.points.position = wcardinalUi.EShapeBarPosition.LEFT;
            result.points.size = -1;
            result.stroke.width = wcardinalUi.EShapeDefaults.STROKE_WIDTH;
            result.text.value = this.getTheme().newXAxisLabel();
            result.text.align.vertical = wcardinalUi.EShapeTextAlignVertical.OUTSIDE_BOTTOM;
            result.text.padding.set(50, 50);
            result.attach(shape);
            return result;
        }
        static createXAxis(selection) {
            selection.createChildren((shape) => {
                return [EShapeChartAxes.newXAxis(shape)];
            });
        }
        static deleteXAxis(selection) {
            selection.deleteChildren((shape) => {
                let result = null;
                const axis = EShapeChartAxes.getXAxis(shape);
                if (axis != null) {
                    result = [axis];
                }
                const major = EShapeChartAxes.getXAxisTickMajor(shape);
                if (major != null) {
                    if (result == null) {
                        result = [major];
                    }
                    else {
                        result.push(major);
                    }
                }
                const minor = EShapeChartAxes.getXAxisTickMinor(shape);
                if (minor != null) {
                    if (result == null) {
                        result = [minor];
                    }
                    else {
                        result.push(minor);
                    }
                }
                return result;
            });
        }
        static setXAxisPadding(padding, selection) {
            wcardinalUi.DControllers.getCommandController().push(new ECommandChartAxisXPadding(selection, padding));
        }
        static newXAxisTickMajor(shape) {
            const result = new wcardinalUi.EShapeBar();
            result.id = EShapeChartLineIds.X_AXIS_TICK_MAJOR_ID;
            result.size.set(0, 0);
            result.transform.position.set(0, shape.size.y * 0.5);
            result.points.position = wcardinalUi.EShapeBarPosition.TOP;
            result.points.size = 10;
            result.stroke.width = wcardinalUi.EShapeDefaults.STROKE_WIDTH;
            result.text.value = "%YMD\n%Hms.%mi";
            result.text.align.vertical = wcardinalUi.EShapeTextAlignVertical.TOP;
            result.text.padding.set(12.5, 12.5);
            result.attach(shape);
            return result;
        }
        static newXAxisTickMinor(shape, x, y) {
            const result = new wcardinalUi.EShapeBar();
            result.id = EShapeChartLineIds.X_AXIS_TICK_MINOR_ID;
            result.size.set(0, 0);
            result.transform.position.set(x, y);
            result.points.position = wcardinalUi.EShapeBarPosition.TOP;
            result.points.size = 5;
            result.stroke.width = wcardinalUi.EShapeDefaults.STROKE_WIDTH * 0.5;
            result.attach(shape);
            return result;
        }
        static createXAxisTickMajor(selection) {
            selection.createChildren((shape) => {
                const axis = EShapeChartAxes.getXAxis(shape);
                if (axis != null) {
                    return [this.newXAxisTickMajor(shape)];
                }
                return null;
            });
        }
        static deleteXAxisTickMajor(selection) {
            selection.deleteChildren((shape) => {
                let result = null;
                const major = EShapeChartAxes.getXAxisTickMajor(shape);
                if (major != null) {
                    result = [major];
                }
                const minor = EShapeChartAxes.getXAxisTickMinor(shape);
                if (minor != null) {
                    if (result == null) {
                        result = [minor];
                    }
                    else {
                        result.push(minor);
                    }
                }
                return result;
            });
        }
        static setXAxisTickMajorCount(count, selection) {
            wcardinalUi.DControllers.getCommandController().push(new ECommandChartTickXMajorCount(selection, count));
        }
        static createXAxisTickMinor(selection) {
            selection.createChildren((shape) => {
                const axis = EShapeChartAxes.getXAxis(shape);
                if (axis != null) {
                    const sizeX = axis.size.x;
                    const position = axis.transform.position;
                    return [this.newXAxisTickMinor(shape, position.x - sizeX * 0.25, position.y)];
                }
                return null;
            });
        }
        static deleteXAxisTickMinor(selection) {
            selection.deleteChildren((shape) => {
                const minor = EShapeChartAxes.getXAxisTickMinor(shape);
                if (minor != null) {
                    return [minor];
                }
                return null;
            });
        }
        static setXAxisTickMinorCount(count, selection) {
            wcardinalUi.DControllers.getCommandController().push(new ECommandChartTickXMinorCount(selection, count));
        }
        static getYAxis(shape) {
            return UtilShapeSearch.findChildById(shape, EShapeChartLineIds.Y_AXIS_ID);
        }
        static getYAxisTickMajor(shape) {
            return UtilShapeSearch.findChildById(shape, EShapeChartLineIds.Y_AXIS_TICK_MAJOR_ID);
        }
        static getYAxisTickMinor(shape) {
            return UtilShapeSearch.findChildById(shape, EShapeChartLineIds.Y_AXIS_TICK_MINOR_ID);
        }
        static newYAxis(shape) {
            const result = new wcardinalUi.EShapeBar();
            result.id = EShapeChartLineIds.Y_AXIS_ID;
            result.size.set(0, shape.size.y);
            result.transform.position.set(-shape.size.x * 0.5, 0);
            result.points.position = wcardinalUi.EShapeBarPosition.TOP;
            result.points.size = -1;
            result.stroke.width = wcardinalUi.EShapeDefaults.STROKE_WIDTH;
            result.text.value = this.getTheme().newYAxisLabel();
            result.text.align.horizontal = wcardinalUi.EShapeTextAlignHorizontal.OUTSIDE_LEFT;
            result.text.direction = wcardinalUi.EShapeTextDirection.BOTTOM_TO_TOP;
            result.text.padding.set(50, 50);
            result.attach(shape);
            return result;
        }
        static createYAxis(selection) {
            selection.createChildren((shape) => {
                return [EShapeChartAxes.newYAxis(shape)];
            });
        }
        static deleteYAxis(selection) {
            selection.deleteChildren((shape) => {
                let result = null;
                const axis = EShapeChartAxes.getYAxis(shape);
                if (axis != null) {
                    result = [axis];
                }
                const major = EShapeChartAxes.getYAxisTickMajor(shape);
                if (major != null) {
                    if (result == null) {
                        result = [major];
                    }
                    else {
                        result.push(major);
                    }
                }
                const minor = EShapeChartAxes.getYAxisTickMinor(shape);
                if (minor != null) {
                    if (result == null) {
                        result = [minor];
                    }
                    else {
                        result.push(minor);
                    }
                }
                return result;
            });
        }
        static setYAxisPadding(padding, selection) {
            wcardinalUi.DControllers.getCommandController().push(new ECommandChartAxisYPadding(selection, padding));
        }
        static newYAxisTickMajor(shape) {
            const result = new wcardinalUi.EShapeBar();
            result.id = EShapeChartLineIds.Y_AXIS_TICK_MAJOR_ID;
            result.size.set(0, 0);
            result.transform.position.set(-shape.size.x * 0.5, 0);
            result.points.position = wcardinalUi.EShapeBarPosition.RIGHT;
            result.points.size = 10;
            result.stroke.width = wcardinalUi.EShapeDefaults.STROKE_WIDTH;
            result.text.value = "%ssi";
            result.text.align.horizontal = wcardinalUi.EShapeTextAlignHorizontal.RIGHT;
            result.text.padding.set(12.5, 12.5);
            result.attach(shape);
            return result;
        }
        static newYAxisTickMinor(shape, x, y) {
            const result = new wcardinalUi.EShapeBar();
            result.id = EShapeChartLineIds.Y_AXIS_TICK_MINOR_ID;
            result.size.set(0, 0);
            result.transform.position.set(x, y);
            result.points.position = wcardinalUi.EShapeBarPosition.RIGHT;
            result.points.size = 5;
            result.stroke.width = wcardinalUi.EShapeDefaults.STROKE_WIDTH * 0.5;
            result.attach(shape);
            return result;
        }
        static createYAxisTickMajor(selection) {
            selection.createChildren((shape) => {
                const axis = EShapeChartAxes.getYAxis(shape);
                if (axis != null) {
                    return [this.newYAxisTickMajor(shape)];
                }
                return null;
            });
        }
        static deleteYAxisTickMajor(selection) {
            selection.deleteChildren((shape) => {
                let result = null;
                const major = EShapeChartAxes.getYAxisTickMajor(shape);
                if (major != null) {
                    result = [major];
                }
                const minor = EShapeChartAxes.getYAxisTickMinor(shape);
                if (minor != null) {
                    if (result == null) {
                        result = [minor];
                    }
                    else {
                        result.push(minor);
                    }
                }
                return result;
            });
        }
        static setYAxisTickMajorCount(count, selection) {
            wcardinalUi.DControllers.getCommandController().push(new ECommandChartTickYMajorCount(selection, count));
        }
        static createYAxisTickMinor(selection) {
            selection.createChildren((shape) => {
                const axis = EShapeChartAxes.getYAxis(shape);
                if (axis != null) {
                    const sizeY = axis.size.y;
                    const position = axis.transform.position;
                    return [this.newYAxisTickMinor(shape, position.x, position.y + sizeY * 0.25)];
                }
                return null;
            });
        }
        static deleteYAxisTickMinor(selection) {
            selection.deleteChildren((shape) => {
                const minor = EShapeChartAxes.getYAxisTickMinor(shape);
                if (minor != null) {
                    return [minor];
                }
                return null;
            });
        }
        static setYAxisTickMinorCount(count, selection) {
            wcardinalUi.DControllers.getCommandController().push(new ECommandChartTickYMinorCount(selection, count));
        }
    }

    class EEditorShapeChartLine extends wcardinalUi.DPane {
        constructor(options) {
            super(options);
            const selection = options.selection;
            this.state.isDisabled = selection.isEmpty();
            selection.on("change", () => {
                this.state.isDisabled = selection.isEmpty();
            });
            const subtheme = this.subtheme;
            new wcardinalUi.DLayoutVertical({
                parent: this.content,
                x: "padding",
                y: "padding",
                width: "padding",
                height: "auto",
                children: [
                    this.newTextLabel(),
                    new wcardinalUi.DButtonCheckRight({
                        width: "100%",
                        text: {
                            value: subtheme.getCheckXAxisLabel()
                        },
                        padding: 0,
                        background: {
                            color: null
                        },
                        on: {
                            init: (self) => {
                                const update = () => {
                                    const last = selection.last();
                                    if (last instanceof EShapeChartLine) {
                                        self.state.isActive = EShapeChartAxes.getXAxis(last) != null;
                                        self.state.isDisabled = false;
                                    }
                                    else {
                                        self.state.isDisabled = true;
                                    }
                                };
                                update();
                                selection.on("change", update);
                            },
                            active: () => {
                                EShapeChartAxes.createXAxis(selection);
                            },
                            inactive: () => {
                                EShapeChartAxes.deleteXAxis(selection);
                            }
                        }
                    }),
                    new wcardinalUi.DButtonCheckRight({
                        width: "100%",
                        text: {
                            value: subtheme.getCheckXAxisMajorTickLabel()
                        },
                        padding: {
                            top: 0,
                            right: 0,
                            left: 10,
                            bottom: 0
                        },
                        background: {
                            color: null
                        },
                        on: {
                            init: (self) => {
                                const update = () => {
                                    const last = selection.last();
                                    if (last instanceof EShapeChartLine) {
                                        if (EShapeChartAxes.getXAxis(last) != null) {
                                            self.state.isActive =
                                                EShapeChartAxes.getXAxisTickMajor(last) != null;
                                            self.state.isDisabled = false;
                                        }
                                        else {
                                            self.state.isDisabled = true;
                                        }
                                    }
                                    else {
                                        self.state.isDisabled = true;
                                    }
                                };
                                update();
                                selection.on("change", update);
                            },
                            active: () => {
                                EShapeChartAxes.createXAxisTickMajor(selection);
                            },
                            inactive: () => {
                                EShapeChartAxes.deleteXAxisTickMajor(selection);
                            }
                        }
                    }),
                    new wcardinalUi.DButtonCheckRight({
                        width: "100%",
                        text: {
                            value: subtheme.getCheckXAxisMinorTickLabel()
                        },
                        padding: {
                            top: 0,
                            right: 0,
                            left: 10,
                            bottom: 0
                        },
                        background: {
                            color: null
                        },
                        on: {
                            init: (self) => {
                                const update = () => {
                                    const last = selection.last();
                                    if (last instanceof EShapeChartLine) {
                                        if (EShapeChartAxes.getXAxis(last) != null) {
                                            self.state.isActive =
                                                EShapeChartAxes.getXAxisTickMinor(last) != null;
                                            self.state.isDisabled = false;
                                        }
                                        else {
                                            self.state.isDisabled = true;
                                        }
                                    }
                                    else {
                                        self.state.isDisabled = true;
                                    }
                                };
                                update();
                                selection.on("change", update);
                            },
                            active: () => {
                                EShapeChartAxes.createXAxisTickMinor(selection);
                            },
                            inactive: () => {
                                EShapeChartAxes.deleteXAxisTickMinor(selection);
                            }
                        }
                    }),
                    new wcardinalUi.DButtonCheckRight({
                        width: "100%",
                        text: {
                            value: subtheme.getCheckYAxisLabel()
                        },
                        padding: 0,
                        background: {
                            color: null
                        },
                        on: {
                            init: (self) => {
                                const update = () => {
                                    const last = selection.last();
                                    if (last instanceof EShapeChartLine) {
                                        self.state.isActive = EShapeChartAxes.getYAxis(last) != null;
                                        self.state.isDisabled = false;
                                    }
                                    else {
                                        self.state.isDisabled = true;
                                    }
                                };
                                update();
                                selection.on("change", update);
                            },
                            active: () => {
                                EShapeChartAxes.createYAxis(selection);
                            },
                            inactive: () => {
                                EShapeChartAxes.deleteYAxis(selection);
                            }
                        }
                    }),
                    new wcardinalUi.DButtonCheckRight({
                        width: "100%",
                        text: {
                            value: subtheme.getCheckYAxisMajorTickLabel()
                        },
                        padding: {
                            top: 0,
                            right: 0,
                            left: 10,
                            bottom: 0
                        },
                        background: {
                            color: null
                        },
                        on: {
                            init: (self) => {
                                const update = () => {
                                    const last = selection.last();
                                    if (last instanceof EShapeChartLine) {
                                        if (EShapeChartAxes.getYAxis(last) != null) {
                                            self.state.isActive =
                                                EShapeChartAxes.getYAxisTickMajor(last) != null;
                                            self.state.isDisabled = false;
                                        }
                                        else {
                                            self.state.isDisabled = true;
                                        }
                                    }
                                    else {
                                        self.state.isDisabled = true;
                                    }
                                };
                                update();
                                selection.on("change", update);
                            },
                            active: () => {
                                EShapeChartAxes.createYAxisTickMajor(selection);
                            },
                            inactive: () => {
                                EShapeChartAxes.deleteYAxisTickMajor(selection);
                            }
                        }
                    }),
                    new wcardinalUi.DButtonCheckRight({
                        width: "100%",
                        text: {
                            value: subtheme.getCheckYAxisMinorTickLabel()
                        },
                        padding: {
                            top: 0,
                            right: 0,
                            left: 10,
                            bottom: 0
                        },
                        background: {
                            color: null
                        },
                        on: {
                            init: (self) => {
                                const update = () => {
                                    const last = selection.last();
                                    if (last instanceof EShapeChartLine) {
                                        if (EShapeChartAxes.getYAxis(last) != null) {
                                            self.state.isActive =
                                                EShapeChartAxes.getYAxisTickMinor(last) != null;
                                            self.state.isDisabled = false;
                                        }
                                        else {
                                            self.state.isDisabled = true;
                                        }
                                    }
                                    else {
                                        self.state.isDisabled = true;
                                    }
                                };
                                update();
                                selection.on("change", update);
                            },
                            active: () => {
                                EShapeChartAxes.createYAxisTickMinor(selection);
                            },
                            inactive: () => {
                                EShapeChartAxes.deleteYAxisTickMinor(selection);
                            }
                        }
                    }),
                    new wcardinalUi.DText({
                        width: "100%",
                        text: {
                            value: subtheme.getTextMajorTickCountLabel()
                        }
                    }),
                    new wcardinalUi.DLayoutHorizontal({
                        width: "100%",
                        children: [
                            new wcardinalUi.DInputInteger({
                                weight: 1,
                                min: 0,
                                on: {
                                    init: (self) => {
                                        const update = () => {
                                            const last = selection.last();
                                            if (last instanceof EShapeChartLine) {
                                                self.value = last.axis.x.tick.major.count;
                                            }
                                        };
                                        update();
                                        selection.on("change", update);
                                    },
                                    change: (count) => {
                                        EShapeChartAxes.setXAxisTickMajorCount(count, selection);
                                    }
                                }
                            }),
                            new wcardinalUi.DInputInteger({
                                weight: 1,
                                min: 0,
                                on: {
                                    init: (self) => {
                                        const update = () => {
                                            const last = selection.last();
                                            if (last instanceof EShapeChartLine) {
                                                self.value = last.axis.y.tick.major.count;
                                            }
                                        };
                                        update();
                                        selection.on("change", update);
                                    },
                                    change: (count) => {
                                        EShapeChartAxes.setYAxisTickMajorCount(count, selection);
                                    }
                                }
                            })
                        ]
                    }),
                    new wcardinalUi.DText({
                        width: "100%",
                        text: {
                            value: subtheme.getTextMinorTickCountLabel()
                        }
                    }),
                    new wcardinalUi.DLayoutHorizontal({
                        width: "100%",
                        children: [
                            new wcardinalUi.DInputInteger({
                                weight: 1,
                                min: 0,
                                on: {
                                    init: (self) => {
                                        const update = () => {
                                            const last = selection.last();
                                            if (last instanceof EShapeChartLine) {
                                                self.value = last.axis.x.tick.minor.count;
                                            }
                                        };
                                        update();
                                        selection.on("change", update);
                                    },
                                    change: (count) => {
                                        EShapeChartAxes.setXAxisTickMinorCount(count, selection);
                                    }
                                }
                            }),
                            new wcardinalUi.DInputInteger({
                                weight: 1,
                                min: 0,
                                on: {
                                    init: (self) => {
                                        const update = () => {
                                            const last = selection.last();
                                            if (last instanceof EShapeChartLine) {
                                                self.value = last.axis.y.tick.minor.count;
                                            }
                                        };
                                        update();
                                        selection.on("change", update);
                                    },
                                    change: (count) => {
                                        EShapeChartAxes.setYAxisTickMinorCount(count, selection);
                                    }
                                }
                            })
                        ]
                    }),
                    new wcardinalUi.DText({
                        width: "100%",
                        text: {
                            value: subtheme.getTextPaddingLabel()
                        }
                    }),
                    new wcardinalUi.DLayoutHorizontal({
                        width: "100%",
                        children: [
                            new wcardinalUi.DInputInteger({
                                weight: 1,
                                min: 0,
                                on: {
                                    init: (self) => {
                                        const update = () => {
                                            const last = selection.last();
                                            if (last instanceof EShapeChartLine) {
                                                self.value = last.axis.x.padding;
                                            }
                                        };
                                        update();
                                        selection.on("change", update);
                                    },
                                    change: (padding) => {
                                        EShapeChartAxes.setXAxisPadding(padding, selection);
                                    }
                                }
                            }),
                            new wcardinalUi.DInputInteger({
                                weight: 1,
                                min: 0,
                                on: {
                                    init: (self) => {
                                        const update = () => {
                                            const last = selection.last();
                                            if (last instanceof EShapeChartLine) {
                                                self.value = last.axis.y.padding;
                                            }
                                        };
                                        update();
                                        selection.on("change", update);
                                    },
                                    change: (padding) => {
                                        EShapeChartAxes.setYAxisPadding(padding, selection);
                                    }
                                }
                            })
                        ]
                    })
                ],
                on: {
                    init: (self) => {
                        const update = () => {
                            self.state.isDisabled = !(selection.last() instanceof EShapeChartLine);
                        };
                        update();
                        selection.on("change", update);
                    }
                }
            });
        }
        newTextLabel() {
            return new wcardinalUi.DText({
                width: "100%",
                text: {
                    value: this.subtheme.getLabel()
                }
            });
        }
        get subtheme() {
            var _a;
            return ((_a = this._subtheme) !== null && _a !== void 0 ? _a : (this._subtheme = this.newSubtheme()));
        }
        newSubtheme() {
            return wcardinalUi.DThemes.get("EEditorShapeChartLine");
        }
    }

    class EShapeChartLineActionRuntime extends wcardinalUi.EShapeActionRuntimeBase {
        constructor(shape) {
            super();
            // Lines
            const line = UtilShapeSearch.findChildById(shape, "line");
            if (line != null) {
                const data = shape.data;
                if (data.size() <= 0) {
                    line.detach();
                    this.lines = [];
                }
                else {
                    const lines = [line];
                    for (let i = 1, imax = data.size(); i < imax; ++i) {
                        const cloned = line.clone();
                        cloned.attach(shape);
                        lines.push(cloned);
                    }
                    this.lines = lines;
                }
            }
            else {
                this.lines = [];
            }
            // Ticks
            let xmajorCount = 3;
            let ymajorCount = 3;
            let xminorCount = 3;
            let yminorCount = 3;
            if (shape instanceof EShapeChartLine) {
                xmajorCount = shape.axis.x.tick.major.count;
                ymajorCount = shape.axis.y.tick.major.count;
                xminorCount = shape.axis.x.tick.minor.count;
                yminorCount = shape.axis.y.tick.minor.count;
            }
            this.xmajorCount = xmajorCount;
            this.ymajorCount = ymajorCount;
            this.xminorCount = xminorCount;
            this.yminorCount = yminorCount;
            this.xmajors = this.initTicks(shape, EShapeChartLineIds.X_AXIS_TICK_MAJOR_ID, xmajorCount);
            this.ymajors = this.initTicks(shape, EShapeChartLineIds.Y_AXIS_TICK_MAJOR_ID, ymajorCount);
            this.xminors = this.initTicks(shape, EShapeChartLineIds.X_AXIS_TICK_MINOR_ID, (xmajorCount + 1) * xminorCount);
            this.yminors = this.initTicks(shape, EShapeChartLineIds.Y_AXIS_TICK_MINOR_ID, (ymajorCount + 1) * yminorCount);
            this.workMajorPositions = new Float64Array(Math.max(xmajorCount, ymajorCount));
            // Tick format
            const xtick = UtilShapeSearch.findChildById(shape, EShapeChartLineIds.X_AXIS_TICK_MAJOR_ID);
            this.xformatter = wcardinalUi.NumberFormatters.create(xtick != null ? xtick.text.value : "");
            const ytick = UtilShapeSearch.findChildById(shape, EShapeChartLineIds.Y_AXIS_TICK_MAJOR_ID);
            this.yformatter = wcardinalUi.NumberFormatters.create(ytick != null ? ytick.text.value : "");
            // Plot area
            this.plotArea = UtilShapeSearch.findChildById(shape, "plot-area");
            // Padding
            let xpadding = 10;
            let ypadding = 10;
            if (shape instanceof EShapeChartLine) {
                xpadding = shape.axis.x.padding;
                ypadding = shape.axis.y.padding;
            }
            this.xpadding = xpadding;
            this.ypadding = ypadding;
        }
        initTicks(shape, id, count) {
            const tick = UtilShapeSearch.findChildById(shape, id);
            if (tick != null) {
                if (count <= 0) {
                    tick.detach();
                    return [];
                }
                else {
                    const ticks = [tick];
                    for (let i = 1; i < count; ++i) {
                        const cloned = tick.clone();
                        cloned.attach(shape);
                        ticks.push(cloned);
                    }
                    return ticks;
                }
            }
            else {
                return [];
            }
        }
        toStepScale(scale) {
            if (5.5 <= scale) {
                return 10;
            }
            else if (2.2 <= scale) {
                return 5;
            }
            else if (1.1 <= scale) {
                return 2;
            }
            return 1;
        }
        getStep(min, max, count) {
            if (count <= 0 || max <= min) {
                return -1;
            }
            // Calculate the step
            const span = (max - min) / count;
            const power = Math.floor(Math.log(span) / Math.LN10);
            const base = Math.pow(10, power);
            return this.toStepScale(span / base) * base;
        }
        getTickPositions(min, max, count, step, padding, ratio, result) {
            if (count <= 0) {
                return result;
            }
            if (max <= min || step <= 0) {
                result[0] = min;
                for (let i = 1; i < count; ++i) {
                    result[i] = NaN;
                }
                return result;
            }
            // Set positions
            const start = min / step;
            let istart = Math.floor(start);
            const dstart = start - istart;
            if (padding < dstart * step * ratio) {
                istart = Math.ceil(start);
            }
            const stop = max / step;
            let istop = Math.ceil(stop);
            const dstop = istop - stop;
            if (padding < dstop * step * ratio) {
                istop = Math.floor(stop);
            }
            const nticks = Math.min(count, Math.ceil(istop - istart + 1));
            for (let i = 0; i < nticks; ++i) {
                result[i] = (istart + i) * step;
            }
            for (let i = nticks; i < count; ++i) {
                result[i] = NaN;
            }
            //
            return result;
        }
        updateTicksXMinor(mstep, index, position, min, ratio, lmin, lmax) {
            const mticks = this.xminors;
            if (0 < mticks.length) {
                const minorCount = this.xminorCount;
                if (0 < mstep) {
                    const padding = this.xpadding;
                    if (index < 0) {
                        for (let i = 0, j = (index + 1) * minorCount; i < minorCount; i += 1, j += 1) {
                            const mtick = mticks[j];
                            const x = (position - (minorCount - i) * mstep - min) * ratio + lmin;
                            if (lmin - padding <= x) {
                                mtick.lock(wcardinalUi.EShapeLockPart.UPLOADED);
                                mtick.visible = true;
                                mtick.transform.position.x = x;
                                mtick.unlock(wcardinalUi.EShapeLockPart.UPLOADED, true);
                            }
                            else {
                                mtick.visible = false;
                            }
                        }
                    }
                    else {
                        for (let i = 0, j = (index + 1) * minorCount; i < minorCount; i += 1, j += 1) {
                            const mtick = mticks[j];
                            const x = (position + (i + 1) * mstep - min) * ratio + lmin;
                            if (x <= lmax + padding) {
                                mtick.lock(wcardinalUi.EShapeLockPart.UPLOADED);
                                mtick.visible = true;
                                mtick.transform.position.x = x;
                                mtick.unlock(wcardinalUi.EShapeLockPart.UPLOADED, true);
                            }
                            else {
                                mtick.visible = false;
                            }
                        }
                    }
                }
                else {
                    for (let i = (index + 1) * minorCount, imax = i + minorCount; i < imax; ++i) {
                        mticks[i].visible = false;
                    }
                }
            }
        }
        toStepMinor(step, minorCount) {
            if (0 <= step) {
                return step / (minorCount + 1);
            }
            else {
                return -1;
            }
        }
        updateTicksX(min, max, ratio, lmin, lmax) {
            const ticks = this.xmajors;
            const mticks = this.xminors;
            const minorCount = this.xminorCount;
            const padding = this.xpadding;
            // Major tick positions
            const step = this.getStep(min, max, ticks.length);
            const positions = this.getTickPositions(min, max, ticks.length, step, padding, ratio, this.workMajorPositions);
            // First minors
            const mstep = this.toStepMinor(step, minorCount);
            this.updateTicksXMinor(mstep, -1, positions[0], min, ratio, lmin, lmax);
            // Major and minor ticks
            for (let i = 0, imax = ticks.length; i < imax; ++i) {
                const tick = ticks[i];
                const position = positions[i];
                if (position === position) {
                    // Major tick
                    tick.lock(wcardinalUi.EShapeLockPart.UPLOADED);
                    tick.visible = true;
                    tick.transform.position.x = (position - min) * ratio + lmin;
                    tick.text.value = this.xformatter.format(position, step);
                    tick.unlock(wcardinalUi.EShapeLockPart.UPLOADED, true);
                    // Minor ticks
                    this.updateTicksXMinor(mstep, i, positions[i], min, ratio, lmin, lmax);
                }
                else {
                    // Major tick
                    tick.visible = false;
                    // Minor ticks
                    if (0 < mticks.length) {
                        for (let j = (i + 1) * minorCount, jmax = j + minorCount; j < jmax; ++j) {
                            mticks[j].visible = false;
                        }
                    }
                }
            }
        }
        updateTicksYMinor(mstep, index, position, min, ratio, lmin, lmax) {
            const mticks = this.yminors;
            if (0 < mticks.length) {
                const minorCount = this.yminorCount;
                if (0 < mstep) {
                    const padding = this.ypadding;
                    if (index < 0) {
                        for (let i = 0, j = (index + 1) * minorCount; i < minorCount; i += 1, j += 1) {
                            const mtick = mticks[j];
                            const y = lmax - (position - (minorCount - i) * mstep - min) * ratio;
                            if (y <= lmax + padding) {
                                mtick.lock(wcardinalUi.EShapeLockPart.UPLOADED);
                                mtick.visible = true;
                                mtick.transform.position.y = y;
                                mtick.unlock(wcardinalUi.EShapeLockPart.UPLOADED, true);
                            }
                            else {
                                mtick.visible = false;
                            }
                        }
                    }
                    else {
                        for (let i = 0, j = (index + 1) * minorCount; i < minorCount; i += 1, j += 1) {
                            const mtick = mticks[j];
                            const y = lmax - (position + (i + 1) * mstep - min) * ratio;
                            if (lmin - padding <= y) {
                                mtick.lock(wcardinalUi.EShapeLockPart.UPLOADED);
                                mtick.visible = true;
                                mtick.transform.position.y = y;
                                mtick.unlock(wcardinalUi.EShapeLockPart.UPLOADED, true);
                            }
                            else {
                                mtick.visible = false;
                            }
                        }
                    }
                }
                else {
                    for (let i = (index + 1) * minorCount, imax = i + minorCount; i < imax; ++i) {
                        mticks[i].visible = false;
                    }
                }
            }
        }
        updateTicksY(min, max, ratio, lmin, lmax) {
            const ticks = this.ymajors;
            const mticks = this.yminors;
            const minorCount = this.yminorCount;
            const padding = this.ypadding;
            // Major tick positions
            const step = this.getStep(min, max, ticks.length);
            const positions = this.getTickPositions(min, max, ticks.length, step, padding, ratio, this.workMajorPositions);
            // First minors
            const mstep = this.toStepMinor(step, minorCount);
            this.updateTicksYMinor(mstep, -1, positions[0], min, ratio, lmin, lmax);
            // Major and minor ticks
            for (let i = 0, imax = ticks.length; i < imax; ++i) {
                const tick = ticks[i];
                const position = positions[i];
                if (position === position) {
                    // Major tick
                    tick.lock(wcardinalUi.EShapeLockPart.UPLOADED);
                    tick.visible = true;
                    tick.transform.position.y = lmax - (position - min) * ratio;
                    tick.text.value = this.yformatter.format(position, step);
                    tick.unlock(wcardinalUi.EShapeLockPart.UPLOADED, true);
                    // Minor ticks
                    this.updateTicksYMinor(mstep, i, positions[i], min, ratio, lmin, lmax);
                }
                else {
                    // Major tick
                    tick.visible = false;
                    // Minor ticks
                    if (0 < mticks.length) {
                        for (let j = (i + 1) * minorCount, jmax = j + minorCount; j < jmax; ++j) {
                            mticks[j].visible = false;
                        }
                    }
                }
            }
        }
        updateLines(data, xmin, xratio, lxmin, ymin, yratio, lymax) {
            const lines = this.lines;
            for (let i = 0, imax = Math.min(lines.length, data.size()); i < imax; ++i) {
                const value = data.get(i);
                if (value != null) {
                    const line = lines[i];
                    const points = line.points;
                    if (points != null) {
                        const pointsValues = points.values;
                        const valueValues = value.values;
                        const valueValuesLength = valueValues.length;
                        if (2 <= valueValuesLength) {
                            const valueTimes = value.times;
                            const valueTimesLength = valueTimes.length;
                            if (valueTimesLength < valueValuesLength) {
                                // Index mode
                                for (let j = 0; j < valueValuesLength; ++j) {
                                    const index = j << 1;
                                    pointsValues[index + 0] = (j + 1 - xmin) * xratio + lxmin;
                                    pointsValues[index + 1] = lymax - (valueValues[j] - ymin) * yratio;
                                }
                            }
                            else {
                                // Time mode
                                for (let j = 0; j < valueValuesLength; ++j) {
                                    const index = j << 1;
                                    pointsValues[index + 0] = (valueTimes[j] - xmin) * xratio + lxmin;
                                    pointsValues[index + 1] = lymax - (valueValues[j] - ymin) * yratio;
                                }
                            }
                            line.lock(wcardinalUi.EShapeLockPart.UPLOADED);
                            line.visible = true;
                            points.values = pointsValues;
                            line.unlock(wcardinalUi.EShapeLockPart.UPLOADED, true);
                        }
                        else {
                            line.visible = false;
                        }
                    }
                }
            }
        }
        execute(shape, runtime, time) {
            const data = shape.data;
            if (data.isChanged) {
                // Calculate the plot range in the time-value coordinate
                let xmin = +Infinity;
                let xmax = -Infinity;
                let ymin = +Infinity;
                let ymax = -Infinity;
                for (let i = 0, imax = data.size(); i < imax; ++i) {
                    const value = data.get(i);
                    if (value != null) {
                        const values = value.values;
                        const valuesLength = values.length;
                        const times = value.times;
                        const timesLength = times.length;
                        // X
                        if (timesLength < valuesLength) {
                            // Index mode
                            if (1 < xmin) {
                                xmin = 1;
                            }
                            if (xmax < valuesLength) {
                                xmax = valuesLength;
                            }
                        }
                        else {
                            // Time mode
                            for (let j = 0; j < timesLength; ++j) {
                                const t = times[j];
                                if (t < xmin) {
                                    xmin = t;
                                }
                                if (xmax < t) {
                                    xmax = t;
                                }
                            }
                        }
                        // Y
                        for (let j = 0; j < valuesLength; ++j) {
                            const v = values[j];
                            if (v < ymin) {
                                ymin = v;
                            }
                            if (ymax < v) {
                                ymax = v;
                            }
                        }
                    }
                }
                if (xmax < xmin) {
                    xmin = 0;
                    xmax = 1;
                }
                else if (xmax <= xmin) {
                    xmax = xmin + 1;
                }
                if (ymax < ymin) {
                    ymax = 1;
                    ymin = 0;
                }
                else if (ymax <= ymin) {
                    ymax = ymin + 1;
                }
                const xspan = xmax - xmin;
                const yspan = ymax - ymin;
                // Calculate plot range in the local coordinate
                const plotArea = this.plotArea;
                const size = plotArea != null ? plotArea.size : shape.size;
                const sx = size.x * 0.5;
                const sy = size.y * 0.5;
                const xpadding = this.xpadding;
                const ypadding = this.ypadding;
                const lxmin = -sx + xpadding;
                let lxmax = +sx - xpadding;
                const lymin = -sy + ypadding;
                let lymax = +sy - ypadding;
                if (lxmax <= lxmin) {
                    lxmax = lxmin + 1;
                }
                if (lymax <= lymin) {
                    lymax = lymin + 1;
                }
                const lxspan = lxmax - lxmin;
                const lyspan = lymax - lymin;
                // x (in the time-value coordinate)
                // lx (in the local coordinate)
                // lx = (x - xmin) / (xmax - xmin) * (lxmax - lxmin) + lxmin
                //    = (x - xmin) * xratio + lxmin
                // where xratio := (lxmax - lxmin) / (xmax - xmin)
                //
                // Please note thay the y coordinate in the local coordinate is upside down.
                // Namely, ly = lymax - (y - ymin) * yratio.
                const xratio = lxspan / xspan;
                const yratio = lyspan / yspan;
                // X ticks
                this.updateTicksX(xmin, xmax, xratio, lxmin, lxmax);
                // Y ticks
                this.updateTicksY(ymin, ymax, yratio, lymin, lymax);
                // Lines
                this.updateLines(data, xmin, xratio, lxmin, ymin, yratio, lymax);
            }
        }
    }

    class EShapeChartLineRuntime extends wcardinalUi.EShapeRuntimeImpl {
        constructor(shape) {
            super(shape);
            this.actions.push(new EShapeChartLineActionRuntime(shape));
        }
    }

    class EShapeChartLines {
        static getTheme() {
            return wcardinalUi.DThemes.get("EShapeChartLine");
        }
        static deserialize(item, manager) {
            const shape = new EShapeChartLine(manager.mode);
            const index = item[15];
            const resources = manager.resources;
            if (0 <= index && index < resources.length) {
                let parsed = manager.getExtension(index);
                if (parsed == null) {
                    parsed = JSON.parse(resources[index]);
                    manager.setExtension(index, parsed);
                }
                shape.axis.deserialize(parsed[0], manager);
                item[15] = parsed[parsed.length - 1];
            }
            const result = wcardinalUi.deserializeBase(item, manager, shape);
            shape.size.init();
            return result;
        }
        static create(existing) {
            const result = new EShapeChartLine(wcardinalUi.EShapeResourceManagerDeserializationMode.EDITOR);
            if (existing) {
                result.copy(existing);
            }
            // Plot area
            EShapeChartAxes.newPlotArea(result);
            // Line
            EShapeChartAxes.newLine(result);
            // Axis
            EShapeChartAxes.newXAxis(result);
            EShapeChartAxes.newXAxisTickMajor(result);
            EShapeChartAxes.newYAxis(result);
            EShapeChartAxes.newYAxisTickMajor(result);
            if (existing instanceof EShapeChartLine) {
                result.axis.copy(existing.axis);
            }
            return result;
        }
        static load() {
            const theme = this.getTheme();
            const name = theme.getName();
            EShapeExtensions.add({
                type: EShapeChartLineIds.ID,
                name,
                icon: {
                    width: 24,
                    height: 24,
                    // Material Icons https://material.io/tools/icons/
                    // Available under Apache license version 2.0
                    svg: `<g transform="scale(26.6666)" fill="#fff" stroke="none">` +
                        `<path d="M23,8c0,1.1-0.9,2-2,2c-0.18,0-0.35-0.02-0.51-0.07l-3.56,` +
                        `3.55C16.98,13.64,17,13.82,17,14c0,1.1-0.9,2-2,2s-2-0.9-2-2 c0-0.1` +
                        `8,0.02-0.36,0.07-0.52l-2.55-2.55C10.36,10.98,10.18,11,10,11c-0.18` +
                        `,0-0.36-0.02-0.52-0.07l-4.55,4.56 C4.98,15.65,5,15.82,5,16c0,1.1-` +
                        `0.9,2-2,2s-2-0.9-2-2s0.9-2,2-2c0.18,0,0.35,0.02,0.51,0.07l4.56-4.` +
                        `55C8.02,9.36,8,9.18,8,9 c0-1.1,0.9-2,2-2s2,0.9,2,2c0,0.18-0.02,0.` +
                        `36-0.07,0.52l2.55,2.55C14.64,12.02,14.82,12,15,12c0.18,0,0.36,0.0` +
                        `2,0.52,0.07 l3.55-3.56C19.02,8.35,19,8.18,19,8c0-1.1,0.9-2,2-2S23` +
                        `,6.9,23,8z"/>` +
                        `</g>`
                },
                title: name,
                creator: (existing) => EShapeChartLines.create(existing),
                editor: EEditorShapeChartLine,
                deserializer: (item, manager) => EShapeChartLines.deserialize(item, manager),
                runtime: EShapeChartLineRuntime
            });
        }
    }

    const loadShapeExtensionChartLine = () => {
        EShapeChartLines.load();
    };

    class EShapeInputs {
        static getTheme() {
            return wcardinalUi.DThemes.get("EShapeInput");
        }
        static create(existing) {
            const result = new wcardinalUi.EShapeRectangleRounded();
            if (existing) {
                result.copy(existing);
            }
            else {
                result.stroke.set(true, wcardinalUi.EShapeDefaults.STROKE_COLOR, 1, 1);
                result.fill.set(true, 0xffffff, 1);
                result.text.set(this.getTheme().getLabel());
                result.cursor = "text";
                result.state.isFocusable = true;
                result.interactive = true;
            }
            result.action.add(new wcardinalUi.EShapeActionValueMiscInput(wcardinalUi.EShapeActionValueMiscType.INPUT_TEXT, '"ALWAYS"', "", wcardinalUi.EShapeActionValueOnInputAction.EMIT_EVENT));
            result.action.add(new wcardinalUi.EShapeActionValueChangeColor(wcardinalUi.EShapeActionValueChangeColorType.STROKE, "inFocused", wcardinalUi.EShapeActionValueChangeColorTarget.COLOR, wcardinalUi.EShapeDefaults.HIGHLIGHT_COLOR, 0, ""));
            result.action.add(new wcardinalUi.EShapeActionValueChangeColor(wcardinalUi.EShapeActionValueChangeColorType.TEXT, "inDisabled", wcardinalUi.EShapeActionValueChangeColorTarget.ALPHA, 0, 0.5, ""));
            return result;
        }
        static load() {
            const theme = this.getTheme();
            const name = theme.getName();
            EShapeExtensions.add({
                icon: {
                    width: 24,
                    height: 24,
                    // Material Icons https://material.io/tools/icons/
                    // Available under Apache license version 2.0
                    svg: `<g transform="scale(26.6666)" fill="#fff" stroke="none">` +
                        `<path d="M22,9v6c0,1.1-0.9,2-2,2h-1l0-2h1V9H4v6h6v2H4c-1.1,0-2` +
                        `-0.9-2-2V9c0-1.1,0.9-2,2-2h16C21.1,7,22,7.9,22,9z"/>` +
                        `<path d="M5 4v3h5.5v12h3V7H19V4H5z" transform="translate(7.25,8.5) scale(0.6)" />` +
                        `</g>`
                },
                title: name,
                creator: (existing) => EShapeInputs.create(existing)
            });
        }
    }

    const loadShapeExtensionInput = () => {
        EShapeInputs.load();
    };

    class EShapeTableCell {
        constructor(parent) {
            this._parent = parent;
        }
        get values() {
            const parent = this._parent;
            const values = parent.data.values;
            const columnValues = parent.column.values;
            const result = [];
            for (let i = 0, imax = values.length; i < imax; ++i) {
                const value = values[i];
                const row = [];
                for (let j = 0, jmax = columnValues.length; j < jmax; ++j) {
                    const columnValue = columnValues[j];
                    const columnValueRuntime = columnValue.runtime;
                    if (columnValueRuntime != null) {
                        row.push(columnValueRuntime.toValue(value, j, values));
                    }
                }
                result.push(row);
            }
            return result;
        }
    }

    class EShapeTableColumnValueBody {
        isEquals(target) {
            return true;
        }
        serialize(manager) {
            return -1;
        }
        static deserialize(target, manager) {
            return new EShapeTableColumnValueBody();
        }
    }

    class EShapeTableColumnValueHeader {
        constructor(label) {
            this.label = label;
        }
        isEquals(target) {
            return this.label === target.label;
        }
        serialize(manager) {
            const labelId = manager.addResource(this.label);
            return manager.addResource(`[${labelId}]`);
        }
        static deserialize(target, manager) {
            const resources = manager.resources;
            if (0 <= target && target < resources.length) {
                let parsed = manager.getExtension(target);
                if (parsed == null) {
                    parsed = JSON.parse(resources[target]);
                    manager.setExtension(target, parsed);
                }
                return new EShapeTableColumnValueHeader(resources[parsed[0]]);
            }
            return new EShapeTableColumnValueHeader("");
        }
    }

    const EShapeTableColumnValueType = {
        TEXT: 0,
        NUMBER: 1
    };
    class EShapeTableColumnValue {
        constructor(weight, type, getter, setter, format, align, header, body) {
            this.weight = weight;
            this.type = type;
            this.getter = getter;
            this.setter = setter;
            this.format = format;
            this.align = align;
            this.header = header;
            this.body = body;
        }
        isEquals(target) {
            return (this.weight === target.weight &&
                this.type === target.type &&
                this.getter === target.getter &&
                this.setter === target.setter &&
                this.format === target.format &&
                this.align === target.align &&
                this.header.isEquals(target.header) &&
                this.body.isEquals(target.body));
        }
        toLabel() {
            return this.header.label;
        }
        serialize(manager) {
            const getterId = manager.addResource(this.getter);
            const setterId = manager.addResource(this.setter);
            const formatterId = manager.addResource(this.format);
            const headerId = this.header.serialize(manager);
            const bodyId = this.body.serialize(manager);
            return manager.addResource(`[${this.weight},${this.type},${getterId},${setterId},` +
                `${formatterId},${this.align},-1,${headerId},${bodyId}]`);
        }
        static deserialize(target, manager) {
            const resources = manager.resources;
            if (0 <= target && target < resources.length) {
                let parsed = manager.getExtension(target);
                if (parsed == null) {
                    parsed = JSON.parse(resources[target]);
                    manager.setExtension(target, parsed);
                }
                return new EShapeTableColumnValue(parsed[0], parsed[1], resources[parsed[2]], resources[parsed[3]], resources[parsed[4]], parsed[5], EShapeTableColumnValueHeader.deserialize(parsed[7], manager), EShapeTableColumnValueBody.deserialize(parsed[8], manager));
            }
            return null;
        }
    }

    class EShapeTableColumn {
        constructor(onChange) {
            this.values = [];
            this._sizeX = 1;
            this._onChange = onChange;
        }
        add(value, at) {
            if (at != null) {
                this.values.splice(at, 0, value);
            }
            else {
                this.values.push(value);
            }
            this._onChange();
        }
        remove(index) {
            const values = this.values;
            if (0 <= index && index < values.length) {
                const result = values.splice(index, 1)[0];
                this._onChange();
                return result;
            }
            return null;
        }
        indexOf(target) {
            const values = this.values;
            // Instance-based matching
            for (let i = 0, imax = values.length; i < imax; ++i) {
                const value = values[i];
                if (value === target) {
                    return i;
                }
            }
            // Data-based matching
            for (let i = 0, imax = values.length; i < imax; ++i) {
                const value = values[i];
                if (value.isEquals(target)) {
                    return i;
                }
            }
            return -1;
        }
        get(index) {
            const result = this.values[index];
            if (result != null) {
                return result;
            }
            return null;
        }
        set(index, value) {
            this.values[index] = value;
            this._onChange();
        }
        swap(indexA, indexB) {
            const values = this.values;
            const tmp = values[indexB];
            values[indexB] = values[indexA];
            values[indexA] = tmp;
            this._onChange();
        }
        size() {
            return this.values.length;
        }
        copy(source) {
            // Values
            const values = this.values;
            const sourceValues = source.values;
            const sourceValuesLength = sourceValues.length;
            for (let i = 0; i < sourceValuesLength; ++i) {
                values.push(sourceValues[i]);
            }
            if (values.length !== sourceValuesLength) {
                values.length = sourceValuesLength;
            }
            //
            this._sizeX = source._sizeX;
            this._onChange();
            return this;
        }
        serialize(manager) {
            let serialized = "";
            let delimiter = "[";
            const values = this.values;
            for (let i = 0, imax = values.length; i < imax; ++i) {
                const value = values[i];
                serialized += delimiter + value.serialize(manager);
                delimiter = ",";
            }
            serialized += "]";
            return manager.addResource(serialized);
        }
        deserialize(target, manager) {
            const resources = manager.resources;
            if (0 <= target && target < resources.length) {
                let parsed = manager.getExtension(target);
                if (parsed == null) {
                    parsed = JSON.parse(resources[target]);
                    manager.setExtension(target, parsed);
                }
                let isChanged = false;
                const values = this.values;
                if (0 < values.length) {
                    values.length = 0;
                    isChanged = true;
                }
                for (let i = 0, imax = parsed.length; i < imax; ++i) {
                    const value = EShapeTableColumnValue.deserialize(parsed[i], manager);
                    if (value != null) {
                        values.push(value);
                    }
                }
                if (0 < values.length) {
                    isChanged = true;
                }
                if (isChanged) {
                    this._onChange();
                }
            }
        }
    }

    class EShapeTableIds {
    }
    EShapeTableIds.ID = wcardinalUi.EShapeType.EXTENSION + 100;
    EShapeTableIds.HEADER_ID = wcardinalUi.EShapeType.EXTENSION + 101;
    EShapeTableIds.BODY_ID = wcardinalUi.EShapeType.EXTENSION + 102;

    const EShapeTableRowSelectionType = {
        NONE: 0,
        SINGLE: 1,
        MULTIPLE: 2
    };
    class EShapeTableRowSelection {
        constructor(parent) {
            this.parent = parent;
            this.type = EShapeTableRowSelectionType.NONE;
            this.indices = [];
            this.body = null;
        }
        get values() {
            const indices = this.indices;
            const values = this.parent.data.values;
            const result = (this._values = this._values || []);
            if (values != null) {
                result.length = 0;
                for (let i = 0, imax = indices.length; i < imax; ++i) {
                    const index = indices[i];
                    if (0 <= index && index < values.length) {
                        result.push(values[index]);
                    }
                }
            }
            return result;
        }
        size() {
            return this.indices.length;
        }
        isEmpty() {
            return this.indices.length <= 0;
        }
        toggle(index) {
            const indices = this.indices;
            const indexIndex = indices.indexOf(index);
            if (indexIndex < 0) {
                indices.push(index);
                const body = this.getBody();
                if (body != null) {
                    this.setRowActive(body, index, true);
                }
            }
            else {
                indices.splice(indexIndex, 1);
                const body = this.getBody();
                if (body != null) {
                    this.setRowActive(body, index, false);
                }
            }
        }
        add(index) {
            const indices = this.indices;
            const indexIndex = indices.indexOf(index);
            if (indexIndex < 0) {
                indices.push(index);
                const body = this.getBody();
                if (body != null) {
                    this.setRowActive(body, index, true);
                }
            }
        }
        addTo(index) {
            const indices = this.indices;
            const lastIndex = indices[indices.length - 1];
            if (lastIndex < index) {
                const body = this.getBody();
                for (let i = lastIndex + 1; i <= index; ++i) {
                    if (indices.indexOf(i) < 0) {
                        indices.push(i);
                        if (body != null) {
                            this.setRowActive(body, i, true);
                        }
                    }
                }
            }
            else if (index < lastIndex) {
                const body = this.getBody();
                for (let i = lastIndex - 1; index <= i; --i) {
                    if (indices.indexOf(i) < 0) {
                        indices.push(i);
                        if (body != null) {
                            this.setRowActive(body, i, true);
                        }
                    }
                }
            }
        }
        remove(index) {
            const indices = this.indices;
            const indexIndex = indices.indexOf(index);
            if (0 <= indexIndex) {
                indices.splice(indexIndex, 1);
                const body = this.getBody();
                if (body != null) {
                    this.setRowActive(body, index, false);
                }
            }
        }
        clear() {
            const indices = this.indices;
            const body = this.getBody();
            if (body != null) {
                for (let i = 0, imax = indices.length; i < imax; ++i) {
                    this.setRowActive(body, indices[i], false);
                }
            }
            indices.length = 0;
        }
        clearAndAdd(index) {
            const indices = this.indices;
            const body = this.getBody();
            if (body != null) {
                for (let i = 0, imax = indices.length; i < imax; ++i) {
                    const target = indices[i];
                    if (target !== index) {
                        this.setRowActive(body, target, false);
                    }
                }
                this.setRowActive(body, index, true);
            }
            indices.length = 0;
            indices.push(index);
        }
        getBody() {
            const body = this.body;
            if (body != null) {
                return body;
            }
            return (this.body = UtilShapeSearch.findChildByType(this.parent, EShapeTableIds.BODY_ID));
        }
        getRow(body, index) {
            const rows = body.children;
            if (0 <= index && index < rows.length) {
                return rows[index];
            }
            return null;
        }
        setRowActive(body, index, isActive) {
            const row = this.getRow(body, index);
            if (row != null) {
                const cells = row.children;
                for (let i = 0, imax = cells.length; i < imax; ++i) {
                    cells[i].state.isActive = isActive;
                }
            }
        }
        serialize(manager) {
            return manager.addResource(`[${this.type}]`);
        }
        deserialize(target, manager) {
            const resources = manager.resources;
            if (0 <= target && target < resources.length) {
                let parsed = manager.getExtension(target);
                if (parsed == null) {
                    parsed = JSON.parse(resources[target]);
                    manager.setExtension(target, parsed);
                }
                const type = parsed[0];
                if (this.type !== type) {
                    this.type = type;
                }
            }
        }
    }

    class EShapeTableRow {
        constructor(parent, onChange) {
            this._height = 40;
            this._onChange = onChange;
            this._isCellUpdateAllowed = true;
            this._isCellUpdateCalled = false;
            this.selection = new EShapeTableRowSelection(parent);
        }
        toDirty() {
            this.updateCells();
        }
        disallowCellUpdate() {
            this._isCellUpdateAllowed = false;
            this._isCellUpdateCalled = false;
        }
        allowCellUpdate(invoke) {
            this._isCellUpdateAllowed = true;
            const isCellUpdatedCalled = this._isCellUpdateCalled;
            if (invoke && isCellUpdatedCalled) {
                this.updateCells();
            }
        }
        updateCells() {
            if (this._isCellUpdateAllowed) {
                this._onChange();
            }
            else {
                this._isCellUpdateCalled = true;
            }
        }
        get height() {
            return this._height;
        }
        set height(height) {
            height = Math.max(5, height);
            if (this._height !== height) {
                this._height = height;
                this.updateCells();
            }
        }
        copy(source) {
            this.disallowCellUpdate();
            this._height = source._height;
            this.allowCellUpdate(false);
            this.updateCells();
            return this;
        }
        serialize(manager) {
            const selectionId = this.selection.serialize(manager);
            return manager.addResource(`[${this._height},${selectionId}]`);
        }
        deserialize(target, manager) {
            const resources = manager.resources;
            if (0 <= target && target < resources.length) {
                let parsed = manager.getExtension(target);
                if (parsed == null) {
                    parsed = JSON.parse(resources[target]);
                    manager.setExtension(target, parsed);
                }
                let isChanged = false;
                const height = parsed[0];
                if (this._height !== height) {
                    this._height = height;
                    isChanged = true;
                }
                this.selection.deserialize(parsed[1], manager);
                if (isChanged) {
                    this._onChange();
                }
            }
        }
    }

    class EShapeTable extends wcardinalUi.EShapeGroupShadowed {
        constructor(mode, type = EShapeTableIds.ID) {
            super(mode, type);
            this._columnWidths = [];
            this._columnXs = [];
            this.column = new EShapeTableColumn(() => {
                this.onColumnChange();
            });
            this.row = new EShapeTableRow(this, () => {
                this.onRowChange();
            });
            this.cell = new EShapeTableCell(this);
        }
        onColumnChange() {
            this.newCellsHeader();
            this.newCellsBody(true);
            this.layoutCells();
        }
        onRowChange() {
            this.newCellsBody(false);
            this.layoutCells();
        }
        onSizeChange() {
            super.onSizeChange();
            this.newCellsBody(false);
            this.layoutCells();
        }
        newCellsHeader() {
            if (this.children.length <= 0) {
                return;
            }
            const header = this.children[0];
            const column = this.column;
            const columnCount = column.size();
            const values = column.values;
            // Create / delete children
            const children = header.children;
            const childrenLength = children.length;
            if (childrenLength < columnCount) {
                const master = children[childrenLength - 1] || this;
                for (let i = childrenLength; i < columnCount; ++i) {
                    const cell = new wcardinalUi.EShapeRectangle().copy(master);
                    cell.text.value = values[i].header.label;
                    cell.attach(header);
                }
            }
            else if (columnCount < childrenLength) {
                for (let i = childrenLength - 1; columnCount <= i; --i) {
                    children[i].detach();
                }
            }
            // Update text
            for (let i = 0; i < columnCount; ++i) {
                children[i].text.value = values[i].header.label;
            }
        }
        toRowCountRequired() {
            return Math.min(1000, Math.max(1, Math.floor(Math.abs(this.size.y) / this.row.height))) - 1;
        }
        newCellsBody(isColumnDirty) {
            // Rows
            if (this.children.length <= 1) {
                return;
            }
            const body = this.children[1];
            const rows = body.children;
            const rowsLength = rows.length;
            const rowCountRequired = this.toRowCountRequired();
            const rowCount = Math.max(2, rowCountRequired);
            if (rowsLength < rowCount) {
                const masterEven = (0 < rowsLength ? rows[0] : null) || this;
                const masterOdd = (1 < rowsLength ? rows[1] : null) || this;
                const mode = this.mode;
                for (let irow = rowsLength; irow < rowCount; ++irow) {
                    const master = irow % 2 === 0 ? masterEven : masterOdd;
                    new wcardinalUi.EShapeGroupShadowed(mode).copy(master, wcardinalUi.EShapeCopyPart.ACTION).attach(body);
                }
            }
            else if (rowCount < rowsLength) {
                for (let i = rowsLength - 1; rowCount <= i; --i) {
                    rows[i].detach();
                }
            }
            if (0 < rows.length) {
                rows[0].visible = 0 < rowCountRequired;
            }
            if (1 < rows.length) {
                rows[1].visible = 1 < rowCountRequired;
            }
            // Cells
            const masterCellEven = (0 < rows.length ? rows[0].children[0] : null) || this;
            const masterCellOdd = (1 < rows.length ? rows[1].children[0] : null) || this;
            const column = this.column;
            const columnValues = column.values;
            const columnCount = column.size();
            for (let irow = 0; irow < rowCount; ++irow) {
                const columnCountRequired = irow <= 1 ? Math.max(1, columnCount) : columnCount;
                const row = rows[irow];
                const cells = row.children;
                const cellsLength = cells.length;
                const master = irow % 2 === 0 ? masterCellEven : masterCellOdd;
                if (cellsLength < columnCountRequired) {
                    for (let icolumn = cellsLength; icolumn < columnCountRequired; ++icolumn) {
                        new wcardinalUi.EShapeRectangle().copy(master).attach(row);
                    }
                }
                else if (columnCountRequired < cellsLength) {
                    for (let i = cellsLength - 1; columnCountRequired <= i; --i) {
                        cells[i].detach();
                    }
                }
                if (0 < cells.length) {
                    cells[0].visible = 0 < columnCount;
                }
                if (1 < cells.length) {
                    cells[1].visible = 1 < columnCount;
                }
                if (isColumnDirty) {
                    for (let i = 0; i < columnCount; ++i) {
                        cells[i].text.align.horizontal = columnValues[i].align;
                    }
                }
            }
        }
        layoutCells() {
            if (this.children.length <= 1) {
                return;
            }
            const rowHeight = this.row.height;
            const rowHeightHalf = rowHeight * 0.5;
            const column = this.column;
            const size = this.size;
            const sizeX = size.x;
            const sizeY = size.y;
            const sxh = -sizeX * 0.5;
            const syh = -sizeY * 0.5;
            const columnValues = column.values;
            const columnValuesLength = columnValues.length;
            // Total weight
            let totalWeight = 0;
            for (let i = 0; i < columnValuesLength; ++i) {
                totalWeight += columnValues[i].weight;
            }
            totalWeight = Math.max(0.00001, totalWeight);
            // Column width and x position
            const columnWidths = this._columnWidths;
            const columnXs = this._columnXs;
            const columnWidthFactor = sizeX / totalWeight;
            let columnX = 0;
            for (let i = 0; i < columnValuesLength; ++i) {
                const columnWidth = columnValues[i].weight * columnWidthFactor;
                columnWidths[i] = columnWidth;
                columnXs[i] = columnX + columnWidth * 0.5;
                columnX += columnWidth;
            }
            // Header
            const header = this.children[0];
            header.lock(wcardinalUi.EShapeLockPart.ALL);
            header.size.set(sizeX, rowHeight);
            header.transform.position.set(0, syh + rowHeightHalf);
            header.unlock(wcardinalUi.EShapeLockPart.ALL, true);
            const hcells = header.children;
            const hcellsLength = hcells.length;
            for (let icolumn = 0; icolumn < hcellsLength; ++icolumn) {
                const hcell = hcells[icolumn];
                hcell.lock(wcardinalUi.EShapeLockPart.ALL);
                hcell.size.set(columnWidths[icolumn], rowHeight);
                hcell.transform.position.set(sxh + columnXs[icolumn], 0);
                hcell.unlock(wcardinalUi.EShapeLockPart.ALL, true);
            }
            // Body
            const body = this.children[1];
            body.lock(wcardinalUi.EShapeLockPart.ALL);
            body.size.set(sizeX, sizeY - rowHeight);
            body.transform.position.set(0, rowHeightHalf);
            body.unlock(wcardinalUi.EShapeLockPart.ALL, true);
            const rows = body.children;
            const rowsLength = rows.length;
            for (let irow = 0, y = syh + rowHeight; irow < rowsLength; ++irow, y += rowHeight) {
                const row = rows[irow];
                row.lock(wcardinalUi.EShapeLockPart.ALL);
                row.size.set(sizeX, rowHeight);
                row.transform.position.set(0, y);
                row.unlock(wcardinalUi.EShapeLockPart.ALL, true);
                const cells = row.children;
                const cellsLength = cells.length;
                for (let icolumn = 0; icolumn < cellsLength; ++icolumn) {
                    const cell = cells[icolumn];
                    cell.lock(wcardinalUi.EShapeLockPart.ALL);
                    cell.size.set(columnWidths[icolumn], rowHeight);
                    cell.transform.position.set(sxh + columnXs[icolumn], 0);
                    cell.unlock(wcardinalUi.EShapeLockPart.ALL, true);
                }
            }
        }
        copy(source, part = wcardinalUi.EShapeCopyPart.ALL) {
            const result = super.copy(source, part);
            if (source instanceof EShapeTable) {
                this.column.copy(source.column);
                this.row.copy(source.row);
            }
            return result;
        }
        serialize(manager) {
            const result = super.serialize(manager);
            const resource = result[15];
            result[15] = manager.addResource(`[${this.column.serialize(manager)},${this.row.serialize(manager)},${resource}]`);
            return result;
        }
    }

    class ECommandShapeTableColumnValueAdd extends wcardinalUi.DCommandBase {
        constructor(value, selection) {
            super();
            this._selection = selection;
            this._value = value;
        }
        execute() {
            return this.redo();
        }
        redo() {
            const value = this._value;
            const shapes = this._selection.get();
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                if (shape instanceof EShapeTable) {
                    shape.column.add(value);
                }
            }
            this._selection.update("PROPERTY");
            return true;
        }
        undo() {
            const shapes = this._selection.get();
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                if (shape instanceof EShapeTable) {
                    shape.column.remove(shape.column.size() - 1);
                }
            }
            this._selection.update("PROPERTY");
            return true;
        }
    }

    class ECommandShapeTableColumnValueBringForward extends wcardinalUi.DCommandBase {
        constructor(target, selection) {
            super();
            this._selection = selection;
            this._target = target;
            const indices = [];
            const shapes = this._selection.get();
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                if (shape instanceof EShapeTable) {
                    const index = shape.column.indexOf(target);
                    indices.push(index);
                    if (0 < index) {
                        shape.column.swap(index - 1, index);
                    }
                }
            }
            this._indices = indices;
            this._selection.update("PROPERTY");
        }
        execute() {
            return true;
        }
        redo() {
            const shapes = this._selection.get();
            const indices = this._indices;
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                if (shape instanceof EShapeTable) {
                    const index = indices[i];
                    if (0 < index) {
                        shape.column.swap(index - 1, index);
                    }
                }
            }
            this._selection.update("PROPERTY");
            return true;
        }
        undo() {
            return this.redo();
        }
    }

    class ECommandShapeTableColumnValueRemove extends wcardinalUi.DCommandBase {
        constructor(target, selection) {
            super();
            this._selection = selection;
            this._target = target;
            const indices = [];
            const shapes = this._selection.get();
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                if (shape instanceof EShapeTable) {
                    const index = shape.column.indexOf(target);
                    indices.push(index);
                    if (0 <= index) {
                        shape.column.remove(index);
                    }
                }
            }
            this._indices = indices;
            this._selection.update("PROPERTY");
        }
        execute() {
            return true;
        }
        redo() {
            const indices = this._indices;
            const shapes = this._selection.get();
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                if (shape instanceof EShapeTable) {
                    const index = indices[i];
                    if (0 <= index) {
                        shape.column.remove(index);
                    }
                }
            }
            this._selection.update("PROPERTY");
            return true;
        }
        undo() {
            const target = this._target;
            const indices = this._indices;
            const shapes = this._selection.get();
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                if (shape instanceof EShapeTable) {
                    const index = indices[i];
                    if (0 <= index) {
                        shape.column.add(target, index);
                    }
                }
            }
            this._selection.update("PROPERTY");
            return true;
        }
    }

    class ECommandShapeTableColumnValueReplace extends wcardinalUi.DCommandBase {
        constructor(oldValue, newValue, selection, list) {
            super();
            this._selection = selection;
            this._oldValue = oldValue;
            this._newValue = newValue;
            this._list = list;
            const indices = [];
            const oldValues = [];
            const shapes = this._selection.get();
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                if (shape instanceof EShapeTable) {
                    const index = shape.column.indexOf(oldValue);
                    indices.push(index);
                    if (0 <= index) {
                        oldValues.push(shape.column.get(index));
                        shape.column.set(index, newValue);
                    }
                    else {
                        oldValues.push(newValue);
                    }
                }
                else {
                    indices.push(-1);
                    oldValues.push(newValue);
                }
            }
            this._indices = indices;
            this._oldValues = oldValues;
            if (list.data.selection.contains(oldValue)) {
                list.data.selection.clearAndAdd(newValue);
            }
            this._selection.update("PROPERTY");
        }
        execute() {
            return true;
        }
        redo() {
            const newValue = this._newValue;
            const indices = this._indices;
            const shapes = this._selection.get();
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                if (shape instanceof EShapeTable) {
                    const index = indices[i];
                    if (0 <= index) {
                        shape.column.set(index, newValue);
                    }
                }
            }
            const list = this._list;
            if (list.data.selection.contains(this._oldValue)) {
                list.data.selection.clearAndAdd(newValue);
            }
            this._selection.update("PROPERTY");
            return true;
        }
        undo() {
            const indices = this._indices;
            const oldValues = this._oldValues;
            const shapes = this._selection.get();
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                if (shape instanceof EShapeTable) {
                    const index = indices[i];
                    if (0 <= index) {
                        shape.column.set(index, oldValues[i]);
                    }
                }
            }
            const list = this._list;
            if (list.data.selection.contains(this._newValue)) {
                list.data.selection.clearAndAdd(this._oldValue);
            }
            this._selection.update("PROPERTY");
            return true;
        }
    }

    class ECommandShapeTableColumnValueSendBackward extends wcardinalUi.DCommandBase {
        constructor(target, selection) {
            super();
            this._selection = selection;
            this._target = target;
            const indices = [];
            const shapes = this._selection.get();
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                if (shape instanceof EShapeTable) {
                    const column = shape.column;
                    const index = column.indexOf(target);
                    indices.push(index);
                    if (0 <= index && index < column.size() - 1) {
                        column.swap(index + 1, index);
                    }
                }
                else {
                    indices.push(-1);
                }
            }
            this._indices = indices;
            this._selection.update("PROPERTY");
        }
        execute() {
            return true;
        }
        redo() {
            const shapes = this._selection.get();
            const indices = this._indices;
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                if (shape instanceof EShapeTable) {
                    const column = shape.column;
                    const index = indices[i];
                    if (0 <= index && index < column.size() - 1) {
                        column.swap(index + 1, index);
                    }
                }
            }
            this._selection.update("PROPERTY");
            return true;
        }
        undo() {
            return this.redo();
        }
    }

    class ECommandShapeTableRowHeight extends wcardinalUi.DCommandBase {
        constructor(value, selection) {
            super();
            const shapes = selection.get();
            const values = [];
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                if (shape instanceof EShapeTable) {
                    values.push(shape.row.height);
                    shape.row.height = value;
                }
                else {
                    values.push(35);
                }
            }
            this._values = values;
            this._selection = selection;
        }
        execute() {
            return true;
        }
        redo() {
            const selection = this._selection;
            const shapes = selection.get();
            const values = [];
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                if (shape instanceof EShapeTable) {
                    const value = values[i];
                    values[i] = shape.row.height;
                    shape.row.height = value;
                }
            }
            selection.update("PROPERTY");
            return true;
        }
        undo() {
            return this.redo();
        }
    }

    class ECommandShapeTableRowSelectionType extends wcardinalUi.DCommandBase {
        constructor(value, selection) {
            super();
            const shapes = selection.get();
            const values = [];
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                if (shape instanceof EShapeTable) {
                    values.push(shape.row.selection.type);
                    shape.row.selection.type = value;
                }
                else {
                    values.push(EShapeTableRowSelectionType.NONE);
                }
            }
            this._values = values;
            this._selection = selection;
        }
        execute() {
            return true;
        }
        redo() {
            const selection = this._selection;
            const shapes = selection.get();
            const values = [];
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                if (shape instanceof EShapeTable) {
                    const value = values[i];
                    values[i] = shape.row.selection.type;
                    shape.row.selection.type = value;
                }
            }
            selection.update("PROPERTY");
            return true;
        }
        undo() {
            return this.redo();
        }
    }

    class EDialogTableColumn extends wcardinalUi.DDialogLayered {
        newContentChildren(theme, options) {
            const result = super.newContentChildren(theme, options);
            // Type
            result.push(new wcardinalUi.DLayoutHorizontal({
                width: "padding",
                height: "auto",
                children: [
                    new wcardinalUi.DInputLabel({
                        width: 60,
                        text: {
                            value: theme.getSelectColumnValueTypeLabel()
                        }
                    }),
                    new wcardinalUi.DSelect({
                        weight: 1,
                        value: EShapeTableColumnValueType.TEXT,
                        menu: {
                            items: [
                                {
                                    value: EShapeTableColumnValueType.TEXT,
                                    text: {
                                        value: theme.toSelectColumnValueTypeLabel(EShapeTableColumnValueType.TEXT)
                                    }
                                },
                                {
                                    value: EShapeTableColumnValueType.NUMBER,
                                    text: {
                                        value: theme.toSelectColumnValueTypeLabel(EShapeTableColumnValueType.NUMBER)
                                    }
                                }
                            ]
                        },
                        on: {
                            init: (self) => {
                                this._selectType = self;
                            }
                        }
                    }),
                    new wcardinalUi.DLayoutSpace({
                        width: 60
                    })
                ]
            }));
            // Label
            result.push(new wcardinalUi.DLayoutHorizontal({
                width: "padding",
                height: "auto",
                children: [
                    new wcardinalUi.DInputLabel({
                        width: 60,
                        text: {
                            value: theme.getInputLabelLabel()
                        }
                    }),
                    new wcardinalUi.DInputText({
                        weight: 1,
                        text: {
                            value: ""
                        },
                        on: {
                            init: (self) => {
                                this._inputLabel = self;
                            },
                            enter: () => {
                                this.ok();
                            }
                        }
                    }),
                    new wcardinalUi.DLayoutSpace({
                        width: 60
                    })
                ]
            }));
            // Width Weight
            result.push(new wcardinalUi.DLayoutHorizontal({
                width: "padding",
                height: "auto",
                children: [
                    new wcardinalUi.DInputLabel({
                        width: 60,
                        text: {
                            value: theme.getInputWidthLabel()
                        }
                    }),
                    new wcardinalUi.DInputReal({
                        weight: 1,
                        text: {
                            value: 0
                        },
                        min: 0,
                        on: {
                            init: (self) => {
                                this._inputWidth = self;
                            },
                            enter: () => {
                                this.ok();
                            }
                        }
                    }),
                    new wcardinalUi.DLayoutSpace({
                        width: 60
                    })
                ]
            }));
            // Getter / setter
            result.push(new wcardinalUi.DLayoutHorizontal({
                width: "padding",
                height: "auto",
                children: [
                    new wcardinalUi.DInputLabel({
                        width: 60,
                        text: {
                            value: theme.getInputGetterLabel()
                        }
                    }),
                    new wcardinalUi.DInputText({
                        weight: 1,
                        text: {
                            value: ""
                        },
                        on: {
                            init: (self) => {
                                this._inputGetter = self;
                            },
                            enter: () => {
                                this.ok();
                            }
                        }
                    }),
                    new wcardinalUi.DLayoutSpace({
                        width: 60
                    })
                ]
            }));
            result.push(new wcardinalUi.DLayoutHorizontal({
                width: "padding",
                height: "auto",
                children: [
                    new wcardinalUi.DInputLabel({
                        width: 60,
                        text: {
                            value: theme.getInputSetterLabel()
                        }
                    }),
                    new wcardinalUi.DInputText({
                        weight: 1,
                        text: {
                            value: ""
                        },
                        on: {
                            init: (self) => {
                                this._inputSetter = self;
                            },
                            enter: () => {
                                this.ok();
                            }
                        }
                    }),
                    new wcardinalUi.DLayoutSpace({
                        width: 60
                    })
                ]
            }));
            // Format
            result.push(new wcardinalUi.DLayoutHorizontal({
                width: "padding",
                height: "auto",
                children: [
                    new wcardinalUi.DInputLabel({
                        width: 60,
                        text: {
                            value: theme.getInputFormatLabel()
                        }
                    }),
                    new wcardinalUi.DInputText({
                        weight: 1,
                        text: {
                            value: ""
                        },
                        on: {
                            init: (self) => {
                                this._inputFormat = self;
                            },
                            enter: () => {
                                this.ok();
                            }
                        }
                    }),
                    new wcardinalUi.DLayoutSpace({
                        width: 60
                    })
                ]
            }));
            // Align
            result.push(new wcardinalUi.DLayoutHorizontal({
                width: "padding",
                height: "auto",
                children: [
                    new wcardinalUi.DInputLabel({
                        width: 60,
                        text: {
                            value: theme.getSelectTextAlignLabel()
                        }
                    }),
                    new wcardinalUi.DSelect({
                        weight: 1,
                        value: wcardinalUi.EShapeTextAlignHorizontal.CENTER,
                        menu: {
                            items: [
                                {
                                    value: wcardinalUi.EShapeTextAlignHorizontal.LEFT,
                                    text: {
                                        value: theme.toTextAlignLabel(wcardinalUi.EShapeTextAlignHorizontal.LEFT)
                                    }
                                },
                                {
                                    value: wcardinalUi.EShapeTextAlignHorizontal.CENTER,
                                    text: {
                                        value: theme.toTextAlignLabel(wcardinalUi.EShapeTextAlignHorizontal.CENTER)
                                    }
                                },
                                {
                                    value: wcardinalUi.EShapeTextAlignHorizontal.RIGHT,
                                    text: {
                                        value: theme.toTextAlignLabel(wcardinalUi.EShapeTextAlignHorizontal.RIGHT)
                                    }
                                }
                            ]
                        },
                        on: {
                            init: (self) => {
                                this._selectAlign = self;
                            }
                        }
                    }),
                    new wcardinalUi.DLayoutSpace({
                        width: 60
                    })
                ]
            }));
            return result;
        }
        reset() {
            this._selectType.value = EShapeTableColumnValueType.TEXT;
            this._inputLabel.value = this.theme.newInputLabel();
            this._inputWidth.value = 1;
            this._inputGetter.value = "";
            this._inputSetter.value = "";
            this._inputFormat.value = "";
            this._selectAlign.value = wcardinalUi.EShapeTextAlignHorizontal.CENTER;
            return this;
        }
        get value() {
            return new EShapeTableColumnValue(this._inputWidth.value, this._selectType.value || EShapeTableColumnValueType.TEXT, this._inputGetter.value, this._inputSetter.value, this._inputFormat.value, this._selectAlign.value || wcardinalUi.EShapeTextAlignHorizontal.LEFT, new EShapeTableColumnValueHeader(this._inputLabel.value), new EShapeTableColumnValueBody());
        }
        set value(value) {
            if (value != null) {
                this._selectType.value = value.type;
                this._inputLabel.value = value.header.label;
                this._inputWidth.value = value.weight;
                this._inputGetter.value = value.getter;
                this._inputSetter.value = value.setter;
                this._inputFormat.value = value.format;
                this._selectAlign.value = value.align;
            }
        }
        getResolvedValue() {
            return this.value;
        }
        getType() {
            return "EDialogShapeTableColumn";
        }
    }

    class EEditorShapeTable extends wcardinalUi.DPane {
        constructor(options) {
            super(options);
            this._icons = options.icons;
            const selection = options.selection;
            this._selection = selection;
            this.state.isDisabled = selection.isEmpty();
            selection.on("change", () => {
                this.state.isDisabled = selection.isEmpty();
            });
            this.content.setHeight("padding");
            new wcardinalUi.DLayoutVertical({
                parent: this.content,
                x: "padding",
                y: "padding",
                width: "padding",
                height: "padding",
                children: [
                    new wcardinalUi.DLayoutHorizontal({
                        width: "100%",
                        height: "auto",
                        children: [
                            this.newTextLabel(),
                            this.buttonNew,
                            this.buttonDelete,
                            this.buttonBringForward,
                            this.buttonSendBackward
                        ]
                    }),
                    this.columnList,
                    new wcardinalUi.DText({
                        width: "100%",
                        text: {
                            value: this.subtheme.getInputRowHeightLabel()
                        }
                    }),
                    this.inputRowHeight,
                    new wcardinalUi.DText({
                        width: "100%",
                        text: {
                            value: this.subtheme.getSelectRowSelectionTypeLabel()
                        }
                    }),
                    this.selectRowSelectionType
                ]
            });
            selection.on("change", () => {
                this.onSelectionChange(selection);
            });
            const columnList = this.columnList;
            columnList.data.selection.on("change", () => {
                this.onListSelectionChange(columnList);
            });
            this.onSelectionChange(selection);
        }
        newTextLabel() {
            return new wcardinalUi.DText({
                weight: 1,
                text: {
                    value: this.subtheme.getLabel()
                }
            });
        }
        get buttonNew() {
            var _a;
            return ((_a = this._buttonNew) !== null && _a !== void 0 ? _a : (this._buttonNew = this.newButtonNew()));
        }
        newButtonNew() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.new
                },
                title: this.subtheme.getButtonNewTitle(),
                on: {
                    active: (emitter) => {
                        this.onButtonNewActive(emitter);
                    }
                }
            });
        }
        onButtonNewActive(opener) {
            this.columnDialog
                .reset()
                .open(opener)
                .then((value) => {
                if (value != null) {
                    wcardinalUi.DControllers.getCommandController().push(new ECommandShapeTableColumnValueAdd(value, this._selection));
                }
            });
        }
        onSelectionChangeButtonNew(selection) {
            const buttonNew = this.buttonNew;
            if (selection.last() instanceof EShapeTable) {
                buttonNew.state.isDisabled = false;
            }
            else {
                buttonNew.state.isDisabled = true;
            }
        }
        get buttonDelete() {
            var _a;
            return ((_a = this._buttonDelete) !== null && _a !== void 0 ? _a : (this._buttonDelete = this.newButtonDelete()));
        }
        newButtonDelete() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.delete
                },
                title: this.subtheme.getButtonDeleteTitle(),
                on: {
                    active: () => {
                        const columnList = this.columnList;
                        const first = columnList.data.selection.first;
                        if (first != null && 1 < columnList.data.size()) {
                            wcardinalUi.DControllers.getCommandController().push(new ECommandShapeTableColumnValueRemove(first, this._selection));
                        }
                    }
                }
            });
        }
        onListSelectionChangeButtonDelete(columnList) {
            this.buttonDelete.state.isDisabled =
                columnList.data.size() <= 1 || columnList.data.selection.isEmpty();
        }
        get buttonBringForward() {
            var _a;
            return ((_a = this._buttonBringForward) !== null && _a !== void 0 ? _a : (this._buttonBringForward = this.newButtonBringForward()));
        }
        newButtonBringForward() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.arrow_up
                },
                title: this.subtheme.getButtonBringForwardTitle(),
                on: {
                    active: () => {
                        const columnList = this.columnList;
                        const first = columnList.selection.first;
                        if (first != null && columnList.data.items[0] !== first) {
                            wcardinalUi.DControllers.getCommandController().push(new ECommandShapeTableColumnValueBringForward(first, this._selection));
                        }
                    }
                }
            });
        }
        onListSelectionChangeButtonBringForward(columnList) {
            const first = columnList.data.selection.first;
            const items = columnList.data.items;
            this.buttonBringForward.state.isDisabled = first == null || items[0] === first;
        }
        get buttonSendBackward() {
            var _a;
            return ((_a = this._buttonSendBackward) !== null && _a !== void 0 ? _a : (this._buttonSendBackward = this.newButtonSendBackward()));
        }
        newButtonSendBackward() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.arrow_down
                },
                title: this.subtheme.getButtonSendBackwardTitle(),
                on: {
                    active: () => {
                        const columnList = this.columnList;
                        const first = columnList.selection.first;
                        const items = columnList.data.items;
                        if (first != null && items[items.length - 1] !== first) {
                            wcardinalUi.DControllers.getCommandController().push(new ECommandShapeTableColumnValueSendBackward(first, this._selection));
                        }
                    }
                }
            });
        }
        onListSelectionChangeButtonSendBackward(columnList) {
            const first = columnList.selection.first;
            const items = columnList.data.items;
            this.buttonSendBackward.state.isDisabled =
                first == null || items[items.length - 1] === first;
        }
        get columnDialog() {
            var _a;
            return ((_a = this._columnDialog) !== null && _a !== void 0 ? _a : (this._columnDialog = this.newColumnDialog()));
        }
        newColumnDialog() {
            return new EDialogTableColumn();
        }
        get columnList() {
            var _a;
            return ((_a = this._columnList) !== null && _a !== void 0 ? _a : (this._columnList = this.newColumnList()));
        }
        newColumnList() {
            const result = new wcardinalUi.DList({
                width: "100%",
                weight: 1,
                data: {
                    toLabel: (value) => {
                        return value.toLabel();
                    }
                },
                updater: {
                    newItem: (data) => {
                        return new wcardinalUi.DListItem(data, {
                            on: {
                                dblclick: (e, _, item) => {
                                    this.onColumnListDblClick(e, _, item, result);
                                }
                            }
                        });
                    }
                }
            });
            return result;
        }
        onColumnListDblClick(e, _, item, list) {
            const oldValue = item.value;
            if (oldValue != null) {
                const columnDialog = this.columnDialog;
                columnDialog.value = oldValue;
                columnDialog.open(item).then(() => {
                    const newValue = columnDialog.value;
                    if (newValue != null) {
                        wcardinalUi.DControllers.getCommandController().push(new ECommandShapeTableColumnValueReplace(oldValue, newValue, this._selection, list));
                    }
                });
            }
        }
        onSelectionChangeColumnList(selection) {
            const last = selection.last();
            const columnList = this.columnList;
            columnList.data.items = last instanceof EShapeTable ? last.column.values : [];
            this.onListSelectionChange(columnList);
        }
        get inputRowHeight() {
            var _a;
            return ((_a = this._inputRowHeight) !== null && _a !== void 0 ? _a : (this._inputRowHeight = this.newInputRowHeight()));
        }
        newInputRowHeight() {
            return new wcardinalUi.DInputReal({
                width: "100%",
                min: 5,
                step: 1,
                on: {
                    change: (value) => {
                        wcardinalUi.DControllers.getCommandController().push(new ECommandShapeTableRowHeight(value, this._selection));
                    }
                }
            });
        }
        onSelectionChangeInputRowHeight(selection) {
            const last = selection.last();
            const input = this.inputRowHeight;
            if (last instanceof EShapeTable) {
                input.value = last.row.height;
                input.state.isDisabled = false;
            }
            else {
                input.state.isDisabled = true;
            }
        }
        get selectRowSelectionType() {
            var _a;
            return ((_a = this._selectRowSelectionType) !== null && _a !== void 0 ? _a : (this._selectRowSelectionType = this.newSelectRowSelectionType()));
        }
        newSelectRowSelectionType() {
            const subtheme = this.subtheme;
            return new wcardinalUi.DSelect({
                width: "100%",
                value: EShapeTableRowSelectionType.SINGLE,
                menu: {
                    items: [
                        {
                            value: EShapeTableRowSelectionType.NONE,
                            text: {
                                value: subtheme.toSelectRowSelectionTypeLabel(EShapeTableRowSelectionType.NONE)
                            }
                        },
                        {
                            value: EShapeTableRowSelectionType.SINGLE,
                            text: {
                                value: subtheme.toSelectRowSelectionTypeLabel(EShapeTableRowSelectionType.SINGLE)
                            }
                        },
                        {
                            value: EShapeTableRowSelectionType.MULTIPLE,
                            text: {
                                value: subtheme.toSelectRowSelectionTypeLabel(EShapeTableRowSelectionType.MULTIPLE)
                            }
                        }
                    ]
                },
                on: {
                    change: (value) => {
                        if (value == null) {
                            value = EShapeTableRowSelectionType.SINGLE;
                        }
                        wcardinalUi.DControllers.getCommandController().push(new ECommandShapeTableRowSelectionType(value, this._selection));
                    }
                }
            });
        }
        onSelectionChangeSelectRowSelectionType(selection) {
            const last = selection.last();
            const select = this.selectRowSelectionType;
            if (last instanceof EShapeTable) {
                select.value = last.row.selection.type;
                select.state.isDisabled = false;
            }
            else {
                select.state.isDisabled = true;
            }
        }
        onSelectionChange(selection) {
            this.onSelectionChangeButtonNew(selection);
            this.onSelectionChangeColumnList(selection);
            this.onSelectionChangeInputRowHeight(selection);
            this.onSelectionChangeSelectRowSelectionType(selection);
        }
        onListSelectionChange(columnList) {
            this.onListSelectionChangeButtonDelete(columnList);
            this.onListSelectionChangeButtonBringForward(columnList);
            this.onListSelectionChangeButtonSendBackward(columnList);
        }
        get subtheme() {
            var _a;
            return ((_a = this._subtheme) !== null && _a !== void 0 ? _a : (this._subtheme = this.newSubtheme()));
        }
        newSubtheme() {
            return wcardinalUi.DThemes.get("EEditorShapeTable");
        }
    }

    class EShapeTableActionRuntime extends wcardinalUi.EShapeActionRuntimeBase {
        constructor(table) {
            super();
            this.body = UtilShapeSearch.findChildByType(table, EShapeTableIds.BODY_ID);
            this.column = table.column;
        }
        execute(shape, runtime, time) {
            const body = this.body;
            const column = this.column;
            if (body != null && column != null) {
                const data = shape.data;
                if (data.isChanged) {
                    const rows = body.children;
                    const rowsLength = rows.length;
                    const first = data.get(0);
                    if (first != null) {
                        const columnValues = column.values;
                        const values = first.values;
                        const valuesLength = values.length;
                        const imin = Math.min(rowsLength, valuesLength);
                        for (let i = 0; i < imin; ++i) {
                            const value = values[i];
                            const row = rows[i];
                            const cells = row.children;
                            const cellsLength = cells.length;
                            const jmin = Math.min(cellsLength, columnValues.length);
                            for (let j = 0; j < jmin; ++j) {
                                const cell = cells[j];
                                const columnValue = columnValues[j];
                                const columnRuntime = columnValue.runtime;
                                if (columnRuntime != null) {
                                    cell.state.isFocusable = true;
                                    cell.text.value = columnRuntime.formatter(columnRuntime.toValue(value, j, values), j);
                                }
                            }
                            for (let j = jmin; j < cellsLength; ++j) {
                                const cell = cells[j];
                                cell.state.isFocusable = false;
                                cell.text.value = "";
                            }
                        }
                        for (let i = imin; i < rowsLength; ++i) {
                            const row = rows[i];
                            const cells = row.children;
                            const cellsLength = cells.length;
                            for (let j = 0; j < cellsLength; ++j) {
                                const cell = cells[j];
                                cell.state.isFocusable = false;
                                cell.text.value = "";
                            }
                        }
                    }
                    else {
                        for (let i = 0; i < rowsLength; ++i) {
                            const row = rows[i];
                            const cells = row.children;
                            const cellsLength = cells.length;
                            for (let j = 0; j < cellsLength; ++j) {
                                const cell = cells[j];
                                cell.state.isFocusable = false;
                                cell.text.value = "";
                            }
                        }
                    }
                }
            }
        }
    }

    class EShapeTableCellActionValueChangeColor extends wcardinalUi.EShapeActionValueChangeColorCode {
        constructor() {
            super(wcardinalUi.EShapeActionValueChangeColorType.FILL, "", EShapeTableCellActionValueChangeColor.getColorCode(), "", "");
        }
        static getColorCode() {
            const activeHoverColor = wcardinalUi.UtilRgb.brighten(wcardinalUi.EShapeDefaults.HIGHLIGHT_COLOR, 0.8);
            const activeColor = wcardinalUi.UtilRgb.brighten(wcardinalUi.EShapeDefaults.HIGHLIGHT_COLOR, 0.75);
            const hoverColor = wcardinalUi.UtilRgb.brighten(wcardinalUi.EShapeDefaults.HIGHLIGHT_COLOR, 0.85);
            const disabledColor = wcardinalUi.UtilRgb.darken(wcardinalUi.EShapeDefaults.FILL_COLOR, 0.25);
            return (`inDisabled ? ${disabledColor} : ( isActive ?` +
                `	( isHovered ? ${activeHoverColor} : ${activeColor} ) :` +
                `	( isHovered ? ${hoverColor} : null )` +
                `)`);
        }
    }

    class EShapeTableBodyRuntime extends wcardinalUi.EShapeRuntimeImpl {
        constructor(shape) {
            super(shape);
            this.lastRowIndex = -1;
            this.lastColumnIndex = -1;
            this.init(shape);
        }
        init(shape) {
            const parent = shape.parent;
            if (parent instanceof EShapeTable) {
                this.selection = parent.row.selection;
                const rows = shape.children;
                for (let i = 0, imax = rows.length; i < imax; ++i) {
                    const row = rows[i];
                    const cells = row.children;
                    for (let j = 0, jmax = cells.length; j < jmax; ++j) {
                        cells[j].action.add(new EShapeTableCellActionValueChangeColor());
                    }
                }
            }
        }
        onClick(shape, e) {
            super.onClick(shape, e);
            // Update the selection
            const selection = this.selection;
            if (e != null && selection != null && selection.type !== EShapeTableRowSelectionType.NONE) {
                const lastRowIndex = this.lastRowIndex;
                if (0 <= lastRowIndex) {
                    const indices = selection.indices;
                    const isSingle = selection.type === EShapeTableRowSelectionType.SINGLE;
                    const isNotSingle = !isSingle;
                    const originalEvent = "data" in e ? e.data.originalEvent : e;
                    const ctrlKey = originalEvent.ctrlKey;
                    const shiftKey = originalEvent.shiftKey;
                    if (isSingle || indices.length <= 0 || !(isNotSingle && (ctrlKey || shiftKey))) {
                        selection.clearAndAdd(lastRowIndex);
                    }
                    else if (ctrlKey) {
                        selection.toggle(lastRowIndex);
                    }
                    else if (shiftKey) {
                        selection.addTo(lastRowIndex);
                    }
                }
            }
        }
        onDblClick(shape, e, interactionManager) {
            const result = super.onDblClick(shape, e, interactionManager);
            // Focus on clicked cell
            const cell = this.getCell(shape, this.lastRowIndex, this.lastColumnIndex);
            if (cell != null) {
                cell.focus();
            }
            return result;
        }
        onOut(shape, e) {
            super.onOut(shape, e);
            // Clear highlight
            const lastRowIndex = this.lastRowIndex;
            if (0 <= lastRowIndex) {
                this.setRowHovered(shape, lastRowIndex, false);
                this.lastRowIndex = -1;
            }
        }
        onCellTouched(shape, rowIndex, columnIndex) {
            let isChanged = false;
            const lastRowTouched = this.lastRowIndex;
            if (lastRowTouched !== rowIndex) {
                this.setRowHovered(shape, lastRowTouched, false);
                this.setRowHovered(shape, rowIndex, true);
                this.lastRowIndex = rowIndex;
                isChanged = true;
            }
            const lastColumnIndex = this.lastColumnIndex;
            if (lastColumnIndex !== columnIndex) {
                this.lastColumnIndex = columnIndex;
                isChanged = true;
            }
            if (isChanged) {
                const cell = this.getCell(shape, rowIndex, columnIndex);
                shape.title = (cell && cell.text.value) || "";
                const layer = wcardinalUi.DApplications.getLayer(shape);
                if (layer) {
                    layer.view.title = shape.title;
                }
            }
        }
        getRow(shape, index) {
            const rows = shape.children;
            if (0 <= index && index < rows.length) {
                return rows[index];
            }
            return null;
        }
        getCell(shape, rowIndex, columnIndex) {
            const row = this.getRow(shape, rowIndex);
            if (row != null) {
                const cells = row.children;
                if (0 <= columnIndex && columnIndex < cells.length) {
                    return cells[columnIndex];
                }
            }
            return null;
        }
        setRowHovered(shape, index, isHovered) {
            const row = this.getRow(shape, index);
            if (row != null) {
                const cells = row.children;
                for (let i = 0, imax = cells.length; i < imax; ++i) {
                    cells[i].state.isHovered = isHovered;
                }
            }
        }
    }
    EShapeTableBodyRuntime.WORK_POINT = new pixi_js.Point();

    class EShapeTableBody extends wcardinalUi.EShapeGroupShadowed {
        constructor(mode, type = EShapeTableIds.BODY_ID) {
            super(mode, type);
        }
        containsAbs(x, y, ax, ay) {
            if (this.containsAbsBBox(x, y, ax, ay)) {
                const children = this.children;
                if (0 < children.length) {
                    const first = children[0];
                    const rowIndex = ((ay + y) / first.size.y) | 0;
                    if (rowIndex < children.length) {
                        const cells = first.children;
                        for (let i = 0, imax = cells.length; i < imax; ++i) {
                            const cell = cells[i];
                            const cx = cell.transform.position.x;
                            const csx = 0.5 * cell.size.x;
                            if (x < cx + csx) {
                                const runtime = this.runtime;
                                if (runtime instanceof EShapeTableBodyRuntime) {
                                    runtime.onCellTouched(this, rowIndex, i);
                                }
                                return true;
                            }
                        }
                        return true;
                    }
                    else {
                        return false;
                    }
                }
            }
            return false;
        }
        containsText(x, y) {
            return null;
        }
        containsChildren(x, y) {
            return null;
        }
    }

    const toValueDefault = (row, index) => row[index];
    const fromValueDefault = (row, index, rows, value) => {
        row[index] = value;
    };
    const formatterDefault = (value) => String(value);
    class EShapeTableColumnValueRuntime {
        constructor(value) {
            this.toValue = this.parseToValue(value.getter, toValueDefault, '""');
            this.fromValue = this.parseFromValue(value.setter, fromValueDefault);
            if (value.type === EShapeTableColumnValueType.TEXT) {
                this.formatter = this.parseFormat(value.format, formatterDefault, '""');
            }
            else {
                const format = value.format;
                if (0 < format.trim().length) {
                    const formatter = wcardinalUi.NumberFormatters.create(format);
                    this.formatter = (v) => {
                        return formatter.format(v, 1);
                    };
                }
                else {
                    this.formatter = formatterDefault;
                }
            }
        }
        parseToValue(expression, def, defLiteral) {
            if (expression.trim().length <= 0) {
                return def;
            }
            try {
                return Function("row", "index", "rows", `try{ return (${expression}); } catch( e ) { return ${defLiteral}; }`);
            }
            catch (_a) {
                return def;
            }
        }
        parseFromValue(expression, def) {
            if (expression.trim().length <= 0) {
                return def;
            }
            try {
                return Function("row", "index", "rows", "value", `try{ ${expression} = value; } catch( e ) {}`);
            }
            catch (_a) {
                return def;
            }
        }
        parseFormat(expression, def, defLiteral) {
            if (expression.trim().length <= 0) {
                return def;
            }
            try {
                return Function("value", "index", `try{ return (${expression}); } catch( e ) { return ${defLiteral}; }`);
            }
            catch (_a) {
                return def;
            }
        }
    }

    class EShapeTableHeaderRuntime extends wcardinalUi.EShapeRuntimeImpl {
    }

    class EShapeTableHeader extends wcardinalUi.EShapeGroupShadowed {
        constructor(mode, type = EShapeTableIds.HEADER_ID) {
            super(mode, type);
        }
    }

    class EShapeTableRuntime extends wcardinalUi.EShapeRuntimeImpl {
        constructor(shape) {
            super(shape);
            if (shape instanceof EShapeTable) {
                // Columns
                const values = shape.column.values;
                for (let i = 0, imax = values.length; i < imax; ++i) {
                    const value = values[i];
                    value.runtime = new EShapeTableColumnValueRuntime(value);
                }
                // Action
                this.actions.push(new EShapeTableActionRuntime(shape));
            }
        }
    }

    class EShapeTables {
        static getTheme() {
            return wcardinalUi.DThemes.get("EShapeTable");
        }
        static create(existing) {
            const mode = wcardinalUi.EShapeResourceManagerDeserializationMode.EDITOR;
            const result = new EShapeTable(mode);
            const header = new EShapeTableHeader(mode).attach(result);
            const headerCell = new wcardinalUi.EShapeRectangle().attach(header);
            headerCell.stroke.side = wcardinalUi.EShapeStrokeSide.BOTTOM;
            headerCell.stroke.width = 1;
            headerCell.stroke.color = wcardinalUi.UtilRgb.brighten(wcardinalUi.EShapeDefaults.STROKE_COLOR, 0.65);
            const body = new EShapeTableBody(mode).attach(result);
            body.state.isFocusable = true;
            body.interactive = true;
            const even = new wcardinalUi.EShapeGroupShadowed(mode).attach(body);
            const odd = new wcardinalUi.EShapeGroupShadowed(mode).attach(body);
            const cellEven = new wcardinalUi.EShapeRectangle().attach(even);
            cellEven.stroke.enable = false;
            cellEven.text.value = "-";
            cellEven.text.clipping = true;
            const cellOdd = new wcardinalUi.EShapeRectangle().attach(odd);
            cellOdd.fill.color = wcardinalUi.UtilRgb.darken(wcardinalUi.EShapeDefaults.FILL_COLOR, 0.05);
            cellOdd.stroke.enable = false;
            cellOdd.text.value = "-";
            cellOdd.text.clipping = true;
            result.column.add(new EShapeTableColumnValue(1, EShapeTableColumnValueType.TEXT, "", "", "", wcardinalUi.EShapeTextAlignHorizontal.CENTER, new EShapeTableColumnValueHeader(this.getTheme().newHeaderLabel()), new EShapeTableColumnValueBody()));
            if (existing) {
                result.copy(existing);
            }
            result.onSizeChange();
            return result;
        }
        static load() {
            const theme = this.getTheme();
            const name = theme.getName();
            EShapeExtensions.add({
                type: EShapeTableIds.ID,
                name,
                icon: {
                    width: 24,
                    height: 24,
                    // Material Icons https://material.io/tools/icons/
                    // Available under Apache license version 2.0
                    svg: `<g transform="scale(26.6666)" fill="#fff" stroke="none">` +
                        `<path d="M20 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h15c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 2v3H5V5h15z` +
                        `m-5 14h-5v-9h5v9zM5 10h3v9H5v-9zm12 9v-9h3v9h-3z"/>` +
                        `</g>`
                },
                title: name,
                creator: (existing) => EShapeTables.create(existing),
                deserializer: (item, manager) => EShapeTables.deserialize(item, manager),
                editor: EEditorShapeTable,
                runtime: EShapeTableRuntime,
                uploaded: wcardinalUi.createGroupUploaded
            });
            EShapeExtensions.add({
                type: EShapeTableIds.HEADER_ID,
                name: theme.getHeaderName(),
                deserializer: (item, manager) => EShapeTables.deserializeHeader(item, manager),
                runtime: EShapeTableHeaderRuntime,
                capability: wcardinalUi.EShapeCapability.PRIMITIVE & ~wcardinalUi.EShapeCapability.CHILDREN
            });
            EShapeExtensions.add({
                type: EShapeTableIds.BODY_ID,
                name: theme.getBodyName(),
                deserializer: (item, manager) => EShapeTables.deserializeBody(item, manager),
                runtime: EShapeTableBodyRuntime,
                capability: wcardinalUi.EShapeCapability.PRIMITIVE & ~wcardinalUi.EShapeCapability.CHILDREN
            });
        }
        static deserialize(item, manager) {
            const shape = new EShapeTable(manager.mode);
            const index = item[15];
            const resources = manager.resources;
            if (0 <= index && index < resources.length) {
                let parsed = manager.getExtension(index);
                if (parsed == null) {
                    parsed = JSON.parse(resources[index]);
                    manager.setExtension(index, parsed);
                }
                shape.column.deserialize(parsed[0], manager);
                shape.row.deserialize(parsed[1], manager);
                item[15] = parsed[parsed.length - 1];
            }
            const result = wcardinalUi.deserializeBase(item, manager, shape);
            shape.size.init();
            return result;
        }
        static deserializeHeader(item, manager) {
            const shape = new EShapeTableHeader(manager.mode);
            const result = wcardinalUi.deserializeBase(item, manager, shape);
            shape.size.init();
            return result;
        }
        static deserializeBody(item, manager) {
            const shape = new EShapeTableBody(manager.mode);
            const result = wcardinalUi.deserializeBase(item, manager, shape);
            shape.size.init();
            return result;
        }
    }

    const loadShapeExtensionTable = () => {
        EShapeTables.load();
    };

    const toIconName = (index) => {
        return `extension_factory_icon_${index}`;
    };
    class EShapeExtensionFactories {
        static add(factory) {
            this._factories.push(factory);
        }
        static each(iteratee) {
            const factories = this._factories;
            for (let i = 0, imax = factories.length; i < imax; ++i) {
                iteratee(factories[i]);
            }
        }
        static merge(iconBuilder) {
            const factories = this._factories;
            for (let i = 0, imax = factories.length; i < imax; ++i) {
                const factory = factories[i];
                const icon = factory.icon;
                iconBuilder.add(toIconName(i), icon.width, icon.height, icon.svg);
            }
        }
        static build(icons) {
            const factories = this._factories;
            for (let i = 0, imax = factories.length; i < imax; ++i) {
                const factory = factories[i];
                factory.icon.texture = icons[toIconName(i)];
            }
        }
    }
    EShapeExtensionFactories._factories = [];

    class EDialogActionKeywordInput extends wcardinalUi.DInputSearch {
        getClipperRect(resolution, point, result) {
            return wcardinalUi.UtilHtmlElement.getClipperRect(null, this, resolution, point, result);
        }
    }

    class EDialogActionKeywordBoard extends wcardinalUi.DBoard {
        constructor(options) {
            super(options);
            this.addChild(new wcardinalUi.DLayoutVertical({
                x: "padding",
                y: "padding",
                width: "padding",
                height: "padding",
                children: [this.input, this.list, this.text]
            }));
            this.onInputChange("");
        }
        // Input
        get input() {
            let result = this._input;
            if (result == null) {
                result = this.newInput();
                this._input = result;
            }
            return result;
        }
        newInput() {
            return new EDialogActionKeywordInput({
                width: "padding",
                on: {
                    input: (value) => {
                        this.onInputChange(value);
                    }
                }
            });
        }
        onInputChange(word) {
            this.list.data.clearAndAddAll(this.newKeywords(word));
        }
        newKeywords(word) {
            var _a;
            const keywords = ((_a = this._keywords) !== null && _a !== void 0 ? _a : (this._keywords = wcardinalUi.DThemes.get("EDialogAction").newKeywords()));
            if (0 < word.trim().length) {
                const filtered = [];
                for (let i = 0, imax = keywords.length; i < imax; ++i) {
                    const keyword = keywords[i];
                    if (0 <= keyword.keyword.indexOf(word)) {
                        filtered.push(keyword);
                    }
                }
                return filtered;
            }
            else {
                return keywords;
            }
        }
        // List
        get list() {
            let result = this._list;
            if (result == null) {
                result = this.newList();
                this._list = result;
            }
            return result;
        }
        newList() {
            return new wcardinalUi.DList({
                weight: 1,
                width: "padding",
                data: {
                    selection: {
                        on: {
                            change: () => {
                                this.onListSelectionChange();
                            }
                        }
                    },
                    toLabel: (keyword) => {
                        return keyword.keyword;
                    },
                    toId: (keyword) => {
                        return keyword.keyword;
                    }
                }
            });
        }
        onListSelectionChange() {
            const first = this.list.data.selection.first;
            if (first) {
                this.text.text = `${first.keyword}: ${first.type}\n${first.description}`;
            }
            else {
                this.text.text = "";
            }
        }
        // Text
        get text() {
            let result = this._text;
            if (result == null) {
                result = this.newText();
                this._text = result;
            }
            return result;
        }
        newText() {
            return new wcardinalUi.DText({
                width: "padding",
                height: 120,
                state: "READ_ONLY",
                text: {
                    style: {
                        wordWrap: "NORMAL"
                    }
                },
                theme: "DInputTextArea"
            });
        }
        getType() {
            return "DDialog";
        }
    }

    class EDialogAction extends wcardinalUi.DDialogLayered {
        newContentChildren(theme, options) {
            const result = super.newContentChildren(theme, options);
            result.push(this.selectLayout, this.showHideTypeLayout, this.blinkTypeLayout, this.transformTypeLayout, this.changeColorTypeLayout, this.changeColorTargetLayout, this.rotateTypeLayout, this.resizeTypeLayout, this.originXLayout, this.originYLayout, this.moveTypeLayout, this.openTypeLayout, this.openDialogTypeLayout, this.changeTextTypeLayout, this.miscTypeLayout, this.onInputActionLayout, this.whenTypeLayout, this.gestureTypeLayout, this.gestureOperationTypeLayout, this.selectLayerLayout, this.condition, this.intervalLayout, this.size, this.amount, this.targetName, this.colorLayout, this.target, this.argument, this.contents, this.initialization, this.pointerEventsLayout, this.colorCode, this.alphaCode, this.brightness, this.blend, this.initial, this.step, this.min, this.max, this.scaleLayout, this.checkBringToFrontLayout, this.inNewWindowLayout);
            const onChangeBound = () => {
                this.onChange();
            };
            this.select.on("change", onChangeBound);
            this.showHideType.on("change", onChangeBound);
            this.blinkType.on("change", onChangeBound);
            this.transformType.on("change", onChangeBound);
            this.resizeType.on("change", onChangeBound);
            this.changeColorTarget.on("change", onChangeBound);
            this.openType.on("change", onChangeBound);
            this.openDialogType.on("change", onChangeBound);
            this.miscType.on("change", onChangeBound);
            return result;
        }
        newLabel(label) {
            return new wcardinalUi.DInputLabel({
                width: 60,
                text: {
                    value: label
                }
            });
        }
        newSpace() {
            return new wcardinalUi.DLayoutSpace({
                width: 60
            });
        }
        newLabeled(label, input) {
            return new wcardinalUi.DLayoutHorizontal({
                width: "padding",
                height: "auto",
                children: [
                    label != null ? this.newLabel(label) : this.newSpace(),
                    input,
                    this.newSpace()
                ]
            });
        }
        // Theme
        get themeShape() {
            var _a;
            return ((_a = this._themeShape) !== null && _a !== void 0 ? _a : (this._themeShape = this.newThemeShape()));
        }
        newThemeShape() {
            return wcardinalUi.DThemes.get("EShapeActionValue");
        }
        // Select
        get select() {
            var _a;
            return ((_a = this._select) !== null && _a !== void 0 ? _a : (this._select = this.newSelect()));
        }
        newSelect() {
            return new wcardinalUi.DSelect({
                weight: 1,
                value: wcardinalUi.EShapeActionValueType.SHOW_HIDE,
                menu: {
                    items: this.newSelectMenuItems()
                }
            });
        }
        newSelectMenuItems() {
            const themeShape = this.themeShape;
            const result = [
                {
                    value: wcardinalUi.EShapeActionValueType.SHOW_HIDE,
                    text: {
                        value: themeShape.toTypeLabel(wcardinalUi.EShapeActionValueType.SHOW_HIDE)
                    }
                },
                {
                    value: wcardinalUi.EShapeActionValueType.BLINK,
                    text: {
                        value: themeShape.toTypeLabel(wcardinalUi.EShapeActionValueType.BLINK)
                    }
                },
                {
                    value: wcardinalUi.EShapeActionValueType.TRANSFORM,
                    text: {
                        value: themeShape.toTypeLabel(wcardinalUi.EShapeActionValueType.TRANSFORM)
                    }
                },
                {
                    value: wcardinalUi.EShapeActionValueType.CHANGE_COLOR,
                    text: {
                        value: themeShape.toTypeLabel(wcardinalUi.EShapeActionValueType.CHANGE_COLOR)
                    }
                },
                {
                    value: wcardinalUi.EShapeActionValueType.CHANGE_TEXT,
                    text: {
                        value: themeShape.toTypeLabel(wcardinalUi.EShapeActionValueType.CHANGE_TEXT)
                    }
                },
                {
                    value: wcardinalUi.EShapeActionValueType.CHANGE_CURSOR,
                    text: {
                        value: themeShape.toTypeLabel(wcardinalUi.EShapeActionValueType.CHANGE_CURSOR)
                    }
                },
                {
                    value: wcardinalUi.EShapeActionValueType.OPEN,
                    text: {
                        value: themeShape.toTypeLabel(wcardinalUi.EShapeActionValueType.OPEN)
                    }
                },
                {
                    value: wcardinalUi.EShapeActionValueType.GESTURE,
                    text: {
                        value: themeShape.toTypeLabel(wcardinalUi.EShapeActionValueType.GESTURE)
                    }
                },
                {
                    value: wcardinalUi.EShapeActionValueType.MISC,
                    text: {
                        value: themeShape.toTypeLabel(wcardinalUi.EShapeActionValueType.MISC)
                    }
                }
            ];
            EShapeActionExtensions.each((extension) => {
                result.push({
                    value: extension.type,
                    text: {
                        value: extension.label
                    }
                });
            });
            return result;
        }
        get selectLayout() {
            var _a;
            return ((_a = this._selectLayout) !== null && _a !== void 0 ? _a : (this._selectLayout = this.newSelectLayout()));
        }
        newSelectLayout() {
            return new wcardinalUi.DLayoutHorizontal({
                width: "padding",
                height: "auto",
                children: [
                    this.newLabel(this.theme.getSelectActionLabel()),
                    this.select,
                    new wcardinalUi.DLayoutHorizontal({
                        width: 60,
                        height: "auto",
                        children: [
                            new wcardinalUi.DLayoutSpace({
                                weight: 1
                            }),
                            this.buttonKeyword
                        ]
                    })
                ]
            });
        }
        // Keyword button
        get buttonKeyword() {
            var _a;
            return ((_a = this._buttonKeyword) !== null && _a !== void 0 ? _a : (this._buttonKeyword = this.newButtonKeyword()));
        }
        newButtonKeyword() {
            var _a;
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                toggle: true,
                image: {
                    source: (_a = this.options) === null || _a === void 0 ? void 0 : _a.icons.action_keyword
                },
                title: this.theme.getButtonKeywordTitle(),
                on: {
                    active: () => {
                        this.onButtonKeywordActive();
                    },
                    inactive: () => {
                        this.onButtonKeywordInactive();
                    }
                }
            });
        }
        onButtonKeywordActive() {
            const boardKeyword = this.boardKeyword;
            const offset = this.getBoardKeywordOffset();
            const width = this.width;
            const layer = wcardinalUi.DApplications.getLayer(this);
            if (layer != null) {
                const boardKeywordWidth = boardKeyword.width;
                if (layer.width < this.position.x + width + offset + boardKeywordWidth) {
                    boardKeyword.position.x = -boardKeywordWidth - offset;
                }
                else {
                    boardKeyword.position.x = width + offset;
                }
            }
            else {
                boardKeyword.position.x = width + offset;
            }
            boardKeyword.show();
        }
        onButtonKeywordInactive() {
            this.boardKeyword.hide();
        }
        // Keyword board
        get boardKeyword() {
            var _a;
            return ((_a = this._boardKeyword) !== null && _a !== void 0 ? _a : (this._boardKeyword = this.newBoardKeyword()));
        }
        newBoardKeyword() {
            // To exclude this board from the automatic height calculation targets,
            // The width and the height must be functions.
            return new EDialogActionKeywordBoard({
                parent: this,
                x: 0,
                y: 0,
                width: () => 300,
                height: () => 400,
                padding: 16
            });
        }
        getBoardKeywordOffset() {
            return 16;
        }
        // Select show / hide type
        get showHideType() {
            var _a;
            return ((_a = this._showHideType) !== null && _a !== void 0 ? _a : (this._showHideType = this.newShowHideType()));
        }
        newShowHideType() {
            const themeShape = this.themeShape;
            return new wcardinalUi.DSelect({
                weight: 1,
                value: wcardinalUi.EShapeActionValueShowHideType.SHAPE,
                menu: {
                    items: [
                        {
                            value: wcardinalUi.EShapeActionValueShowHideType.SHAPE,
                            text: {
                                value: themeShape.toShowHideTypeLabel(wcardinalUi.EShapeActionValueShowHideType.SHAPE)
                            }
                        },
                        {
                            value: wcardinalUi.EShapeActionValueShowHideType.LAYER,
                            text: {
                                value: themeShape.toShowHideTypeLabel(wcardinalUi.EShapeActionValueShowHideType.LAYER)
                            }
                        }
                    ]
                }
            });
        }
        get showHideTypeLayout() {
            var _a;
            return ((_a = this._showHideTypeLayout) !== null && _a !== void 0 ? _a : (this._showHideTypeLayout = this.newLabeled(null, this.showHideType)));
        }
        onChangeShowHideTypeLayout(select) {
            const showHideTypeLayout = this.showHideTypeLayout;
            if (select === wcardinalUi.EShapeActionValueType.SHOW_HIDE) {
                showHideTypeLayout.show();
            }
            else {
                showHideTypeLayout.hide();
            }
        }
        // Select blink type
        get blinkType() {
            var _a;
            return ((_a = this._blinkType) !== null && _a !== void 0 ? _a : (this._blinkType = this.newBlinkType()));
        }
        newBlinkType() {
            const themeShape = this.themeShape;
            return new wcardinalUi.DSelect({
                weight: 1,
                value: wcardinalUi.EShapeActionValueBlinkType.VISIBILITY,
                menu: {
                    items: [
                        {
                            value: wcardinalUi.EShapeActionValueBlinkType.VISIBILITY,
                            text: {
                                value: themeShape.toBlinkTypeLabel(wcardinalUi.EShapeActionValueBlinkType.VISIBILITY)
                            }
                        },
                        {
                            value: wcardinalUi.EShapeActionValueBlinkType.BRIGHTEN,
                            text: {
                                value: themeShape.toBlinkTypeLabel(wcardinalUi.EShapeActionValueBlinkType.BRIGHTEN)
                            }
                        },
                        {
                            value: wcardinalUi.EShapeActionValueBlinkType.DARKEN,
                            text: {
                                value: themeShape.toBlinkTypeLabel(wcardinalUi.EShapeActionValueBlinkType.DARKEN)
                            }
                        },
                        {
                            value: wcardinalUi.EShapeActionValueBlinkType.OPACITY,
                            text: {
                                value: themeShape.toBlinkTypeLabel(wcardinalUi.EShapeActionValueBlinkType.OPACITY)
                            }
                        },
                        {
                            value: wcardinalUi.EShapeActionValueBlinkType.COLOR_FILL,
                            text: {
                                value: themeShape.toBlinkTypeLabel(wcardinalUi.EShapeActionValueBlinkType.COLOR_FILL)
                            }
                        },
                        {
                            value: wcardinalUi.EShapeActionValueBlinkType.COLOR_STROKE,
                            text: {
                                value: themeShape.toBlinkTypeLabel(wcardinalUi.EShapeActionValueBlinkType.COLOR_STROKE)
                            }
                        }
                    ]
                }
            });
        }
        get blinkTypeLayout() {
            var _a;
            return ((_a = this._blinkTypeLayout) !== null && _a !== void 0 ? _a : (this._blinkTypeLayout = this.newLabeled(null, this.blinkType)));
        }
        onChangeBlinkTypeLayout(select) {
            const blinkTypeLayout = this.blinkTypeLayout;
            if (select === wcardinalUi.EShapeActionValueType.BLINK) {
                blinkTypeLayout.show();
            }
            else {
                blinkTypeLayout.hide();
            }
        }
        // Transform type
        get transformType() {
            var _a;
            return ((_a = this._transformType) !== null && _a !== void 0 ? _a : (this._transformType = this.newTransformType()));
        }
        newTransformType() {
            const themeShape = this.themeShape;
            return new wcardinalUi.DSelect({
                weight: 1,
                value: wcardinalUi.EShapeActionValueTransformType.MOVE,
                menu: {
                    items: [
                        {
                            value: wcardinalUi.EShapeActionValueTransformType.MOVE,
                            text: {
                                value: themeShape.toTransformTypeLabel(wcardinalUi.EShapeActionValueTransformType.MOVE)
                            }
                        },
                        {
                            value: wcardinalUi.EShapeActionValueTransformType.ROTATE,
                            text: {
                                value: themeShape.toTransformTypeLabel(wcardinalUi.EShapeActionValueTransformType.ROTATE)
                            }
                        },
                        {
                            value: wcardinalUi.EShapeActionValueTransformType.RESIZE,
                            text: {
                                value: themeShape.toTransformTypeLabel(wcardinalUi.EShapeActionValueTransformType.RESIZE)
                            }
                        }
                    ]
                }
            });
        }
        get transformTypeLayout() {
            var _a;
            return ((_a = this._transformTypeLayout) !== null && _a !== void 0 ? _a : (this._transformTypeLayout = this.newLabeled(null, this.transformType)));
        }
        onChangeTransformTypeLayout(select) {
            const transformTypeLayout = this.transformTypeLayout;
            if (select === wcardinalUi.EShapeActionValueType.TRANSFORM) {
                transformTypeLayout.show();
            }
            else {
                transformTypeLayout.hide();
            }
        }
        // Select color type
        get changeColorType() {
            var _a;
            return ((_a = this._changeColorType) !== null && _a !== void 0 ? _a : (this._changeColorType = this.newChangeColorType()));
        }
        newChangeColorType() {
            const themeShape = this.themeShape;
            return new wcardinalUi.DSelectMultiple({
                weight: 1,
                values: [wcardinalUi.EShapeActionValueChangeColorType.FILL],
                menu: {
                    items: [
                        {
                            value: wcardinalUi.EShapeActionValueChangeColorType.FILL,
                            text: {
                                value: themeShape.toChangeColorTypeLabel(wcardinalUi.EShapeActionValueChangeColorType.FILL)
                            },
                            check: true
                        },
                        {
                            value: wcardinalUi.EShapeActionValueChangeColorType.STROKE,
                            text: {
                                value: themeShape.toChangeColorTypeLabel(wcardinalUi.EShapeActionValueChangeColorType.STROKE)
                            },
                            check: true
                        },
                        {
                            value: wcardinalUi.EShapeActionValueChangeColorType.TEXT,
                            text: {
                                value: themeShape.toChangeColorTypeLabel(wcardinalUi.EShapeActionValueChangeColorType.TEXT)
                            },
                            check: true
                        },
                        {
                            value: wcardinalUi.EShapeActionValueChangeColorType.TEXT_OUTLINE,
                            text: {
                                value: themeShape.toChangeColorTypeLabel(wcardinalUi.EShapeActionValueChangeColorType.TEXT_OUTLINE)
                            },
                            check: true
                        }
                    ]
                }
            });
        }
        get changeColorTypeLayout() {
            var _a;
            return ((_a = this._changeColorTypeLayout) !== null && _a !== void 0 ? _a : (this._changeColorTypeLayout = this.newLabeled(null, this.changeColorType)));
        }
        onChangeChangeColorTypeLayout(select) {
            const changeColorTypeLayout = this.changeColorTypeLayout;
            if (select === wcardinalUi.EShapeActionValueType.CHANGE_COLOR) {
                changeColorTypeLayout.show();
            }
            else {
                changeColorTypeLayout.hide();
            }
        }
        // Select color target
        get changeColorTarget() {
            var _a;
            return ((_a = this._changeColorTarget) !== null && _a !== void 0 ? _a : (this._changeColorTarget = this.newChangeColorTarget()));
        }
        newChangeColorTarget() {
            const themeShape = this.themeShape;
            return new wcardinalUi.DSelect({
                weight: 1,
                value: wcardinalUi.EShapeActionValueChangeColorTarget.COLOR_AND_ALPHA,
                menu: {
                    items: [
                        {
                            value: wcardinalUi.EShapeActionValueChangeColorTarget.COLOR_AND_ALPHA,
                            text: {
                                value: themeShape.toChangeColorTargetLabel(wcardinalUi.EShapeActionValueChangeColorTarget.COLOR_AND_ALPHA)
                            }
                        },
                        {
                            value: wcardinalUi.EShapeActionValueChangeColorTarget.COLOR,
                            text: {
                                value: themeShape.toChangeColorTargetLabel(wcardinalUi.EShapeActionValueChangeColorTarget.COLOR)
                            }
                        },
                        {
                            value: wcardinalUi.EShapeActionValueChangeColorTarget.ALPHA,
                            text: {
                                value: themeShape.toChangeColorTargetLabel(wcardinalUi.EShapeActionValueChangeColorTarget.ALPHA)
                            }
                        },
                        {
                            value: wcardinalUi.EShapeActionValueChangeColorTarget.CODE,
                            text: {
                                value: themeShape.toChangeColorTargetLabel(wcardinalUi.EShapeActionValueChangeColorTarget.CODE)
                            }
                        },
                        {
                            value: wcardinalUi.EShapeActionValueChangeColorTarget.BRIGHTNESS,
                            text: {
                                value: themeShape.toChangeColorTargetLabel(wcardinalUi.EShapeActionValueChangeColorTarget.BRIGHTNESS)
                            }
                        }
                    ]
                }
            });
        }
        get changeColorTargetLayout() {
            var _a;
            return ((_a = this._changeColorTargetLayout) !== null && _a !== void 0 ? _a : (this._changeColorTargetLayout = this.newLabeled(null, this.changeColorTarget)));
        }
        onChangeChangeColorTargetLayout(select) {
            const changeColorTargetLayout = this.changeColorTargetLayout;
            if (select === wcardinalUi.EShapeActionValueType.CHANGE_COLOR) {
                changeColorTargetLayout.show();
            }
            else {
                changeColorTargetLayout.hide();
            }
        }
        // Select rotate type
        get rotateType() {
            var _a;
            return ((_a = this._rotateType) !== null && _a !== void 0 ? _a : (this._rotateType = this.newRotateType()));
        }
        newRotateType() {
            const themeShape = this.themeShape;
            return new wcardinalUi.DSelect({
                weight: 1,
                value: wcardinalUi.EShapeActionValueTransformRotateType.RELATIVE,
                menu: {
                    items: [
                        {
                            value: wcardinalUi.EShapeActionValueTransformRotateType.RELATIVE,
                            text: {
                                value: themeShape.toTransformRotateTypeLabel(wcardinalUi.EShapeActionValueTransformRotateType.RELATIVE)
                            }
                        },
                        {
                            value: wcardinalUi.EShapeActionValueTransformRotateType.ABSOLUTE,
                            text: {
                                value: themeShape.toTransformRotateTypeLabel(wcardinalUi.EShapeActionValueTransformRotateType.ABSOLUTE)
                            }
                        }
                    ]
                }
            });
        }
        get rotateTypeLayout() {
            var _a;
            return ((_a = this._rotateTypeLayout) !== null && _a !== void 0 ? _a : (this._rotateTypeLayout = this.newLabeled(null, this.rotateType)));
        }
        onChangeRotateTypeLayout(select) {
            const rotateTypeLayout = this.rotateTypeLayout;
            if (select === wcardinalUi.EShapeActionValueType.TRANSFORM) {
                if (this.transformType.value === wcardinalUi.EShapeActionValueTransformType.ROTATE) {
                    rotateTypeLayout.show();
                }
                else {
                    rotateTypeLayout.hide();
                }
            }
            else {
                rotateTypeLayout.hide();
            }
        }
        // Select resize type
        get resizeType() {
            var _a;
            return ((_a = this._resizeType) !== null && _a !== void 0 ? _a : (this._resizeType = this.newResizeType()));
        }
        newResizeType() {
            const themeShape = this.themeShape;
            return new wcardinalUi.DSelect({
                weight: 1,
                value: wcardinalUi.EShapeActionValueTransformResizeType.RELATIVE_SIZE,
                menu: {
                    items: [
                        {
                            value: wcardinalUi.EShapeActionValueTransformResizeType.ABSOLUTE_SIZE,
                            text: {
                                value: themeShape.toTransformResizeTypeLabel(wcardinalUi.EShapeActionValueTransformResizeType.ABSOLUTE_SIZE)
                            }
                        },
                        {
                            value: wcardinalUi.EShapeActionValueTransformResizeType.RELATIVE_SIZE,
                            text: {
                                value: themeShape.toTransformResizeTypeLabel(wcardinalUi.EShapeActionValueTransformResizeType.RELATIVE_SIZE)
                            }
                        },
                        {
                            value: wcardinalUi.EShapeActionValueTransformResizeType.ABSOLUTE_HEIGHT,
                            text: {
                                value: themeShape.toTransformResizeTypeLabel(wcardinalUi.EShapeActionValueTransformResizeType.ABSOLUTE_HEIGHT)
                            }
                        },
                        {
                            value: wcardinalUi.EShapeActionValueTransformResizeType.RELATIVE_HEIGHT,
                            text: {
                                value: themeShape.toTransformResizeTypeLabel(wcardinalUi.EShapeActionValueTransformResizeType.RELATIVE_HEIGHT)
                            }
                        },
                        {
                            value: wcardinalUi.EShapeActionValueTransformResizeType.ABSOLUTE_WIDTH,
                            text: {
                                value: themeShape.toTransformResizeTypeLabel(wcardinalUi.EShapeActionValueTransformResizeType.ABSOLUTE_WIDTH)
                            }
                        },
                        {
                            value: wcardinalUi.EShapeActionValueTransformResizeType.RELATIVE_WIDTH,
                            text: {
                                value: themeShape.toTransformResizeTypeLabel(wcardinalUi.EShapeActionValueTransformResizeType.RELATIVE_WIDTH)
                            }
                        }
                    ]
                }
            });
        }
        get resizeTypeLayout() {
            var _a;
            return ((_a = this._resizeTypeLayout) !== null && _a !== void 0 ? _a : (this._resizeTypeLayout = this.newLabeled(null, this.resizeType)));
        }
        onChangeResizeTypeLayout(select) {
            const resizeTypeLayout = this.resizeTypeLayout;
            if (select === wcardinalUi.EShapeActionValueType.TRANSFORM) {
                if (this.transformType.value === wcardinalUi.EShapeActionValueTransformType.RESIZE) {
                    resizeTypeLayout.show();
                }
                else {
                    resizeTypeLayout.hide();
                }
            }
            else {
                resizeTypeLayout.hide();
            }
        }
        // X Origin
        get originX() {
            var _a;
            return ((_a = this._originX) !== null && _a !== void 0 ? _a : (this._originX = this.newOriginX()));
        }
        newOriginX() {
            return new wcardinalUi.DInputReal({
                weight: 1,
                text: {
                    value: 0.5
                },
                step: 0.1,
                on: {
                    enter: () => {
                        this.ok();
                    }
                }
            });
        }
        get originXLayout() {
            var _a;
            return ((_a = this._originXLayout) !== null && _a !== void 0 ? _a : (this._originXLayout = this.newLabeled(this.theme.getInputOriginXLabel(), this.originX)));
        }
        onChangeOriginXLayout(select) {
            const originXLayout = this.originXLayout;
            if (select === wcardinalUi.EShapeActionValueType.TRANSFORM) {
                const transformType = this.transformType.value;
                if (transformType === wcardinalUi.EShapeActionValueTransformType.RESIZE) {
                    const resizeType = this.resizeType.value;
                    if (resizeType === wcardinalUi.EShapeActionValueTransformResizeType.ABSOLUTE_SIZE ||
                        resizeType === wcardinalUi.EShapeActionValueTransformResizeType.RELATIVE_SIZE ||
                        resizeType === wcardinalUi.EShapeActionValueTransformResizeType.ABSOLUTE_WIDTH ||
                        resizeType === wcardinalUi.EShapeActionValueTransformResizeType.RELATIVE_WIDTH) {
                        originXLayout.show();
                    }
                    else {
                        originXLayout.hide();
                    }
                }
                else if (transformType === wcardinalUi.EShapeActionValueTransformType.ROTATE) {
                    originXLayout.show();
                }
                else {
                    originXLayout.hide();
                }
            }
            else {
                originXLayout.hide();
            }
        }
        // Y Origin
        get originY() {
            var _a;
            return ((_a = this._originY) !== null && _a !== void 0 ? _a : (this._originY = this.newOriginY()));
        }
        newOriginY() {
            return new wcardinalUi.DInputReal({
                weight: 1,
                text: {
                    value: 0.5
                },
                step: 0.1,
                on: {
                    enter: () => {
                        this.ok();
                    }
                }
            });
        }
        get originYLayout() {
            var _a;
            return ((_a = this._originYLayout) !== null && _a !== void 0 ? _a : (this._originYLayout = this.newLabeled(this.theme.getInputOriginYLabel(), this.originY)));
        }
        onChangeOriginYLayout(select) {
            const originYLayout = this.originYLayout;
            if (select === wcardinalUi.EShapeActionValueType.TRANSFORM) {
                const transformType = this.transformType.value;
                if (transformType === wcardinalUi.EShapeActionValueTransformType.RESIZE) {
                    const resizeType = this.resizeType.value;
                    if (resizeType === wcardinalUi.EShapeActionValueTransformResizeType.ABSOLUTE_SIZE ||
                        resizeType === wcardinalUi.EShapeActionValueTransformResizeType.RELATIVE_SIZE ||
                        resizeType === wcardinalUi.EShapeActionValueTransformResizeType.ABSOLUTE_HEIGHT ||
                        resizeType === wcardinalUi.EShapeActionValueTransformResizeType.RELATIVE_HEIGHT) {
                        originYLayout.show();
                    }
                    else {
                        originYLayout.hide();
                    }
                }
                else if (transformType === wcardinalUi.EShapeActionValueTransformType.ROTATE) {
                    originYLayout.show();
                }
                else {
                    originYLayout.hide();
                }
            }
            else {
                originYLayout.hide();
            }
        }
        // Select move type
        get moveType() {
            var _a;
            return ((_a = this._moveType) !== null && _a !== void 0 ? _a : (this._moveType = this.newMoveType()));
        }
        newMoveType() {
            const themeShape = this.themeShape;
            return new wcardinalUi.DSelect({
                weight: 1,
                value: wcardinalUi.EShapeActionValueTransformMoveType.RELATIVE_X,
                menu: {
                    items: [
                        {
                            value: wcardinalUi.EShapeActionValueTransformMoveType.RELATIVE_X,
                            text: {
                                value: themeShape.toTransformMoveTypeLabel(wcardinalUi.EShapeActionValueTransformMoveType.RELATIVE_X)
                            }
                        },
                        {
                            value: wcardinalUi.EShapeActionValueTransformMoveType.RELATIVE_Y,
                            text: {
                                value: themeShape.toTransformMoveTypeLabel(wcardinalUi.EShapeActionValueTransformMoveType.RELATIVE_Y)
                            }
                        },
                        {
                            value: wcardinalUi.EShapeActionValueTransformMoveType.ABSOLUTE_X,
                            text: {
                                value: themeShape.toTransformMoveTypeLabel(wcardinalUi.EShapeActionValueTransformMoveType.ABSOLUTE_X)
                            }
                        },
                        {
                            value: wcardinalUi.EShapeActionValueTransformMoveType.ABSOLUTE_Y,
                            text: {
                                value: themeShape.toTransformMoveTypeLabel(wcardinalUi.EShapeActionValueTransformMoveType.ABSOLUTE_Y)
                            }
                        },
                        {
                            value: wcardinalUi.EShapeActionValueTransformMoveType.FORWARD_OR_BACKWARD,
                            text: {
                                value: themeShape.toTransformMoveTypeLabel(wcardinalUi.EShapeActionValueTransformMoveType.FORWARD_OR_BACKWARD)
                            }
                        },
                        {
                            value: wcardinalUi.EShapeActionValueTransformMoveType.LEFT_OR_RIGHT,
                            text: {
                                value: themeShape.toTransformMoveTypeLabel(wcardinalUi.EShapeActionValueTransformMoveType.LEFT_OR_RIGHT)
                            }
                        }
                    ]
                }
            });
        }
        get moveTypeLayout() {
            var _a;
            return ((_a = this._moveTypeLayout) !== null && _a !== void 0 ? _a : (this._moveTypeLayout = this.newLabeled(null, this.moveType)));
        }
        onChangeMoveTypeLayout(select) {
            const moveTypeLayout = this.moveTypeLayout;
            if (select === wcardinalUi.EShapeActionValueType.TRANSFORM) {
                if (this.transformType.value === wcardinalUi.EShapeActionValueTransformType.MOVE) {
                    moveTypeLayout.show();
                }
                else {
                    moveTypeLayout.hide();
                }
            }
            else {
                moveTypeLayout.hide();
            }
        }
        // Select open type
        get openType() {
            var _a;
            return ((_a = this._openType) !== null && _a !== void 0 ? _a : (this._openType = this.newOpenType()));
        }
        newOpenType() {
            return new wcardinalUi.DSelect({
                weight: 1,
                value: wcardinalUi.EShapeActionValueOpenType.DIAGRAM,
                menu: {
                    items: this.newOpenTypeMenuItems()
                }
            });
        }
        newOpenTypeMenuItems() {
            const themeShape = this.themeShape;
            const result = [
                {
                    value: wcardinalUi.EShapeActionValueOpenType.DIAGRAM,
                    text: {
                        value: themeShape.toOpenTypeLabel(wcardinalUi.EShapeActionValueOpenType.DIAGRAM)
                    }
                },
                {
                    value: wcardinalUi.EShapeActionValueOpenType.PAGE,
                    text: {
                        value: themeShape.toOpenTypeLabel(wcardinalUi.EShapeActionValueOpenType.PAGE)
                    }
                },
                {
                    value: wcardinalUi.EShapeActionValueOpenType.DIALOG,
                    text: {
                        value: themeShape.toOpenTypeLabel(wcardinalUi.EShapeActionValueOpenType.DIALOG)
                    }
                }
            ];
            wcardinalUi.EShapeActionOpenExtensions.each((extension) => {
                result.push({
                    value: extension.type,
                    text: {
                        value: extension.label
                    }
                });
            });
            return result;
        }
        get openTypeLayout() {
            var _a;
            return ((_a = this._openTypeLayout) !== null && _a !== void 0 ? _a : (this._openTypeLayout = this.newLabeled(null, this.openType)));
        }
        onChangeOpenTypeLayout(select) {
            const openTypeLayout = this.openTypeLayout;
            if (select === wcardinalUi.EShapeActionValueType.OPEN) {
                openTypeLayout.show();
            }
            else {
                openTypeLayout.hide();
            }
        }
        // Select open dialog type
        get openDialogType() {
            var _a;
            return ((_a = this._openDialogType) !== null && _a !== void 0 ? _a : (this._openDialogType = this.newOpenDialogType()));
        }
        newOpenDialogType() {
            return new wcardinalUi.DSelect({
                weight: 1,
                value: wcardinalUi.EShapeActionValueOpenDialogType.TEXT,
                menu: {
                    items: this.newOpenDialogTypeMenuItems()
                }
            });
        }
        newOpenDialogTypeMenuItems() {
            const themeShape = this.themeShape;
            const result = [
                {
                    value: wcardinalUi.EShapeActionValueOpenDialogType.TEXT,
                    text: {
                        value: themeShape.toOpenDialogTypeLabel(wcardinalUi.EShapeActionValueOpenDialogType.TEXT)
                    }
                },
                {
                    value: wcardinalUi.EShapeActionValueOpenDialogType.INTEGER,
                    text: {
                        value: themeShape.toOpenDialogTypeLabel(wcardinalUi.EShapeActionValueOpenDialogType.INTEGER)
                    }
                },
                {
                    value: wcardinalUi.EShapeActionValueOpenDialogType.REAL,
                    text: {
                        value: themeShape.toOpenDialogTypeLabel(wcardinalUi.EShapeActionValueOpenDialogType.REAL)
                    }
                },
                {
                    value: wcardinalUi.EShapeActionValueOpenDialogType.BOOLEAN,
                    text: {
                        value: themeShape.toOpenDialogTypeLabel(wcardinalUi.EShapeActionValueOpenDialogType.BOOLEAN)
                    }
                },
                {
                    value: wcardinalUi.EShapeActionValueOpenDialogType.DATE,
                    text: {
                        value: themeShape.toOpenDialogTypeLabel(wcardinalUi.EShapeActionValueOpenDialogType.DATE)
                    }
                },
                {
                    value: wcardinalUi.EShapeActionValueOpenDialogType.TIME,
                    text: {
                        value: themeShape.toOpenDialogTypeLabel(wcardinalUi.EShapeActionValueOpenDialogType.TIME)
                    }
                },
                {
                    value: wcardinalUi.EShapeActionValueOpenDialogType.DATETIME,
                    text: {
                        value: themeShape.toOpenDialogTypeLabel(wcardinalUi.EShapeActionValueOpenDialogType.DATETIME)
                    }
                }
            ];
            wcardinalUi.EShapeActionOpenDialogExtensions.each((extension) => {
                result.push({
                    value: extension.type,
                    text: {
                        value: extension.label
                    }
                });
            });
            return result;
        }
        get openDialogTypeLayout() {
            var _a;
            return ((_a = this._openDialogTypeLayout) !== null && _a !== void 0 ? _a : (this._openDialogTypeLayout = this.newLabeled(null, this.openDialogType)));
        }
        onChangeOpenDialogTypeLayout(select) {
            const openDialogTypeLayout = this.openDialogTypeLayout;
            if (select === wcardinalUi.EShapeActionValueType.OPEN) {
                if (this.openType.value === wcardinalUi.EShapeActionValueOpenType.DIALOG) {
                    openDialogTypeLayout.show();
                }
                else {
                    openDialogTypeLayout.hide();
                }
            }
            else {
                openDialogTypeLayout.hide();
            }
        }
        // Select change text type
        get changeTextType() {
            var _a;
            return ((_a = this._changeTextType) !== null && _a !== void 0 ? _a : (this._changeTextType = this.newChangeTextType()));
        }
        newChangeTextType() {
            const themeShape = this.themeShape;
            return new wcardinalUi.DSelect({
                weight: 1,
                value: wcardinalUi.EShapeActionValueChangeTextType.TEXT,
                menu: {
                    items: [
                        {
                            value: wcardinalUi.EShapeActionValueChangeTextType.TEXT,
                            text: {
                                value: themeShape.toChangeTextTypeLabel(wcardinalUi.EShapeActionValueChangeTextType.TEXT)
                            }
                        },
                        {
                            value: wcardinalUi.EShapeActionValueChangeTextType.NUMBER,
                            text: {
                                value: themeShape.toChangeTextTypeLabel(wcardinalUi.EShapeActionValueChangeTextType.NUMBER)
                            }
                        }
                    ]
                }
            });
        }
        get changeTextTypeLayout() {
            var _a;
            return ((_a = this._changeTextTypeLayout) !== null && _a !== void 0 ? _a : (this._changeTextTypeLayout = this.newLabeled(null, this.changeTextType)));
        }
        onChangeChangeTextTypeLayout(select) {
            const changeTextTypeLayout = this.changeTextTypeLayout;
            if (select === wcardinalUi.EShapeActionValueType.CHANGE_TEXT) {
                changeTextTypeLayout.show();
            }
            else {
                changeTextTypeLayout.hide();
            }
        }
        // Select misc. type
        get miscType() {
            var _a;
            return ((_a = this._miscType) !== null && _a !== void 0 ? _a : (this._miscType = this.newMiscType()));
        }
        newMiscType() {
            return new wcardinalUi.DSelect({
                weight: 1,
                value: wcardinalUi.EShapeActionValueMiscType.INPUT_TEXT,
                menu: {
                    items: this.newMiscTypeMenuItems()
                }
            });
        }
        newMiscTypeMenuItems() {
            const themeShape = this.themeShape;
            const result = [
                {
                    value: wcardinalUi.EShapeActionValueMiscType.INPUT_TEXT,
                    text: {
                        value: themeShape.toMiscTypeLabel(wcardinalUi.EShapeActionValueMiscType.INPUT_TEXT)
                    }
                },
                {
                    value: wcardinalUi.EShapeActionValueMiscType.INPUT_INTEGER,
                    text: {
                        value: themeShape.toMiscTypeLabel(wcardinalUi.EShapeActionValueMiscType.INPUT_INTEGER)
                    }
                },
                {
                    value: wcardinalUi.EShapeActionValueMiscType.INPUT_REAL,
                    text: {
                        value: themeShape.toMiscTypeLabel(wcardinalUi.EShapeActionValueMiscType.INPUT_REAL)
                    }
                },
                {
                    value: wcardinalUi.EShapeActionValueMiscType.EMIT_EVENT,
                    text: {
                        value: themeShape.toMiscTypeLabel(wcardinalUi.EShapeActionValueMiscType.EMIT_EVENT)
                    }
                },
                {
                    value: wcardinalUi.EShapeActionValueMiscType.WRITE_BOTH,
                    text: {
                        value: themeShape.toMiscTypeLabel(wcardinalUi.EShapeActionValueMiscType.WRITE_BOTH)
                    }
                },
                {
                    value: wcardinalUi.EShapeActionValueMiscType.WRITE_LOCAL,
                    text: {
                        value: themeShape.toMiscTypeLabel(wcardinalUi.EShapeActionValueMiscType.WRITE_LOCAL)
                    }
                },
                {
                    value: wcardinalUi.EShapeActionValueMiscType.WRITE_REMOTE,
                    text: {
                        value: themeShape.toMiscTypeLabel(wcardinalUi.EShapeActionValueMiscType.WRITE_REMOTE)
                    }
                },
                {
                    value: wcardinalUi.EShapeActionValueMiscType.HTML_ELEMENT,
                    text: {
                        value: themeShape.toMiscTypeLabel(wcardinalUi.EShapeActionValueMiscType.HTML_ELEMENT)
                    }
                },
                {
                    value: wcardinalUi.EShapeActionValueMiscType.EXECUTE,
                    text: {
                        value: themeShape.toMiscTypeLabel(wcardinalUi.EShapeActionValueMiscType.EXECUTE)
                    }
                }
            ];
            wcardinalUi.EShapeActionMiscExtensions.each((extension) => {
                result.push({
                    value: extension.type,
                    text: {
                        value: extension.label
                    }
                });
            });
            return result;
        }
        get miscTypeLayout() {
            var _a;
            return ((_a = this._miscTypeLayout) !== null && _a !== void 0 ? _a : (this._miscTypeLayout = this.newLabeled(null, this.miscType)));
        }
        onChangeMiscTypeLayout(select) {
            const miscTypeLayout = this.miscTypeLayout;
            if (select === wcardinalUi.EShapeActionValueType.MISC) {
                miscTypeLayout.show();
            }
            else {
                miscTypeLayout.hide();
            }
        }
        // OnInput Action type
        get onInputAction() {
            var _a;
            return ((_a = this._onInputAction) !== null && _a !== void 0 ? _a : (this._onInputAction = this.newOnInputAction()));
        }
        newOnInputAction() {
            const themeShape = this.themeShape;
            return new wcardinalUi.DSelect({
                weight: 1,
                value: wcardinalUi.EShapeActionValueOnInputAction.WRITE_REMOTE,
                menu: {
                    items: [
                        {
                            value: wcardinalUi.EShapeActionValueOnInputAction.EMIT_EVENT,
                            text: {
                                value: themeShape.toOnInputActionLabel(wcardinalUi.EShapeActionValueOnInputAction.EMIT_EVENT)
                            }
                        },
                        {
                            value: wcardinalUi.EShapeActionValueOnInputAction.WRITE_BOTH,
                            text: {
                                value: themeShape.toOnInputActionLabel(wcardinalUi.EShapeActionValueOnInputAction.WRITE_BOTH)
                            }
                        },
                        {
                            value: wcardinalUi.EShapeActionValueOnInputAction.WRITE_LOCAL,
                            text: {
                                value: themeShape.toOnInputActionLabel(wcardinalUi.EShapeActionValueOnInputAction.WRITE_LOCAL)
                            }
                        },
                        {
                            value: wcardinalUi.EShapeActionValueOnInputAction.WRITE_REMOTE,
                            text: {
                                value: themeShape.toOnInputActionLabel(wcardinalUi.EShapeActionValueOnInputAction.WRITE_REMOTE)
                            }
                        }
                    ]
                }
            });
        }
        get onInputActionLayout() {
            var _a;
            return ((_a = this._onInputActionLayout) !== null && _a !== void 0 ? _a : (this._onInputActionLayout = this.newLabeled(null, this.onInputAction)));
        }
        onChangeOnInputActionLayout(select) {
            const onInputActionLayout = this.onInputActionLayout;
            if (select === wcardinalUi.EShapeActionValueType.OPEN) {
                switch (this.openType.value) {
                    case wcardinalUi.EShapeActionValueOpenType.DIALOG_TEXT:
                    case wcardinalUi.EShapeActionValueOpenType.DIALOG_INTEGER:
                    case wcardinalUi.EShapeActionValueOpenType.DIALOG_REAL:
                    case wcardinalUi.EShapeActionValueOpenType.DIALOG_BOOLEAN:
                        onInputActionLayout.show();
                        break;
                    case wcardinalUi.EShapeActionValueOpenType.DIALOG:
                        const openDialogType = this.openDialogType.value;
                        if (openDialogType == null) {
                            onInputActionLayout.hide();
                        }
                        else if (wcardinalUi.EShapeActionValueOpenDialogType.EXTENSION <= openDialogType) {
                            onInputActionLayout.hide();
                        }
                        else {
                            onInputActionLayout.show();
                        }
                        break;
                    default:
                        onInputActionLayout.hide();
                        break;
                }
            }
            else if (select === wcardinalUi.EShapeActionValueType.MISC) {
                switch (this.miscType.value) {
                    case wcardinalUi.EShapeActionValueMiscType.INPUT_TEXT:
                    case wcardinalUi.EShapeActionValueMiscType.INPUT_INTEGER:
                    case wcardinalUi.EShapeActionValueMiscType.INPUT_REAL:
                        onInputActionLayout.show();
                        break;
                    default:
                        onInputActionLayout.hide();
                        break;
                }
            }
            else {
                onInputActionLayout.hide();
            }
        }
        // Select when type
        get whenType() {
            var _a;
            return ((_a = this._whenType) !== null && _a !== void 0 ? _a : (this._whenType = this.newWhenType()));
        }
        newWhenType() {
            const themeShape = this.themeShape;
            return new wcardinalUi.DSelect({
                weight: 1,
                value: wcardinalUi.UtilHtmlElementWhen.FOCUSED,
                menu: {
                    items: [
                        {
                            value: wcardinalUi.UtilHtmlElementWhen.CLICKED,
                            text: {
                                value: themeShape.toHtmlElementWhenLabel(wcardinalUi.UtilHtmlElementWhen.CLICKED)
                            }
                        },
                        {
                            value: wcardinalUi.UtilHtmlElementWhen.DOUBLE_CLICKED,
                            text: {
                                value: themeShape.toHtmlElementWhenLabel(wcardinalUi.UtilHtmlElementWhen.DOUBLE_CLICKED)
                            }
                        },
                        {
                            value: wcardinalUi.UtilHtmlElementWhen.FOCUSED,
                            text: {
                                value: themeShape.toHtmlElementWhenLabel(wcardinalUi.UtilHtmlElementWhen.FOCUSED)
                            }
                        },
                        {
                            value: wcardinalUi.UtilHtmlElementWhen.ALWAYS,
                            text: {
                                value: themeShape.toHtmlElementWhenLabel(wcardinalUi.UtilHtmlElementWhen.ALWAYS)
                            }
                        }
                    ]
                }
            });
        }
        get whenTypeLayout() {
            var _a;
            return ((_a = this._whenTypeLayout) !== null && _a !== void 0 ? _a : (this._whenTypeLayout = this.newLabeled(this.theme.getSelectWhenLabel(), this.whenType)));
        }
        toWhenTypeValue(whenType) {
            switch (whenType) {
                case wcardinalUi.UtilHtmlElementWhen.CLICKED:
                    return '"CLICKED"';
                case wcardinalUi.UtilHtmlElementWhen.DOUBLE_CLICKED:
                    return '"DOUBLE_CLICKED"';
                case wcardinalUi.UtilHtmlElementWhen.FOCUSED:
                    return '"FOCUSED"';
                case wcardinalUi.UtilHtmlElementWhen.ALWAYS:
                    return '"ALWAYS"';
            }
            return '"FOCUSED"';
        }
        toWhenType(whenTypeValue) {
            switch (whenTypeValue) {
                case '"CLICKED"':
                    return wcardinalUi.UtilHtmlElementWhen.CLICKED;
                case '"DOUBLE_CLICKED"':
                    return wcardinalUi.UtilHtmlElementWhen.DOUBLE_CLICKED;
                case '"FOCUSED"':
                    return wcardinalUi.UtilHtmlElementWhen.FOCUSED;
                case '"ALWAYS"':
                    return wcardinalUi.UtilHtmlElementWhen.ALWAYS;
            }
            return wcardinalUi.UtilHtmlElementWhen.FOCUSED;
        }
        onChangeWhenTypeLayout(select) {
            const whenTypeLayout = this.whenTypeLayout;
            if (select === wcardinalUi.EShapeActionValueType.MISC) {
                switch (this.miscType.value) {
                    case wcardinalUi.EShapeActionValueMiscType.INPUT_TEXT:
                    case wcardinalUi.EShapeActionValueMiscType.INPUT_INTEGER:
                    case wcardinalUi.EShapeActionValueMiscType.INPUT_REAL:
                    case wcardinalUi.EShapeActionValueMiscType.HTML_ELEMENT:
                    case wcardinalUi.EShapeActionValueMiscType.HTML_ELEMENT_WITHOUT_POINTER_EVENTS:
                        whenTypeLayout.show();
                        break;
                    default:
                        whenTypeLayout.hide();
                        break;
                }
            }
            else {
                whenTypeLayout.hide();
            }
        }
        get gestureType() {
            var _a;
            return ((_a = this._gestureType) !== null && _a !== void 0 ? _a : (this._gestureType = this.newGestureType()));
        }
        newGestureType() {
            const themeShape = this.themeShape;
            return new wcardinalUi.DSelect({
                weight: 1,
                value: wcardinalUi.EShapeActionValueGestureType.SHAPE,
                menu: {
                    items: [
                        {
                            value: wcardinalUi.EShapeActionValueGestureType.SHAPE,
                            text: {
                                value: themeShape.toGestureTypeLabel(wcardinalUi.EShapeActionValueGestureType.SHAPE)
                            }
                        },
                        {
                            value: wcardinalUi.EShapeActionValueGestureType.LAYER,
                            text: {
                                value: themeShape.toGestureTypeLabel(wcardinalUi.EShapeActionValueGestureType.LAYER)
                            }
                        }
                    ]
                }
            });
        }
        get gestureTypeLayout() {
            var _a;
            return ((_a = this._gestureTypeLayout) !== null && _a !== void 0 ? _a : (this._gestureTypeLayout = this.newLabeled("", this.gestureType)));
        }
        onChangeGestureTypeLayout(select) {
            const gestureTypeLayout = this.gestureTypeLayout;
            if (select === wcardinalUi.EShapeActionValueType.GESTURE) {
                gestureTypeLayout.show();
            }
            else {
                gestureTypeLayout.hide();
            }
        }
        get gestureOperationType() {
            var _a;
            return ((_a = this._gestureOperationType) !== null && _a !== void 0 ? _a : (this._gestureOperationType = this.newGestureOperationType()));
        }
        newGestureOperationType() {
            const themeShape = this.themeShape;
            return new wcardinalUi.DSelectMultiple({
                weight: 1,
                values: this.fromGestureOperationType(wcardinalUi.EShapeActionValueGestureOperationType.ALL),
                menu: {
                    items: [
                        {
                            value: wcardinalUi.EShapeActionValueGestureOperationType.DRAG,
                            text: {
                                value: themeShape.toGestureOperationTypeLabel(wcardinalUi.EShapeActionValueGestureOperationType.DRAG)
                            },
                            check: true
                        },
                        {
                            value: wcardinalUi.EShapeActionValueGestureOperationType.PINCH,
                            text: {
                                value: themeShape.toGestureOperationTypeLabel(wcardinalUi.EShapeActionValueGestureOperationType.PINCH)
                            },
                            check: true
                        }
                    ]
                }
            });
        }
        toGestureOperationType(types) {
            let result = wcardinalUi.EShapeActionValueGestureOperationType.NONE;
            for (let i = 0, imax = types.length; i < imax; ++i) {
                result |= types[i];
            }
            return result;
        }
        fromGestureOperationType(type) {
            const result = [];
            if (type & wcardinalUi.EShapeActionValueGestureOperationType.DRAG) {
                result.push(wcardinalUi.EShapeActionValueGestureOperationType.DRAG);
            }
            if (type & wcardinalUi.EShapeActionValueGestureOperationType.PINCH) {
                result.push(wcardinalUi.EShapeActionValueGestureOperationType.PINCH);
            }
            return result;
        }
        get gestureOperationTypeLayout() {
            var _a;
            return ((_a = this._gestureOperationTypeLayout) !== null && _a !== void 0 ? _a : (this._gestureOperationTypeLayout = this.newLabeled("", this.gestureOperationType)));
        }
        onChangeGestureOperationTypeLayout(select) {
            const gestureOperationTypeLayout = this.gestureOperationTypeLayout;
            if (select === wcardinalUi.EShapeActionValueType.GESTURE) {
                gestureOperationTypeLayout.show();
            }
            else {
                gestureOperationTypeLayout.hide();
            }
        }
        get selectLayer() {
            var _a;
            return ((_a = this._selectLayer) !== null && _a !== void 0 ? _a : (this._selectLayer = this.newSelectLayer()));
        }
        newSelectLayer() {
            return new wcardinalUi.DSelectMultiple({
                weight: 1
            });
        }
        newSelectLayerMenuItemOptions() {
            var _a;
            const diagram = (_a = this.options) === null || _a === void 0 ? void 0 : _a.diagram;
            if (diagram != null) {
                const canvas = diagram.canvas;
                if (canvas != null) {
                    const result = [];
                    const layers = canvas.layer.children;
                    for (let i = layers.length - 1; 0 <= i; --i) {
                        const layer = layers[i];
                        result.push({
                            value: i,
                            text: {
                                value: layer.name
                            },
                            check: true
                        });
                    }
                    return result;
                }
            }
            return [];
        }
        get selectLayerLayout() {
            var _a;
            return ((_a = this._selectLayerLayout) !== null && _a !== void 0 ? _a : (this._selectLayerLayout = this.newLabeled(this.theme.getSelectLayerLabel(), this.selectLayer)));
        }
        onChangeSelectLayerLayout(select) {
            const selectLayerLayout = this.selectLayerLayout;
            if (select === wcardinalUi.EShapeActionValueType.SHOW_HIDE) {
                switch (this.showHideType.value) {
                    case wcardinalUi.EShapeActionValueShowHideType.LAYER:
                        selectLayerLayout.show();
                        break;
                    default:
                        selectLayerLayout.hide();
                        break;
                }
            }
            else {
                selectLayerLayout.hide();
            }
        }
        // Condition
        get condition() {
            var _a;
            return ((_a = this._condition) !== null && _a !== void 0 ? _a : (this._condition = this.newCondition()));
        }
        newCondition() {
            return new wcardinalUi.DInputTextAndLabel({
                width: "padding",
                height: "auto",
                label: {
                    width: 60,
                    text: {
                        value: this.theme.getInputConditionLabel()
                    }
                },
                input: {
                    weight: 1,
                    on: {
                        enter: () => {
                            this.ok();
                        }
                    }
                },
                space: {
                    width: 60
                }
            });
        }
        onChangeCondition(select) {
            const condition = this.condition;
            if (select === wcardinalUi.EShapeActionValueType.MISC) {
                switch (this.miscType.value) {
                    case wcardinalUi.EShapeActionValueMiscType.INPUT_TEXT:
                    case wcardinalUi.EShapeActionValueMiscType.INPUT_INTEGER:
                    case wcardinalUi.EShapeActionValueMiscType.INPUT_REAL:
                    case wcardinalUi.EShapeActionValueMiscType.HTML_ELEMENT:
                    case wcardinalUi.EShapeActionValueMiscType.HTML_ELEMENT_WITHOUT_POINTER_EVENTS:
                        condition.hide();
                        break;
                    default:
                        condition.show();
                        break;
                }
            }
            else {
                condition.show();
            }
        }
        // Interval
        get interval() {
            var _a;
            return ((_a = this._interval) !== null && _a !== void 0 ? _a : (this._interval = this.newInterval()));
        }
        newInterval() {
            return new wcardinalUi.DInputInteger({
                weight: 1,
                text: {
                    value: 1000
                },
                min: 0,
                step: 100,
                on: {
                    enter: () => {
                        this.ok();
                    }
                }
            });
        }
        get intervalLayout() {
            var _a;
            return ((_a = this._intervalLayout) !== null && _a !== void 0 ? _a : (this._intervalLayout = this.newIntervalLayout()));
        }
        newIntervalLayout() {
            const theme = this.theme;
            return new wcardinalUi.DLayoutHorizontal({
                width: "padding",
                height: "auto",
                children: [
                    this.newLabel(theme.getInputIntervalLabel()),
                    this.interval,
                    new wcardinalUi.DText({
                        width: 60,
                        text: {
                            value: theme.getInputIntervalUnitLabel(),
                            align: {
                                horizontal: wcardinalUi.DAlignHorizontal.LEFT
                            }
                        }
                    })
                ]
            });
        }
        onChangeIntervalLayout(select) {
            const intervalLayout = this.intervalLayout;
            if (select === wcardinalUi.EShapeActionValueType.BLINK) {
                intervalLayout.show();
            }
            else {
                intervalLayout.hide();
            }
        }
        // Size
        get size() {
            var _a;
            return ((_a = this._size) !== null && _a !== void 0 ? _a : (this._size = this.newSize()));
        }
        newSize() {
            return new wcardinalUi.DInputTextAndLabel({
                width: "padding",
                height: "auto",
                label: {
                    width: 60,
                    text: {
                        value: this.theme.getInputSizeLabel()
                    }
                },
                input: {
                    weight: 1,
                    on: {
                        enter: () => {
                            this.ok();
                        }
                    }
                },
                space: {
                    width: 60
                }
            });
        }
        onChangeSize(select) {
            const size = this.size;
            if (select === wcardinalUi.EShapeActionValueType.TRANSFORM) {
                if (this.transformType.value === wcardinalUi.EShapeActionValueTransformType.RESIZE) {
                    size.show();
                }
                else {
                    size.hide();
                }
            }
            else {
                size.hide();
            }
        }
        // Move amount
        get amount() {
            var _a;
            return ((_a = this._amount) !== null && _a !== void 0 ? _a : (this._amount = this.newAmount()));
        }
        newAmount() {
            return new wcardinalUi.DInputTextAndLabel({
                width: "padding",
                height: "auto",
                label: {
                    width: 60,
                    text: {
                        value: this.theme.getInputAmountLabel()
                    }
                },
                input: {
                    weight: 1,
                    on: {
                        enter: () => {
                            this.ok();
                        }
                    }
                },
                space: {
                    width: 60
                }
            });
        }
        onChangeAmount(select) {
            const amount = this.amount;
            if (select === wcardinalUi.EShapeActionValueType.TRANSFORM) {
                const transformType = this.transformType.value;
                if (transformType === wcardinalUi.EShapeActionValueTransformType.MOVE ||
                    transformType === wcardinalUi.EShapeActionValueTransformType.ROTATE) {
                    amount.show();
                }
                else {
                    amount.hide();
                }
            }
            else {
                amount.hide();
            }
        }
        // Value
        get contents() {
            var _a;
            return ((_a = this._contents) !== null && _a !== void 0 ? _a : (this._contents = this.newContents()));
        }
        newContents() {
            return new wcardinalUi.DInputTextAndLabel({
                width: "padding",
                height: "auto",
                label: {
                    width: 60,
                    text: {
                        value: this.theme.getInputValueLabel()
                    }
                },
                input: {
                    weight: 1,
                    on: {
                        enter: () => {
                            this.ok();
                        }
                    }
                },
                space: {
                    width: 60
                }
            });
        }
        onChangeContents(select) {
            const contents = this.contents;
            if (select === wcardinalUi.EShapeActionValueType.CHANGE_TEXT) {
                contents.show();
            }
            else if (select === wcardinalUi.EShapeActionValueType.MISC) {
                switch (this.miscType.value) {
                    case wcardinalUi.EShapeActionValueMiscType.WRITE_BOTH:
                    case wcardinalUi.EShapeActionValueMiscType.WRITE_LOCAL:
                    case wcardinalUi.EShapeActionValueMiscType.WRITE_REMOTE:
                        contents.show();
                        break;
                    default:
                        contents.hide();
                        break;
                }
            }
            else {
                contents.hide();
            }
        }
        // Initialization
        get initialization() {
            var _a;
            return ((_a = this._initialization) !== null && _a !== void 0 ? _a : (this._initialization = this.newInitialization()));
        }
        newInitialization() {
            return new wcardinalUi.DInputTextAndLabel({
                width: "padding",
                height: "auto",
                label: {
                    width: 60,
                    text: {
                        value: this.theme.getInputInitializationLabel()
                    }
                },
                input: {
                    weight: 1,
                    on: {
                        enter: () => {
                            this.ok();
                        }
                    }
                },
                space: {
                    width: 60
                }
            });
        }
        onChangeInitialization(select) {
            const initialization = this.initialization;
            if (select === wcardinalUi.EShapeActionValueType.MISC) {
                switch (this.miscType.value) {
                    case wcardinalUi.EShapeActionValueMiscType.HTML_ELEMENT:
                    case wcardinalUi.EShapeActionValueMiscType.HTML_ELEMENT_WITHOUT_POINTER_EVENTS:
                        initialization.show();
                        break;
                    default:
                        initialization.hide();
                        break;
                }
            }
            else {
                initialization.hide();
            }
        }
        // Pointer events layout
        get pointerEventsLayout() {
            var _a;
            return ((_a = this._pointerEventsLayout) !== null && _a !== void 0 ? _a : (this._pointerEventsLayout = this.newLabeled(null, this.pointerEvents)));
        }
        onChangePointerEventsLayout(select) {
            const pointerEventsLayout = this.pointerEventsLayout;
            if (select === wcardinalUi.EShapeActionValueType.MISC) {
                switch (this.miscType.value) {
                    case wcardinalUi.EShapeActionValueMiscType.HTML_ELEMENT:
                    case wcardinalUi.EShapeActionValueMiscType.HTML_ELEMENT_WITHOUT_POINTER_EVENTS:
                        pointerEventsLayout.show();
                        break;
                    default:
                        pointerEventsLayout.hide();
                        break;
                }
            }
            else {
                pointerEventsLayout.hide();
            }
        }
        // Pointer events
        get pointerEvents() {
            var _a;
            return ((_a = this._pointerEvents) !== null && _a !== void 0 ? _a : (this._pointerEvents = this.newPointerEvents()));
        }
        newPointerEvents() {
            return new wcardinalUi.DButtonCheck({
                weight: 1,
                text: {
                    value: this.theme.getCheckPointEventsLabel(),
                    align: {
                        horizontal: "LEFT"
                    }
                }
            });
        }
        // Event Name / Cursor name
        get targetName() {
            var _a;
            return ((_a = this._targetName) !== null && _a !== void 0 ? _a : (this._targetName = this.newTargetName()));
        }
        newTargetName() {
            return new wcardinalUi.DInputTextAndLabel({
                width: "padding",
                height: "auto",
                label: {
                    width: 60,
                    text: {
                        value: this.theme.getInputTargetNameLabel()
                    }
                },
                input: {
                    weight: 1,
                    on: {
                        enter: () => {
                            this.ok();
                        }
                    }
                },
                space: {
                    width: 60
                }
            });
        }
        onChangeTargetName(select) {
            const targetName = this.targetName;
            if (select === wcardinalUi.EShapeActionValueType.EMIT_EVENT ||
                select === wcardinalUi.EShapeActionValueType.CHANGE_CURSOR) {
                targetName.show();
            }
            else {
                targetName.hide();
            }
        }
        // Color
        get color() {
            var _a;
            return ((_a = this._color) !== null && _a !== void 0 ? _a : (this._color = this.newColor()));
        }
        newColor() {
            const result = new wcardinalUi.DButtonColor({
                weight: 1
            });
            result.dialog.on("open", () => {
                const dialogNew = result.dialog.new;
                const dialogCurrent = result.dialog.current;
                dialogNew.color = dialogCurrent.color;
                dialogNew.alpha = dialogCurrent.alpha;
            });
            return result;
        }
        get colorLayout() {
            var _a;
            return ((_a = this._colorLayout) !== null && _a !== void 0 ? _a : (this._colorLayout = this.newColorLayout()));
        }
        newColorLayout() {
            return new wcardinalUi.DLayoutHorizontal({
                width: "padding",
                height: "auto",
                children: [
                    new wcardinalUi.DInputLabel({
                        width: 60,
                        text: {
                            value: this.theme.getButtonColorLabel()
                        }
                    }),
                    this.color,
                    new wcardinalUi.DLayoutSpace({
                        width: 60
                    })
                ]
            });
        }
        onChangeColorLayout(select) {
            const colorLayout = this.colorLayout;
            if (select === wcardinalUi.EShapeActionValueType.CHANGE_COLOR) {
                const changeColorTarget = this.changeColorTarget.value;
                if (changeColorTarget === wcardinalUi.EShapeActionValueChangeColorTarget.COLOR_AND_ALPHA ||
                    changeColorTarget === wcardinalUi.EShapeActionValueChangeColorTarget.COLOR ||
                    changeColorTarget === wcardinalUi.EShapeActionValueChangeColorTarget.ALPHA) {
                    colorLayout.show();
                }
                else {
                    colorLayout.hide();
                }
            }
            else if (select === wcardinalUi.EShapeActionValueType.BLINK) {
                const blinkType = this.blinkType.value;
                if (blinkType === wcardinalUi.EShapeActionValueBlinkType.COLOR_FILL ||
                    blinkType === wcardinalUi.EShapeActionValueBlinkType.COLOR_STROKE) {
                    colorLayout.show();
                }
                else {
                    colorLayout.hide();
                }
            }
            else {
                colorLayout.hide();
            }
        }
        // Target
        get target() {
            var _a;
            return ((_a = this._target) !== null && _a !== void 0 ? _a : (this._target = this.newTarget()));
        }
        newTarget() {
            return new wcardinalUi.DInputTextAndLabel({
                width: "padding",
                height: "auto",
                label: {
                    width: 60,
                    text: {
                        value: this.theme.getInputTargetLabel()
                    }
                },
                input: {
                    weight: 1,
                    on: {
                        enter: () => {
                            this.ok();
                        }
                    }
                },
                space: {
                    width: 60
                }
            });
        }
        onChangeTarget(select) {
            const target = this.target;
            if (select === wcardinalUi.EShapeActionValueType.OPEN) {
                target.show();
            }
            else if (select === wcardinalUi.EShapeActionValueType.MISC) {
                const miscType = this.miscType.value;
                if (miscType == null) {
                    target.show();
                }
                else if (miscType === wcardinalUi.EShapeActionValueMiscType.HTML_ELEMENT ||
                    miscType === wcardinalUi.EShapeActionValueMiscType.HTML_ELEMENT_WITHOUT_POINTER_EVENTS ||
                    wcardinalUi.EShapeActionValueMiscType.EXTENSION <= miscType) {
                    target.hide();
                }
                else {
                    target.show();
                }
            }
            else {
                target.hide();
            }
        }
        // Argument
        get argument() {
            var _a;
            return ((_a = this._argument) !== null && _a !== void 0 ? _a : (this._argument = this.newArgument()));
        }
        newArgument() {
            return new wcardinalUi.DInputTextAndLabel({
                width: "padding",
                height: "auto",
                label: {
                    width: 60,
                    text: {
                        value: this.theme.getInputArgumentLabel()
                    }
                },
                input: {
                    weight: 1,
                    on: {
                        enter: () => {
                            this.ok();
                        }
                    }
                },
                space: {
                    width: 60
                }
            });
        }
        onChangeArgument(select) {
            const argument = this.argument;
            if (select === wcardinalUi.EShapeActionValueType.OPEN) {
                const openType = this.openType.value;
                if (openType === wcardinalUi.EShapeActionValueOpenType.DIALOG) {
                    const openDialogType = this.openDialogType.value;
                    if (openDialogType == null) {
                        argument.hide();
                    }
                    else if (wcardinalUi.EShapeActionValueOpenDialogType.EXTENSION <= openDialogType) {
                        argument.show();
                    }
                    else {
                        argument.hide();
                    }
                }
                else {
                    argument.hide();
                }
            }
            else if (select === wcardinalUi.EShapeActionValueType.MISC) {
                const miscType = this.miscType.value;
                if (miscType != null && wcardinalUi.EShapeActionValueMiscType.EXTENSION <= miscType) {
                    argument.show();
                }
                else {
                    argument.hide();
                }
            }
            else {
                argument.hide();
            }
        }
        // Color code
        get colorCode() {
            var _a;
            return ((_a = this._colorCode) !== null && _a !== void 0 ? _a : (this._colorCode = this.newColorCode()));
        }
        newColorCode() {
            return new wcardinalUi.DInputTextAndLabel({
                width: "padding",
                height: "auto",
                label: {
                    width: 60,
                    text: {
                        value: this.theme.getInputColorCodeLabel()
                    }
                },
                input: {
                    weight: 1,
                    text: {
                        value: ""
                    },
                    on: {
                        enter: () => {
                            this.ok();
                        }
                    }
                },
                space: {
                    width: 60
                }
            });
        }
        onChangeColorCode(select) {
            const colorCode = this.colorCode;
            if (select === wcardinalUi.EShapeActionValueType.CHANGE_COLOR) {
                if (this.changeColorTarget.value === wcardinalUi.EShapeActionValueChangeColorTarget.CODE) {
                    colorCode.show();
                }
                else {
                    colorCode.hide();
                }
            }
            else {
                colorCode.hide();
            }
        }
        // Alpha code
        get alphaCode() {
            var _a;
            return ((_a = this._alphaCode) !== null && _a !== void 0 ? _a : (this._alphaCode = this.newAlphaCode()));
        }
        newAlphaCode() {
            return new wcardinalUi.DInputTextAndLabel({
                width: "padding",
                height: "auto",
                input: {
                    weight: 1,
                    on: {
                        enter: () => {
                            this.ok();
                        }
                    }
                },
                label: {
                    width: 60,
                    text: {
                        value: this.theme.getInputAlphaCodeLabel()
                    }
                },
                space: {
                    width: 60
                }
            });
        }
        onChangeAlphaCode(select) {
            const alphaCode = this.alphaCode;
            if (select === wcardinalUi.EShapeActionValueType.CHANGE_COLOR) {
                if (this.changeColorTarget.value === wcardinalUi.EShapeActionValueChangeColorTarget.CODE) {
                    alphaCode.show();
                }
                else {
                    alphaCode.hide();
                }
            }
            else {
                alphaCode.hide();
            }
        }
        // Brightness
        get brightness() {
            var _a;
            return ((_a = this._brightness) !== null && _a !== void 0 ? _a : (this._brightness = this.newBrightness()));
        }
        newBrightness() {
            return new wcardinalUi.DInputTextAndLabel({
                width: "padding",
                height: "auto",
                input: {
                    weight: 1,
                    on: {
                        enter: () => {
                            this.ok();
                        }
                    }
                },
                label: {
                    width: 60,
                    text: {
                        value: this.theme.getInputBrightnessLabel()
                    }
                },
                space: {
                    width: 60
                }
            });
        }
        onChangeBrightness(select) {
            const brightness = this.brightness;
            if (select === wcardinalUi.EShapeActionValueType.CHANGE_COLOR) {
                if (this.changeColorTarget.value === wcardinalUi.EShapeActionValueChangeColorTarget.BRIGHTNESS) {
                    brightness.show();
                }
                else {
                    brightness.hide();
                }
            }
            else {
                brightness.hide();
            }
        }
        // Blend
        get blend() {
            var _a;
            return ((_a = this._blend) !== null && _a !== void 0 ? _a : (this._blend = this.newBlend()));
        }
        newBlend() {
            return new wcardinalUi.DInputTextAndLabel({
                width: "padding",
                height: "auto",
                label: {
                    width: 60,
                    text: {
                        value: this.theme.getInputBlendLabel()
                    }
                },
                input: {
                    weight: 1,
                    on: {
                        enter: () => {
                            this.ok();
                        }
                    }
                },
                space: {
                    width: 60
                }
            });
        }
        onChangeBlend(select) {
            const blend = this.blend;
            if (select === wcardinalUi.EShapeActionValueType.CHANGE_COLOR) {
                const changeColorTarget = this.changeColorTarget.value;
                if (changeColorTarget === wcardinalUi.EShapeActionValueChangeColorTarget.COLOR_AND_ALPHA ||
                    changeColorTarget === wcardinalUi.EShapeActionValueChangeColorTarget.COLOR ||
                    changeColorTarget === wcardinalUi.EShapeActionValueChangeColorTarget.ALPHA ||
                    changeColorTarget === wcardinalUi.EShapeActionValueChangeColorTarget.CODE) {
                    blend.show();
                }
                else {
                    blend.hide();
                }
            }
            else {
                blend.hide();
            }
        }
        // Initial
        get initial() {
            var _a;
            return ((_a = this._initial) !== null && _a !== void 0 ? _a : (this._initial = this.newInitial()));
        }
        newInitial() {
            return new wcardinalUi.DInputTextAndLabel({
                width: "padding",
                height: "auto",
                label: {
                    width: 60,
                    text: {
                        value: this.theme.getInputInitialLabel()
                    }
                },
                input: {
                    weight: 1,
                    on: {
                        enter: () => {
                            this.ok();
                        }
                    }
                },
                space: {
                    width: 60
                }
            });
        }
        onChangeInitial(select) {
            const initial = this.initial;
            if (select === wcardinalUi.EShapeActionValueType.OPEN) {
                switch (this.openType.value) {
                    case wcardinalUi.EShapeActionValueOpenType.DIALOG:
                        switch (this.openDialogType.value) {
                            case wcardinalUi.EShapeActionValueOpenDialogType.TEXT:
                            case wcardinalUi.EShapeActionValueOpenDialogType.INTEGER:
                            case wcardinalUi.EShapeActionValueOpenDialogType.REAL:
                            case wcardinalUi.EShapeActionValueOpenDialogType.BOOLEAN:
                            case wcardinalUi.EShapeActionValueOpenDialogType.DATE:
                            case wcardinalUi.EShapeActionValueOpenDialogType.TIME:
                            case wcardinalUi.EShapeActionValueOpenDialogType.DATETIME:
                                initial.show();
                                break;
                            default:
                                initial.hide();
                                break;
                        }
                        break;
                    default:
                        initial.hide();
                        break;
                }
            }
            else {
                initial.hide();
            }
        }
        get step() {
            var _a;
            return ((_a = this._step) !== null && _a !== void 0 ? _a : (this._step = this.newStep()));
        }
        newStep() {
            return new wcardinalUi.DInputTextAndLabel({
                width: "padding",
                height: "auto",
                label: {
                    width: 60,
                    text: {
                        value: this.theme.getInputStepLabel()
                    }
                },
                input: {
                    weight: 1,
                    on: {
                        enter: () => {
                            this.ok();
                        }
                    }
                },
                space: {
                    width: 60
                }
            });
        }
        onChangeStep(select) {
            const step = this.step;
            if (select === wcardinalUi.EShapeActionValueType.OPEN) {
                switch (this.openType.value) {
                    case wcardinalUi.EShapeActionValueOpenType.DIALOG:
                        switch (this.openDialogType.value) {
                            case wcardinalUi.EShapeActionValueOpenDialogType.INTEGER:
                            case wcardinalUi.EShapeActionValueOpenDialogType.REAL:
                                step.show();
                                break;
                            default:
                                step.hide();
                                break;
                        }
                        break;
                    default:
                        step.hide();
                        break;
                }
            }
            else {
                step.hide();
            }
        }
        get min() {
            var _a;
            return ((_a = this._min) !== null && _a !== void 0 ? _a : (this._min = this.newMin()));
        }
        newMin() {
            return new wcardinalUi.DInputTextAndLabel({
                width: "padding",
                height: "auto",
                label: {
                    width: 60,
                    text: {
                        value: this.theme.getInputMinLabel()
                    }
                },
                input: {
                    weight: 1,
                    on: {
                        enter: () => {
                            this.ok();
                        }
                    }
                },
                space: {
                    width: 60
                }
            });
        }
        onChangeMin(select) {
            const min = this.min;
            if (select === wcardinalUi.EShapeActionValueType.OPEN) {
                switch (this.openType.value) {
                    case wcardinalUi.EShapeActionValueOpenType.DIALOG:
                        switch (this.openDialogType.value) {
                            case wcardinalUi.EShapeActionValueOpenDialogType.INTEGER:
                            case wcardinalUi.EShapeActionValueOpenDialogType.REAL:
                                min.show();
                                break;
                            default:
                                min.hide();
                                break;
                        }
                        break;
                    default:
                        min.hide();
                        break;
                }
            }
            else {
                min.hide();
            }
        }
        get max() {
            var _a;
            return ((_a = this._max) !== null && _a !== void 0 ? _a : (this._max = this.newMax()));
        }
        newMax() {
            return new wcardinalUi.DInputTextAndLabel({
                width: "padding",
                height: "auto",
                label: {
                    width: 60,
                    text: {
                        value: this.theme.getInputMaxLabel()
                    }
                },
                input: {
                    weight: 1,
                    on: {
                        enter: () => {
                            this.ok();
                        }
                    }
                },
                space: {
                    width: 60
                }
            });
        }
        onChangeMax(select) {
            const max = this.max;
            if (select === wcardinalUi.EShapeActionValueType.OPEN) {
                switch (this.openType.value) {
                    case wcardinalUi.EShapeActionValueOpenType.DIALOG:
                        switch (this.openDialogType.value) {
                            case wcardinalUi.EShapeActionValueOpenDialogType.INTEGER:
                            case wcardinalUi.EShapeActionValueOpenDialogType.REAL:
                                max.show();
                                break;
                            default:
                                max.hide();
                                break;
                        }
                        break;
                    default:
                        max.hide();
                        break;
                }
            }
            else {
                max.hide();
            }
        }
        // Scale layout
        get scaleLayout() {
            var _a;
            return ((_a = this._scaleLayout) !== null && _a !== void 0 ? _a : (this._scaleLayout = this.newScaleLayout()));
        }
        newScaleLayout() {
            return new wcardinalUi.DLayoutHorizontal({
                width: "padding",
                height: "auto",
                children: [
                    new wcardinalUi.DInputLabel({
                        width: 60,
                        text: {
                            value: this.theme.getInputScaleLabel()
                        }
                    }),
                    this.scaleMin,
                    this.scaleMax,
                    new wcardinalUi.DLayoutSpace({
                        width: 60
                    })
                ]
            });
        }
        onChangeScaleLayout(select) {
            const scaleLayout = this.scaleLayout;
            if (select === wcardinalUi.EShapeActionValueType.GESTURE) {
                scaleLayout.show();
            }
            else {
                scaleLayout.hide();
            }
        }
        get scaleMin() {
            var _a;
            return ((_a = this._scaleMin) !== null && _a !== void 0 ? _a : (this._scaleMin = this.newScaleMin()));
        }
        newScaleMin() {
            return new wcardinalUi.DInputReal({
                weight: 1,
                on: {
                    enter: () => {
                        this.ok();
                    }
                }
            });
        }
        // Scale max
        get scaleMax() {
            var _a;
            return ((_a = this._scaleMax) !== null && _a !== void 0 ? _a : (this._scaleMax = this.newScaleMax()));
        }
        newScaleMax() {
            return new wcardinalUi.DInputReal({
                weight: 1,
                on: {
                    enter: () => {
                        this.ok();
                    }
                }
            });
        }
        get checkBringToFront() {
            var _a;
            return ((_a = this._checkBringToFront) !== null && _a !== void 0 ? _a : (this._checkBringToFront = this.newCheckBringToFront()));
        }
        newCheckBringToFront() {
            return new wcardinalUi.DButtonCheck({
                weight: 1,
                text: {
                    value: this.theme.getCheckBringToFrontLabel(),
                    align: {
                        horizontal: "LEFT"
                    }
                }
            });
        }
        get checkBringToFrontLayout() {
            var _a;
            return ((_a = this._checkBringToFrontLayout) !== null && _a !== void 0 ? _a : (this._checkBringToFrontLayout = this.newLabeled(null, this.checkBringToFront)));
        }
        onChangeCheckBringToFrontLayout(select) {
            const checkBringToFrontLayout = this.checkBringToFrontLayout;
            if (select === wcardinalUi.EShapeActionValueType.SHOW_HIDE) {
                switch (this.showHideType.value) {
                    case wcardinalUi.EShapeActionValueShowHideType.LAYER:
                        checkBringToFrontLayout.show();
                        break;
                    default:
                        checkBringToFrontLayout.hide();
                        break;
                }
            }
            else {
                checkBringToFrontLayout.hide();
            }
        }
        // inNewWindow
        get inNewWindow() {
            var _a;
            return ((_a = this._inNewWindow) !== null && _a !== void 0 ? _a : (this._inNewWindow = this.newInNewWindow()));
        }
        newInNewWindow() {
            return new wcardinalUi.DButtonCheck({
                weight: 1,
                text: {
                    value: this.theme.getCheckInNewWindowLabel(),
                    align: {
                        horizontal: "LEFT"
                    }
                }
            });
        }
        get inNewWindowLayout() {
            var _a;
            return ((_a = this._inNewWindowLayout) !== null && _a !== void 0 ? _a : (this._inNewWindowLayout = this.newLabeled(null, this.inNewWindow)));
        }
        onChangeInNewWindowLayout(select) {
            const inNewWindowLayout = this.inNewWindowLayout;
            if (select === wcardinalUi.EShapeActionValueType.OPEN) {
                switch (this.openType.value) {
                    case wcardinalUi.EShapeActionValueOpenType.DIALOG:
                        inNewWindowLayout.hide();
                        break;
                    default:
                        inNewWindowLayout.show();
                        break;
                }
            }
            else {
                inNewWindowLayout.hide();
            }
        }
        get extension() {
            var _a;
            return ((_a = this._extension) !== null && _a !== void 0 ? _a : (this._extension = new EDialogActionExtensionContainer(this, this.condition, this.content)));
        }
        onChange() {
            const select = this.select.value;
            this.onChangeAlphaCode(select);
            this.onChangeAmount(select);
            this.onChangeBlend(select);
            this.onChangeBlinkTypeLayout(select);
            this.onChangeBrightness(select);
            this.onChangeChangeColorTargetLayout(select);
            this.onChangeChangeColorTypeLayout(select);
            this.onChangeChangeTextTypeLayout(select);
            this.onChangeCondition(select);
            this.onChangeColorCode(select);
            this.onChangeColorLayout(select);
            this.onChangeInitial(select);
            this.onChangeStep(select);
            this.onChangeMin(select);
            this.onChangeMax(select);
            this.onChangeIntervalLayout(select);
            this.onChangeMiscTypeLayout(select);
            this.onChangeMoveTypeLayout(select);
            this.onChangeOnInputActionLayout(select);
            this.onChangeWhenTypeLayout(select);
            this.onChangeGestureTypeLayout(select);
            this.onChangeGestureOperationTypeLayout(select);
            this.onChangeSelectLayerLayout(select);
            this.onChangeOpenTypeLayout(select);
            this.onChangeOpenDialogTypeLayout(select);
            this.onChangeOriginXLayout(select);
            this.onChangeOriginYLayout(select);
            this.onChangeResizeTypeLayout(select);
            this.onChangeRotateTypeLayout(select);
            this.onChangeShowHideTypeLayout(select);
            this.onChangeSize(select);
            this.onChangeTarget(select);
            this.onChangeArgument(select);
            this.onChangeTargetName(select);
            this.onChangeContents(select);
            this.onChangeInitialization(select);
            this.onChangePointerEventsLayout(select);
            this.onChangeTransformTypeLayout(select);
            this.onChangeScaleLayout(select);
            this.onChangeCheckBringToFrontLayout(select);
            this.onChangeInNewWindowLayout(select);
            this.extension.onChange(select);
        }
        reset() {
            this.select.value = wcardinalUi.EShapeActionValueType.SHOW_HIDE;
            this.showHideType.value = wcardinalUi.EShapeActionValueShowHideType.SHAPE;
            this.blinkType.value = wcardinalUi.EShapeActionValueBlinkType.VISIBILITY;
            this.transformType.value = wcardinalUi.EShapeActionValueTransformType.MOVE;
            this.changeColorType.values = [wcardinalUi.EShapeActionValueChangeColorType.FILL];
            this.changeColorTarget.value = wcardinalUi.EShapeActionValueChangeColorTarget.COLOR_AND_ALPHA;
            this.resizeType.value = wcardinalUi.EShapeActionValueTransformResizeType.RELATIVE_SIZE;
            this.originY.value = 0.5;
            this.originX.value = 0.5;
            this.moveType.value = wcardinalUi.EShapeActionValueTransformMoveType.RELATIVE_X;
            this.rotateType.value = wcardinalUi.EShapeActionValueTransformRotateType.RELATIVE;
            this.openType.value = wcardinalUi.EShapeActionValueOpenType.DIAGRAM;
            this.openDialogType.value = wcardinalUi.EShapeActionValueOpenDialogType.TEXT;
            this.changeTextType.value = wcardinalUi.EShapeActionValueChangeTextType.TEXT;
            this.miscType.value = wcardinalUi.EShapeActionValueMiscType.INPUT_TEXT;
            this.onInputAction.value = wcardinalUi.EShapeActionValueOnInputAction.WRITE_REMOTE;
            this.whenType.value = wcardinalUi.UtilHtmlElementWhen.FOCUSED;
            this.gestureType.value = wcardinalUi.EShapeActionValueGestureType.SHAPE;
            this.gestureOperationType.values = this.fromGestureOperationType(wcardinalUi.EShapeActionValueGestureOperationType.ALL);
            this.selectLayer.values = [];
            this.selectLayer.menu = new wcardinalUi.DMenu({
                fit: true,
                items: this.newSelectLayerMenuItemOptions()
            });
            this.condition.input.value = "";
            this.size.input.value = "";
            this.amount.input.value = "";
            this.contents.input.value = "";
            this.initialization.input.value = "";
            this.pointerEvents.state.isActive = true;
            this.targetName.input.value = "";
            this.interval.value = 1000;
            this.color.value.color = 0xffffff;
            this.color.value.alpha = 1;
            this.target.input.value = "";
            this.argument.input.value = "";
            this.colorCode.input.value = "";
            this.alphaCode.input.value = "";
            this.brightness.input.value = "";
            this.blend.input.value = "";
            this.initial.input.value = "";
            this.step.input.value = "";
            this.min.input.value = "";
            this.max.input.value = "";
            this.scaleMin.value = 0.05;
            this.scaleMax.value = 20;
            this.checkBringToFront.state.isActive = false;
            this.inNewWindow.state.isActive = false;
            this.extension.reset();
            this.onChange();
            return this;
        }
        get value() {
            var _a, _b, _c, _d;
            const select = this.select.value;
            const condition = this.condition.input.value;
            if (select != null) {
                switch (select) {
                    case wcardinalUi.EShapeActionValueType.SHOW_HIDE:
                        switch (this.showHideType.value) {
                            case wcardinalUi.EShapeActionValueShowHideType.SHAPE:
                            case null:
                                return new wcardinalUi.EShapeActionValueShowHideShape(condition);
                            case wcardinalUi.EShapeActionValueShowHideType.LAYER:
                                return new wcardinalUi.EShapeActionValueShowHideLayer(condition, this.selectLayer.values.slice(0), this.checkBringToFront.state.isActive);
                        }
                        break;
                    case wcardinalUi.EShapeActionValueType.BLINK:
                        const blinkType = this.blinkType.value || wcardinalUi.EShapeActionValueBlinkType.VISIBILITY;
                        const interval = this.interval.value;
                        const blinkColor = this.color.value;
                        return new wcardinalUi.EShapeActionValueBlink(blinkType, condition, interval, blinkColor.color, blinkColor.alpha);
                    case wcardinalUi.EShapeActionValueType.CHANGE_COLOR:
                        const changeColorType = wcardinalUi.EShapeActionValueChangeColorTypes.pack(this.changeColorType.values);
                        const changeColorTarget = this.changeColorTarget.value ||
                            wcardinalUi.EShapeActionValueChangeColorTarget.COLOR_AND_ALPHA;
                        switch (changeColorTarget) {
                            case wcardinalUi.EShapeActionValueChangeColorTarget.COLOR_AND_ALPHA:
                            case wcardinalUi.EShapeActionValueChangeColorTarget.COLOR:
                            case wcardinalUi.EShapeActionValueChangeColorTarget.ALPHA:
                                const changeColor = this.color.value;
                                return new wcardinalUi.EShapeActionValueChangeColor(changeColorType, condition, changeColorTarget, changeColor.color, changeColor.alpha, this.blend.input.value);
                            case wcardinalUi.EShapeActionValueChangeColorTarget.CODE:
                                return new wcardinalUi.EShapeActionValueChangeColorCode(changeColorType, condition, this.colorCode.input.value, this.alphaCode.input.value, this.blend.input.value);
                            case wcardinalUi.EShapeActionValueChangeColorTarget.BRIGHTNESS:
                                return new wcardinalUi.EShapeActionValueChangeColorBrightness(changeColorType, condition, this.brightness.input.value);
                        }
                        break;
                    case wcardinalUi.EShapeActionValueType.TRANSFORM:
                        const transformType = this.transformType.value;
                        const originX = this.originX.value;
                        const originY = this.originY.value;
                        switch (transformType) {
                            case wcardinalUi.EShapeActionValueTransformType.RESIZE:
                                const resizeType = this.resizeType.value ||
                                    wcardinalUi.EShapeActionValueTransformResizeType.RELATIVE_SIZE;
                                return new wcardinalUi.EShapeActionValueTransformResize(resizeType, condition, originX, originY, this.size.input.value);
                            case wcardinalUi.EShapeActionValueTransformType.MOVE:
                                const moveType = this.moveType.value ||
                                    wcardinalUi.EShapeActionValueTransformMoveType.RELATIVE_X;
                                return new wcardinalUi.EShapeActionValueTransformMove(moveType, condition, this.amount.input.value);
                            case wcardinalUi.EShapeActionValueTransformType.ROTATE:
                                const rotateType = this.rotateType.value ||
                                    wcardinalUi.EShapeActionValueTransformRotateType.RELATIVE;
                                return new wcardinalUi.EShapeActionValueTransformRotate(rotateType, condition, originX, originY, this.amount.input.value);
                        }
                        break;
                    case wcardinalUi.EShapeActionValueType.CHANGE_TEXT:
                        const changeTextType = this.changeTextType.value || wcardinalUi.EShapeActionValueChangeTextType.TEXT;
                        return new wcardinalUi.EShapeActionValueChangeText(changeTextType, condition, this.contents.input.value);
                    case wcardinalUi.EShapeActionValueType.OPEN:
                        const openType = (_a = this.openType.value) !== null && _a !== void 0 ? _a : wcardinalUi.EShapeActionValueOpenType.DIAGRAM;
                        switch (openType) {
                            case wcardinalUi.EShapeActionValueOpenType.DIALOG:
                                const openDialogType = (_b = this.openDialogType.value) !== null && _b !== void 0 ? _b : wcardinalUi.EShapeActionValueOpenDialogType.TEXT;
                                switch (openDialogType) {
                                    case wcardinalUi.EShapeActionValueOpenDialogType.INTEGER:
                                    case wcardinalUi.EShapeActionValueOpenDialogType.REAL:
                                        return new wcardinalUi.EShapeActionValueOpenDialog(condition, this.target.input.value, (_c = this.onInputAction.value) !== null && _c !== void 0 ? _c : wcardinalUi.EShapeActionValueOnInputAction.EMIT_EVENT, this.initial.input.value, this.step.input.value, this.min.input.value, this.max.input.value, openDialogType);
                                    case wcardinalUi.EShapeActionValueOpenDialogType.TEXT:
                                    case wcardinalUi.EShapeActionValueOpenDialogType.BOOLEAN:
                                    case wcardinalUi.EShapeActionValueOpenDialogType.DATE:
                                    case wcardinalUi.EShapeActionValueOpenDialogType.TIME:
                                    case wcardinalUi.EShapeActionValueOpenDialogType.DATETIME:
                                        return new wcardinalUi.EShapeActionValueOpenDialog(condition, this.target.input.value, (_d = this.onInputAction.value) !== null && _d !== void 0 ? _d : wcardinalUi.EShapeActionValueOnInputAction.EMIT_EVENT, this.initial.input.value, "", "", "", openDialogType);
                                    default:
                                        return new wcardinalUi.EShapeActionValueOpenDialogExtension(condition, this.target.input.value, this.argument.input.value, openDialogType);
                                }
                            case wcardinalUi.EShapeActionValueOpenType.DIAGRAM:
                            case wcardinalUi.EShapeActionValueOpenType.PAGE:
                                return new wcardinalUi.EShapeActionValueOpen(openType, condition, this.target.input.value, this.inNewWindow.state.isActive);
                            default:
                                return new wcardinalUi.EShapeActionValueOpenExtension(openType, condition, this.target.input.value, this.inNewWindow.state.isActive);
                        }
                    case wcardinalUi.EShapeActionValueType.EMIT_EVENT:
                        return new wcardinalUi.EShapeActionValueEmitEvent(condition, this.targetName.input.value);
                    case wcardinalUi.EShapeActionValueType.CHANGE_CURSOR:
                        return new wcardinalUi.EShapeActionValueChangeCursor(condition, this.targetName.input.value);
                    case wcardinalUi.EShapeActionValueType.GESTURE:
                        return new wcardinalUi.EShapeActionValueGesture(condition, this.gestureType.value || wcardinalUi.EShapeActionValueGestureType.SHAPE, this.toGestureOperationType(this.gestureOperationType.values), this.scaleMin.value, this.scaleMax.value);
                    case wcardinalUi.EShapeActionValueType.MISC:
                        const miscType = this.miscType.value || wcardinalUi.EShapeActionValueMiscType.INPUT_TEXT;
                        switch (miscType) {
                            case wcardinalUi.EShapeActionValueMiscType.INPUT_TEXT:
                            case wcardinalUi.EShapeActionValueMiscType.INPUT_REAL:
                            case wcardinalUi.EShapeActionValueMiscType.INPUT_INTEGER:
                                return new wcardinalUi.EShapeActionValueMiscInput(miscType, this.toWhenTypeValue(this.whenType.value), this.target.input.value, this.onInputAction.value ||
                                    wcardinalUi.EShapeActionValueOnInputAction.EMIT_EVENT);
                            case wcardinalUi.EShapeActionValueMiscType.EMIT_EVENT:
                                return new wcardinalUi.EShapeActionValueMiscEmitEvent(condition, this.target.input.value);
                            case wcardinalUi.EShapeActionValueMiscType.WRITE_BOTH:
                            case wcardinalUi.EShapeActionValueMiscType.WRITE_LOCAL:
                            case wcardinalUi.EShapeActionValueMiscType.WRITE_REMOTE:
                                return new wcardinalUi.EShapeActionValueMiscWrite(miscType, condition, this.target.input.value, this.contents.input.value);
                            case wcardinalUi.EShapeActionValueMiscType.HTML_ELEMENT:
                                if (this.pointerEvents.state.isActive) {
                                    return new wcardinalUi.EShapeActionValueMiscHtmlElement(miscType, this.toWhenTypeValue(this.whenType.value), this.initialization.input.value);
                                }
                                else {
                                    return new wcardinalUi.EShapeActionValueMiscHtmlElement(wcardinalUi.EShapeActionValueMiscType.HTML_ELEMENT_WITHOUT_POINTER_EVENTS, this.toWhenTypeValue(this.whenType.value), this.initialization.input.value);
                                }
                            case wcardinalUi.EShapeActionValueMiscType.HTML_ELEMENT_WITHOUT_POINTER_EVENTS:
                                return new wcardinalUi.EShapeActionValueMiscHtmlElement(miscType, this.toWhenTypeValue(this.whenType.value), this.initialization.input.value);
                            case wcardinalUi.EShapeActionValueMiscType.EXECUTE:
                                return new wcardinalUi.EShapeActionValueMiscExecute(condition, this.target.input.value);
                            default:
                                if (wcardinalUi.EShapeActionValueMiscType.EXTENSION <= miscType) {
                                    return new wcardinalUi.EShapeActionValueMiscExtension(miscType, condition, this.argument.input.value);
                                }
                        }
                        break;
                    default:
                        return this.extension.value;
                }
            }
            return null;
        }
        set value(value) {
            this.selectLayer.menu = new wcardinalUi.DMenu({
                fit: true,
                items: this.newSelectLayerMenuItemOptions()
            });
            if (value != null) {
                this.select.value = value.type;
                if (value instanceof wcardinalUi.EShapeActionValueShowHide) {
                    this.condition.input.value = value.condition;
                    this.showHideType.value = wcardinalUi.EShapeActionValueShowHideType.SHAPE;
                }
                else if (value instanceof wcardinalUi.EShapeActionValueShowHideShape) {
                    this.condition.input.value = value.condition;
                    this.showHideType.value = value.subtype;
                }
                else if (value instanceof wcardinalUi.EShapeActionValueShowHideLayer) {
                    this.condition.input.value = value.condition;
                    this.showHideType.value = value.subtype;
                    this.selectLayer.values = value.layers.slice(0);
                    this.checkBringToFront.state.isActive = value.bringToFront;
                }
                else if (value instanceof wcardinalUi.EShapeActionValueBlink) {
                    this.condition.input.value = value.condition;
                    this.blinkType.value = value.subtype;
                    this.interval.value = value.interval;
                    this.color.value.color = value.color;
                    this.color.value.alpha = value.alpha;
                }
                else if (value instanceof wcardinalUi.EShapeActionValueChangeColor) {
                    this.condition.input.value = value.condition;
                    this.changeColorType.values = wcardinalUi.EShapeActionValueChangeColorTypes.unpack(value.subtype);
                    this.changeColorTarget.value = value.target;
                    this.color.value.color = value.color;
                    this.color.value.alpha = value.alpha;
                    this.blend.input.value = value.blend;
                }
                else if (value instanceof wcardinalUi.EShapeActionValueChangeColorCode) {
                    this.condition.input.value = value.condition;
                    this.changeColorType.values = wcardinalUi.EShapeActionValueChangeColorTypes.unpack(value.subtype);
                    this.changeColorTarget.value = wcardinalUi.EShapeActionValueChangeColorTarget.CODE;
                    this.colorCode.input.value = value.color;
                    this.alphaCode.input.value = value.alpha;
                    this.blend.input.value = value.blend;
                }
                else if (value instanceof wcardinalUi.EShapeActionValueChangeColorBrightness) {
                    this.condition.input.value = value.condition;
                    this.changeColorType.values = wcardinalUi.EShapeActionValueChangeColorTypes.unpack(value.subtype);
                    this.changeColorTarget.value = wcardinalUi.EShapeActionValueChangeColorTarget.BRIGHTNESS;
                    this.brightness.input.value = value.brightness;
                }
                else if (value instanceof wcardinalUi.EShapeActionValueTransformResize) {
                    this.condition.input.value = value.condition;
                    this.transformType.value = wcardinalUi.EShapeActionValueTransformType.RESIZE;
                    this.resizeType.value = value.opetype;
                    this.originX.value = value.originX;
                    this.originY.value = value.originY;
                    this.size.input.value = value.amount;
                }
                else if (value instanceof wcardinalUi.EShapeActionValueTransformMove) {
                    this.condition.input.value = value.condition;
                    this.transformType.value = wcardinalUi.EShapeActionValueTransformType.MOVE;
                    this.moveType.value = value.opetype;
                    this.amount.input.value = value.amount;
                }
                else if (value instanceof wcardinalUi.EShapeActionValueTransformRotate) {
                    this.condition.input.value = value.condition;
                    this.transformType.value = wcardinalUi.EShapeActionValueTransformType.ROTATE;
                    this.rotateType.value = value.opetype;
                    this.originX.value = value.originX;
                    this.originY.value = value.originY;
                    this.amount.input.value = value.amount;
                }
                else if (value instanceof wcardinalUi.EShapeActionValueChangeText) {
                    this.condition.input.value = value.condition;
                    this.changeTextType.value = value.subtype;
                    this.contents.input.value = value.value;
                }
                else if (value instanceof wcardinalUi.EShapeActionValueOpen) {
                    this.condition.input.value = value.condition;
                    this.openType.value = value.subtype;
                    this.target.input.value = value.target;
                    this.inNewWindow.state.isActive = value.inNewWindow;
                }
                else if (value instanceof wcardinalUi.EShapeActionValueOpenDialog) {
                    this.condition.input.value = value.condition;
                    this.openType.value = value.subtype;
                    this.target.input.value = value.target;
                    this.onInputAction.value = value.onInputAction;
                    this.initial.input.value = value.initial;
                    this.step.input.value = value.step;
                    this.min.input.value = value.min;
                    this.max.input.value = value.max;
                    this.openDialogType.value = value.dialogType;
                }
                else if (value instanceof wcardinalUi.EShapeActionValueOpenDialogExtension) {
                    this.condition.input.value = value.condition;
                    this.openType.value = value.subtype;
                    this.target.input.value = value.target;
                    this.argument.input.value = value.argument;
                    this.openDialogType.value = value.dialogType;
                }
                else if (value instanceof wcardinalUi.EShapeActionValueOpenExtension) {
                    this.condition.input.value = value.condition;
                    this.openType.value = value.subtype;
                    this.target.input.value = value.target;
                    this.inNewWindow.state.isActive = value.inNewWindow;
                }
                else if (value instanceof wcardinalUi.EShapeActionValueEmitEvent) {
                    this.condition.input.value = value.condition;
                    this.targetName.input.value = value.name;
                }
                else if (value instanceof wcardinalUi.EShapeActionValueChangeCursor) {
                    this.condition.input.value = value.condition;
                    this.targetName.input.value = value.name;
                }
                else if (value instanceof wcardinalUi.EShapeActionValueGesture) {
                    this.condition.input.value = value.condition;
                    this.gestureType.value = value.subtype;
                    this.gestureOperationType.values = this.fromGestureOperationType(value.operationType);
                    this.scaleMin.value = value.scaleMin;
                    this.scaleMax.value = value.scaleMax;
                }
                else if (value instanceof wcardinalUi.EShapeActionValueMisc) {
                    switch (value.subtype) {
                        case wcardinalUi.EShapeActionValueMiscType.INPUT_TEXT:
                        case wcardinalUi.EShapeActionValueMiscType.INPUT_REAL:
                        case wcardinalUi.EShapeActionValueMiscType.INPUT_INTEGER:
                            this.miscType.value = value.subtype;
                            this.whenType.value = this.toWhenType(value.condition);
                            this.target.input.value = value.target;
                            this.onInputAction.value = value.onInputAction;
                            this.contents.input.value = value.value;
                            break;
                        case wcardinalUi.EShapeActionValueMiscType.HTML_ELEMENT:
                            this.miscType.value = wcardinalUi.EShapeActionValueMiscType.HTML_ELEMENT;
                            this.whenType.value = this.toWhenType(value.condition);
                            this.target.input.value = value.target;
                            this.onInputAction.value = value.onInputAction;
                            this.initialization.input.value = value.value;
                            this.pointerEvents.state.isActive = true;
                            break;
                        case wcardinalUi.EShapeActionValueMiscType.HTML_ELEMENT_WITHOUT_POINTER_EVENTS:
                            this.miscType.value = wcardinalUi.EShapeActionValueMiscType.HTML_ELEMENT;
                            this.whenType.value = this.toWhenType(value.condition);
                            this.target.input.value = value.target;
                            this.onInputAction.value = value.onInputAction;
                            this.initialization.input.value = value.value;
                            this.pointerEvents.state.isActive = false;
                            break;
                        default:
                            this.condition.input.value = value.condition;
                            this.miscType.value = value.subtype;
                            this.target.input.value = value.target;
                            this.onInputAction.value = value.onInputAction;
                            this.contents.input.value = value.value;
                            break;
                    }
                }
                else if (value instanceof wcardinalUi.EShapeActionValueMiscExecute) {
                    this.miscType.value = wcardinalUi.EShapeActionValueMiscType.EXECUTE;
                    this.condition.input.value = value.condition;
                    this.target.input.value = value.target;
                }
                else if (value instanceof wcardinalUi.EShapeActionValueMiscExtension) {
                    this.miscType.value = wcardinalUi.EShapeActionValueMiscType.EXTENSION;
                    this.condition.input.value = value.condition;
                    this.argument.input.value = value.argument;
                }
                else {
                    this.extension.value = value;
                }
                this.onChange();
            }
        }
        getResolvedValue() {
            return this.value;
        }
        getType() {
            return "EDialogAction";
        }
    }

    class EDialogDataMappingValue extends wcardinalUi.DDialogLayered {
        newContentChildren(theme, options) {
            const result = super.newContentChildren(theme, options);
            result.push(this.inputSource, this.inputDestination, this.inputInitial, new wcardinalUi.DLayoutSpace({
                height: 6
            }), this.table);
            return result;
        }
        get inputSource() {
            let result = this._inputSource;
            if (result == null) {
                result = this.newInputSource();
                this._inputSource = result;
            }
            return result;
        }
        newInputSource() {
            return new wcardinalUi.DInputTextAndLabel({
                width: "padding",
                height: "auto",
                input: {
                    weight: 1,
                    on: {
                        input: (value) => {
                            this.onInputSourceChanged(value);
                        },
                        enter: () => {
                            this.ok();
                        }
                    }
                },
                label: {
                    width: 60,
                    text: {
                        value: this.theme.getInputSourceLabel()
                    }
                },
                space: {
                    width: 60
                }
            });
        }
        onInputSourceChanged(value) {
            this._newSource = value;
            this.updateRows();
        }
        get inputDestination() {
            let result = this._inputDestination;
            if (result == null) {
                result = this.newInputDestination();
                this._inputDestination = result;
            }
            return result;
        }
        newInputDestination() {
            return new wcardinalUi.DInputTextAndLabel({
                width: "padding",
                height: "auto",
                input: {
                    weight: 1,
                    text: {
                        value: ""
                    },
                    on: {
                        input: (value) => {
                            this.onInputDestinationChanged(value);
                        },
                        enter: () => {
                            this.ok();
                        }
                    }
                },
                label: {
                    width: 60,
                    text: {
                        value: this.theme.getInputDestinationLabel()
                    }
                },
                space: {
                    width: 60
                }
            });
        }
        onInputDestinationChanged(value) {
            this._newDestination = value;
            this.updateRows();
        }
        get inputInitial() {
            let result = this._inputInitial;
            if (result == null) {
                result = this.newInputInitial();
                this._inputInitial = result;
            }
            return result;
        }
        newInputInitial() {
            return new wcardinalUi.DInputTextAndLabel({
                width: "padding",
                height: "auto",
                input: {
                    weight: 1,
                    text: {
                        value: ""
                    },
                    on: {
                        enter: () => {
                            this.ok();
                        }
                    }
                },
                label: {
                    width: 60,
                    text: {
                        value: this.theme.getInputInitialLabel()
                    }
                },
                space: {
                    width: 60
                }
            });
        }
        get table() {
            let result = this._table;
            if (result == null) {
                result = this.newTable();
                this._table = result;
            }
            return result;
        }
        newTable() {
            return new wcardinalUi.DTable({
                width: "padding",
                height: 300,
                columns: this.newColumnOptions()
            });
        }
        newColumnOptions() {
            const theme = this.theme;
            return [
                {
                    type: "TEXT",
                    label: theme.getTableColumnDataIdLabel(),
                    editable: false,
                    sortable: true,
                    getter: (row) => {
                        return row.id;
                    }
                },
                {
                    type: "TEXT",
                    label: theme.getTableColumnMappedToLabel(),
                    editable: false,
                    sortable: true,
                    getter: (row) => {
                        return row.mappedId;
                    }
                }
            ];
        }
        set(value, shape) {
            let isChanged = false;
            if (value !== undefined) {
                if (value != null) {
                    this.inputSource.input.value = value[0];
                    this.inputDestination.input.value = value[1];
                    this.inputInitial.input.value = value[2];
                    this._newSource = value[0];
                    this._newDestination = value[1];
                }
                else {
                    this.inputSource.input.value = "";
                    this.inputDestination.input.value = "";
                    this.inputInitial.input.value = "";
                    this._newSource = "";
                    this._newDestination = "";
                }
                isChanged = true;
            }
            if (shape !== undefined) {
                this._ids = this.toIds(shape);
                isChanged = true;
            }
            if (isChanged) {
                this.updateRows();
            }
            return this;
        }
        get value() {
            return [
                this.inputSource.input.value.trim(),
                this.inputDestination.input.value.trim(),
                this.inputInitial.input.value.trim()
            ];
        }
        set value(value) {
            this.set(value);
        }
        getResolvedValue() {
            return this.value;
        }
        toIds(shape) {
            const result = [];
            if (shape != null) {
                const ids = new Set();
                this.newIds(shape.children, ids);
                ids.forEach((id) => {
                    result.push(id);
                });
                result.sort();
            }
            return result;
        }
        newIds(shapes, result) {
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                const data = shape.data;
                for (let j = 0, jmax = data.size(); j < jmax; ++j) {
                    const value = data.get(j);
                    if (value && value.scope !== wcardinalUi.EShapeDataValueScope.PRIVATE) {
                        result.add(value.id);
                    }
                }
                const children = shape.children;
                if (0 < children.length) {
                    this.newIds(children, result);
                }
            }
        }
        get onUpdateRowsBound() {
            let result = this._onUpdateRowsBound;
            if (result == null) {
                result = this.newOnUpdateRowsBound();
                this._onUpdateRowsBound = result;
            }
            return result;
        }
        newOnUpdateRowsBound() {
            return () => {
                this.onUpdateRows();
            };
        }
        onUpdateRows() {
            this._onUpdateRowsTimeout = undefined;
            if (this._isRowsDirty) {
                this._isRowsDirty = false;
                this.table.data.clearAndAddAll(this.newRows());
                this._onUpdateRowsTimeout = window.setTimeout(this.onUpdateRowsBound, 100);
            }
        }
        newRows() {
            const ids = this._ids;
            if (ids == null || ids.length <= 0) {
                return [];
            }
            // Source
            let mapper = this._mapper;
            const newSource = this._newSource;
            if (mapper === undefined || this._lastSource !== newSource) {
                this._lastSource = newSource;
                if (newSource != null) {
                    const newSourceTrimmed = newSource.trim();
                    if (0 < newSourceTrimmed.length) {
                        mapper = new wcardinalUi.EShapeDataMapperImpl(newSource);
                    }
                    else {
                        mapper = null;
                    }
                }
                else {
                    mapper = null;
                }
            }
            // Destination
            let destinations = this._destinations;
            const newDestination = this._newDestination;
            if (destinations === undefined || this._lastDestination !== newDestination) {
                this._lastDestination = newDestination;
                destinations = wcardinalUi.EShapeDataMapperImpl.split(newDestination);
            }
            // Rows
            const result = [];
            if (mapper != null) {
                const value = new wcardinalUi.EShapeDataValueImpl();
                value.initial = "";
                for (let i = 0, imax = ids.length; i < imax; ++i) {
                    const id = ids[i];
                    value.id = id;
                    if (mapper.map(value, destinations, "")) {
                        result.push({
                            id: id,
                            mappedId: value.id
                        });
                    }
                }
            }
            else {
                for (let i = 0, imax = ids.length; i < imax; ++i) {
                    const id = ids[i];
                    result.push({
                        id: id,
                        mappedId: id
                    });
                }
            }
            return result;
        }
        updateRows() {
            this._isRowsDirty = true;
            if (this._onUpdateRowsTimeout == null) {
                this.onUpdateRows();
            }
        }
        getType() {
            return "EDialogDataMappingValue";
        }
    }

    class EDialogDataValue extends wcardinalUi.DDialogLayered {
        newContentChildren(theme, options) {
            const result = super.newContentChildren(theme, options);
            result.push(this.layoutType, this.layoutScope, this.inputId, this.inputAs, this.inputInitial, this.layoutInterval, this.inputFormat, this.layoutRangeType, this.inputRangeFrom, this.inputRangeTo, this.inputCapacity, this.layoutOrder);
            return result;
        }
        get inputId() {
            let result = this._inputId;
            if (result == null) {
                result = this.newInputId();
                this._inputId = result;
            }
            return result;
        }
        newInputId() {
            return new wcardinalUi.DInputTextAndLabel({
                width: "padding",
                height: "auto",
                input: {
                    weight: 1,
                    on: {
                        enter: () => {
                            this.ok();
                        }
                    }
                },
                label: {
                    width: 60,
                    text: {
                        value: this.theme.getInputIdLabel()
                    }
                },
                space: {
                    width: 60
                }
            });
        }
        get inputAs() {
            let result = this._inputAs;
            if (result == null) {
                result = this.newInputAs();
                this._inputAs = result;
            }
            return result;
        }
        newInputAs() {
            return new wcardinalUi.DInputTextAndLabel({
                width: "padding",
                height: "auto",
                input: {
                    weight: 1,
                    on: {
                        enter: () => {
                            this.ok();
                        }
                    }
                },
                label: {
                    width: 60,
                    text: {
                        value: this.theme.getInputAsLabel()
                    }
                },
                space: {
                    width: 60
                }
            });
        }
        get layoutType() {
            let result = this._layoutType;
            if (result == null) {
                result = this.newLayoutType();
                this._layoutType = result;
            }
            return result;
        }
        newLayoutType() {
            return new wcardinalUi.DLayoutHorizontal({
                width: "padding",
                height: "auto",
                children: [
                    new wcardinalUi.DInputLabel({
                        width: 60,
                        text: {
                            value: this.theme.getSelectTypeLabel()
                        }
                    }),
                    this.selectType,
                    new wcardinalUi.DLayoutSpace({
                        width: 60
                    })
                ]
            });
        }
        get selectType() {
            let result = this._selectType;
            if (result == null) {
                result = this.newSelectType();
                result.on("change", () => {
                    this.onChange();
                });
                this._selectType = result;
            }
            return result;
        }
        newSelectType() {
            return new wcardinalUi.DSelect({
                weight: 1,
                value: wcardinalUi.EShapeDataValueType.NUMBER,
                menu: {
                    items: this.newSelectTypeItems()
                }
            });
        }
        newSelectTypeItems() {
            const theme = this.theme;
            const result = [
                {
                    value: wcardinalUi.EShapeDataValueType.BOOLEAN,
                    text: {
                        value: theme.getSelectTypeValueLabel(wcardinalUi.EShapeDataValueType.BOOLEAN)
                    }
                },
                {
                    value: wcardinalUi.EShapeDataValueType.BOOLEAN_ARRAY,
                    text: {
                        value: theme.getSelectTypeValueLabel(wcardinalUi.EShapeDataValueType.BOOLEAN_ARRAY)
                    }
                },
                {
                    value: wcardinalUi.EShapeDataValueType.NUMBER,
                    text: {
                        value: theme.getSelectTypeValueLabel(wcardinalUi.EShapeDataValueType.NUMBER)
                    }
                },
                {
                    value: wcardinalUi.EShapeDataValueType.NUMBER_ARRAY,
                    text: {
                        value: theme.getSelectTypeValueLabel(wcardinalUi.EShapeDataValueType.NUMBER_ARRAY)
                    }
                },
                {
                    value: wcardinalUi.EShapeDataValueType.STRING,
                    text: {
                        value: theme.getSelectTypeValueLabel(wcardinalUi.EShapeDataValueType.STRING)
                    }
                },
                {
                    value: wcardinalUi.EShapeDataValueType.STRING_ARRAY,
                    text: {
                        value: theme.getSelectTypeValueLabel(wcardinalUi.EShapeDataValueType.STRING_ARRAY)
                    }
                },
                {
                    value: wcardinalUi.EShapeDataValueType.OBJECT,
                    text: {
                        value: theme.getSelectTypeValueLabel(wcardinalUi.EShapeDataValueType.OBJECT)
                    }
                },
                {
                    value: wcardinalUi.EShapeDataValueType.OBJECT_ARRAY,
                    text: {
                        value: theme.getSelectTypeValueLabel(wcardinalUi.EShapeDataValueType.OBJECT_ARRAY)
                    }
                },
                {
                    value: wcardinalUi.EShapeDataValueType.TICKER,
                    text: {
                        value: theme.getSelectTypeValueLabel(wcardinalUi.EShapeDataValueType.TICKER)
                    }
                }
            ];
            wcardinalUi.EShapeDataValueExtensions.each((extension) => {
                result.push({
                    value: extension.type,
                    text: {
                        value: extension.label
                    }
                });
            });
            return result;
        }
        get layoutScope() {
            let result = this._layoutScope;
            if (result == null) {
                result = this.newLayoutScope();
                this._layoutScope = result;
            }
            return result;
        }
        newLayoutScope() {
            return new wcardinalUi.DLayoutHorizontal({
                width: "padding",
                height: "auto",
                children: [
                    new wcardinalUi.DInputLabel({
                        width: 60,
                        text: {
                            value: this.theme.getSelectScopeLabel()
                        }
                    }),
                    this.selectScope,
                    new wcardinalUi.DLayoutSpace({
                        width: 60
                    })
                ]
            });
        }
        get selectScope() {
            let result = this._selectScope;
            if (result == null) {
                result = this.newSelectScope();
                this._selectScope = result;
            }
            return result;
        }
        newSelectScope() {
            const theme = this.theme;
            return new wcardinalUi.DSelect({
                weight: 1,
                value: wcardinalUi.EShapeDataValueScope.PUBLIC,
                menu: {
                    items: [
                        {
                            value: wcardinalUi.EShapeDataValueScope.PUBLIC,
                            text: {
                                value: theme.getSelectScopeValueLabel(wcardinalUi.EShapeDataValueScope.PUBLIC)
                            }
                        },
                        {
                            value: wcardinalUi.EShapeDataValueScope.PROTECTED,
                            text: {
                                value: theme.getSelectScopeValueLabel(wcardinalUi.EShapeDataValueScope.PROTECTED)
                            }
                        },
                        {
                            value: wcardinalUi.EShapeDataValueScope.PRIVATE,
                            text: {
                                value: theme.getSelectScopeValueLabel(wcardinalUi.EShapeDataValueScope.PRIVATE)
                            }
                        }
                    ]
                }
            });
        }
        get inputInitial() {
            let result = this._inputInitial;
            if (result == null) {
                result = this.newInputInitial();
                this._inputInitial = result;
            }
            return result;
        }
        newInputInitial() {
            return new wcardinalUi.DInputTextAndLabel({
                width: "padding",
                height: "auto",
                input: {
                    weight: 1,
                    text: {
                        value: ""
                    },
                    on: {
                        enter: () => {
                            this.ok();
                        }
                    }
                },
                label: {
                    width: 60,
                    text: {
                        value: this.theme.getInputInitialLabel()
                    }
                },
                space: {
                    width: 60
                }
            });
        }
        get layoutInterval() {
            let result = this._layoutInterval;
            if (result == null) {
                result = this.newLayoutInterval();
                this._layoutInterval = result;
            }
            return result;
        }
        newLayoutInterval() {
            const theme = this.theme;
            return new wcardinalUi.DLayoutHorizontal({
                width: "padding",
                height: "auto",
                children: [
                    new wcardinalUi.DInputLabel({
                        width: 60,
                        text: {
                            value: theme.getInputIntervalLabel()
                        }
                    }),
                    this.inputInterval,
                    new wcardinalUi.DInputLabel({
                        width: 60,
                        text: {
                            value: theme.getInputIntervalUnitLabel(),
                            align: {
                                horizontal: "LEFT"
                            }
                        }
                    })
                ]
            });
        }
        get inputInterval() {
            let result = this._inputInterval;
            if (result == null) {
                result = this.newInputInterval();
                this._inputInterval = result;
            }
            return result;
        }
        newInputInterval() {
            return new wcardinalUi.DInputInteger({
                weight: 1,
                text: {
                    value: 1000
                },
                step: 1,
                min: 0,
                on: {
                    enter: () => {
                        this.ok();
                    }
                }
            });
        }
        get inputFormat() {
            let result = this._inputFormat;
            if (result == null) {
                result = this.newInputFormat();
                this._inputFormat = result;
            }
            return result;
        }
        newInputFormat() {
            return new wcardinalUi.DInputTextAndLabel({
                width: "padding",
                height: "auto",
                input: {
                    weight: 1,
                    text: {
                        value: ""
                    },
                    on: {
                        enter: () => {
                            this.ok();
                        }
                    }
                },
                label: {
                    width: 60,
                    text: {
                        value: this.theme.getInputFormatLabel()
                    }
                },
                space: {
                    width: 60
                }
            });
        }
        get layoutRangeType() {
            let result = this._layoutRangeType;
            if (result == null) {
                result = this.newLayoutRangeType();
                this._layoutRangeType = result;
            }
            return result;
        }
        newLayoutRangeType() {
            return new wcardinalUi.DLayoutHorizontal({
                width: "padding",
                height: "auto",
                children: [
                    new wcardinalUi.DInputLabel({
                        width: 60,
                        text: {
                            value: this.theme.getSelectRangeTypeLabel()
                        }
                    }),
                    this.selectRangeType,
                    new wcardinalUi.DLayoutSpace({
                        width: 60
                    })
                ]
            });
        }
        get selectRangeType() {
            let result = this._selectRangeType;
            if (result == null) {
                result = this.newSelectRangeType();
                result.on("change", () => {
                    this.onChange();
                });
                this._selectRangeType = result;
            }
            return result;
        }
        newSelectRangeType() {
            const theme = this.theme;
            return new wcardinalUi.DSelect({
                weight: 1,
                value: wcardinalUi.EShapeDataValueRangeType.NONE,
                menu: {
                    items: [
                        {
                            value: wcardinalUi.EShapeDataValueRangeType.NONE,
                            text: {
                                value: theme.getSelectRangeTypeValueLabel(wcardinalUi.EShapeDataValueRangeType.NONE)
                            }
                        },
                        {
                            value: wcardinalUi.EShapeDataValueRangeType.FROM,
                            text: {
                                value: theme.getSelectRangeTypeValueLabel(wcardinalUi.EShapeDataValueRangeType.FROM)
                            }
                        },
                        {
                            value: wcardinalUi.EShapeDataValueRangeType.TO,
                            text: {
                                value: theme.getSelectRangeTypeValueLabel(wcardinalUi.EShapeDataValueRangeType.TO)
                            }
                        },
                        {
                            value: wcardinalUi.EShapeDataValueRangeType.FROM_TO,
                            text: {
                                value: theme.getSelectRangeTypeValueLabel(wcardinalUi.EShapeDataValueRangeType.FROM_TO)
                            }
                        }
                    ]
                }
            });
        }
        get inputRangeFrom() {
            let result = this._inputRangeFrom;
            if (result == null) {
                result = this.newInputRangeFrom();
                this._inputRangeFrom = result;
            }
            return result;
        }
        newInputRangeFrom() {
            return new wcardinalUi.DInputRealAndLabel({
                width: "padding",
                height: "auto",
                visible: false,
                input: {
                    weight: 1,
                    text: {
                        value: 0
                    },
                    on: {
                        enter: () => {
                            this.ok();
                        }
                    }
                },
                label: {
                    width: 90,
                    text: {
                        value: this.theme.getInputRangeFromLabel()
                    }
                },
                space: {
                    width: 90
                }
            });
        }
        get inputRangeTo() {
            let result = this._inputRangeTo;
            if (result == null) {
                result = this.newInputRangeTo();
                this._inputRangeTo = result;
            }
            return result;
        }
        newInputRangeTo() {
            return new wcardinalUi.DInputRealAndLabel({
                width: "padding",
                height: "auto",
                visible: false,
                input: {
                    weight: 1,
                    text: {
                        value: 1
                    },
                    on: {
                        enter: () => {
                            this.ok();
                        }
                    }
                },
                label: {
                    width: 90,
                    text: {
                        value: this.theme.getInputRangeToLabel()
                    }
                },
                space: {
                    width: 90
                }
            });
        }
        get inputCapacity() {
            let result = this._inputCapacity;
            if (result == null) {
                result = this.newInputCapacity();
                this._inputCapacity = result;
            }
            return result;
        }
        newInputCapacity() {
            return new wcardinalUi.DInputIntegerAndLabel({
                width: "padding",
                height: "auto",
                input: {
                    weight: 1,
                    text: {
                        value: 0
                    },
                    on: {
                        enter: () => {
                            this.ok();
                        }
                    }
                },
                label: {
                    width: 60,
                    text: {
                        value: this.theme.getInputCapacityLabel()
                    }
                },
                space: {
                    width: 60
                }
            });
        }
        get layoutOrder() {
            let result = this._layoutOrder;
            if (result == null) {
                result = this.newLayoutOrder();
                this._layoutOrder = result;
            }
            return result;
        }
        newLayoutOrder() {
            return new wcardinalUi.DLayoutHorizontal({
                width: "padding",
                height: "auto",
                children: [
                    new wcardinalUi.DInputLabel({
                        width: 60,
                        text: {
                            value: this.theme.getSelectOrderLabel()
                        }
                    }),
                    this.selectOrder,
                    new wcardinalUi.DLayoutSpace({
                        width: 60
                    })
                ]
            });
        }
        get selectOrder() {
            let result = this._selectOrder;
            if (result == null) {
                result = this.newSelectOrder();
                this._selectOrder = result;
            }
            return result;
        }
        newSelectOrder() {
            const theme = this.theme;
            return new wcardinalUi.DSelect({
                weight: 1,
                value: wcardinalUi.EShapeDataValueOrder.ASCENDING,
                menu: {
                    items: [
                        {
                            value: wcardinalUi.EShapeDataValueOrder.ASCENDING,
                            text: {
                                value: theme.getSelectOrderValueLabel(wcardinalUi.EShapeDataValueOrder.ASCENDING)
                            }
                        },
                        {
                            value: wcardinalUi.EShapeDataValueOrder.DESCENDING,
                            text: {
                                value: theme.getSelectOrderValueLabel(wcardinalUi.EShapeDataValueOrder.DESCENDING)
                            }
                        }
                    ]
                },
                on: {
                    init: (self) => {
                        this._selectOrder = self;
                    }
                }
            });
        }
        onChange() {
            const type = this.selectType.value;
            switch (type) {
                case wcardinalUi.EShapeDataValueType.BOOLEAN:
                case wcardinalUi.EShapeDataValueType.BOOLEAN_ARRAY:
                case wcardinalUi.EShapeDataValueType.NUMBER:
                case wcardinalUi.EShapeDataValueType.NUMBER_ARRAY:
                case wcardinalUi.EShapeDataValueType.STRING:
                case wcardinalUi.EShapeDataValueType.STRING_ARRAY:
                case wcardinalUi.EShapeDataValueType.OBJECT:
                case wcardinalUi.EShapeDataValueType.OBJECT_ARRAY:
                    this.layoutScope.show();
                    this.inputId.show();
                    this.inputAs.show();
                    this.inputInitial.show();
                    this.layoutInterval.hide();
                    this.inputFormat.show();
                    if (type === wcardinalUi.EShapeDataValueType.NUMBER) {
                        this.layoutRangeType.show();
                        const rangeType = this.selectRangeType.value;
                        if (rangeType != null && (rangeType & wcardinalUi.EShapeDataValueRangeType.FROM) !== 0) {
                            this.inputRangeFrom.show();
                        }
                        else {
                            this.inputRangeFrom.hide();
                        }
                        if (rangeType != null && (rangeType & wcardinalUi.EShapeDataValueRangeType.TO) !== 0) {
                            this.inputRangeTo.show();
                        }
                        else {
                            this.inputRangeTo.hide();
                        }
                    }
                    else {
                        this.layoutRangeType.hide();
                        this.inputRangeFrom.hide();
                        this.inputRangeTo.hide();
                    }
                    break;
                case wcardinalUi.EShapeDataValueType.TICKER:
                    this.layoutScope.hide();
                    this.inputId.hide();
                    this.inputAs.show();
                    this.inputInitial.hide();
                    this.layoutInterval.show();
                    this.inputFormat.hide();
                    this.layoutRangeType.hide();
                    this.inputRangeFrom.hide();
                    this.inputRangeTo.hide();
                    break;
                default:
                    this.layoutScope.hide();
                    this.inputId.hide();
                    this.inputAs.show();
                    this.inputInitial.hide();
                    this.layoutInterval.hide();
                    this.inputFormat.hide();
                    this.layoutRangeType.hide();
                    this.inputRangeFrom.hide();
                    this.inputRangeTo.hide();
                    break;
            }
        }
        reset() {
            this.selectType.value = wcardinalUi.EShapeDataValueType.NUMBER;
            this.selectScope.value = wcardinalUi.EShapeDataValueScope.PUBLIC;
            this.inputId.input.value = "";
            this.inputAs.input.value = "";
            this.inputInitial.input.value = "";
            this.inputInterval.value = 1000;
            this.inputFormat.input.value = "";
            this.selectRangeType.value = wcardinalUi.EShapeDataValueRangeType.NONE;
            this.inputRangeFrom.input.value = 0;
            this.inputRangeTo.input.value = 1;
            this.inputCapacity.input.value = 0;
            this.selectOrder.value = wcardinalUi.EShapeDataValueOrder.ASCENDING;
            this.onChange();
            return this;
        }
        get value() {
            var _a, _b, _c, _d;
            const result = new wcardinalUi.EShapeDataValueImpl();
            const type = (_a = this.selectType.value) !== null && _a !== void 0 ? _a : wcardinalUi.EShapeDataValueType.NUMBER;
            const scope = (_b = this.selectScope.value) !== null && _b !== void 0 ? _b : wcardinalUi.EShapeDataValueScope.PUBLIC;
            const order = (_c = this.selectOrder.value) !== null && _c !== void 0 ? _c : wcardinalUi.EShapeDataValueOrder.ASCENDING;
            result.type = type;
            switch (type) {
                case wcardinalUi.EShapeDataValueType.BOOLEAN:
                case wcardinalUi.EShapeDataValueType.BOOLEAN_ARRAY:
                case wcardinalUi.EShapeDataValueType.NUMBER:
                case wcardinalUi.EShapeDataValueType.NUMBER_ARRAY:
                case wcardinalUi.EShapeDataValueType.STRING:
                case wcardinalUi.EShapeDataValueType.STRING_ARRAY:
                case wcardinalUi.EShapeDataValueType.OBJECT:
                case wcardinalUi.EShapeDataValueType.OBJECT_ARRAY:
                    result.scope = scope;
                    result.id = this.inputId.input.value.trim();
                    result.as = this.inputAs.input.value.trim();
                    result.initial = this.inputInitial.input.value.trim();
                    result.format = this.inputFormat.input.value.trim();
                    if (type === wcardinalUi.EShapeDataValueType.NUMBER) {
                        result.range.type = (_d = this.selectRangeType.value) !== null && _d !== void 0 ? _d : wcardinalUi.EShapeDataValueRangeType.NONE;
                        result.range.from = this.inputRangeFrom.input.value;
                        result.range.to = this.inputRangeTo.input.value;
                    }
                    else {
                        result.range.type = wcardinalUi.EShapeDataValueRangeType.NONE;
                        result.range.from = 0;
                        result.range.to = 1;
                    }
                    result.order = order;
                    break;
                case wcardinalUi.EShapeDataValueType.TICKER:
                    result.scope = wcardinalUi.EShapeDataValueScope.PUBLIC;
                    result.id = "";
                    result.as = this.inputAs.input.value.trim();
                    result.initial = `${this.inputInterval.value}`;
                    result.format = "";
                    result.range.type = wcardinalUi.EShapeDataValueRangeType.NONE;
                    result.range.from = 0;
                    result.range.to = 1;
                    result.order = order;
                    break;
                default:
                    result.scope = wcardinalUi.EShapeDataValueScope.PUBLIC;
                    result.id = "";
                    result.as = this.inputAs.input.value.trim();
                    result.initial = "";
                    result.format = "";
                    result.range.type = wcardinalUi.EShapeDataValueRangeType.NONE;
                    result.range.from = 0;
                    result.range.to = 1;
                    result.order = order;
                    break;
            }
            return result;
        }
        set value(value) {
            if (value != null) {
                this.selectType.value = value.type;
                this.selectScope.value = value.scope;
                this.inputId.input.value = value.id;
                this.inputAs.input.value = value.as;
                if (value.type === wcardinalUi.EShapeDataValueType.TICKER) {
                    this.inputInitial.input.value = "";
                    this.inputInterval.value = this.toInterval(value.initial);
                }
                else {
                    this.inputInitial.input.value = value.initial;
                    this.inputInterval.value = 1000;
                }
                this.inputFormat.input.value = value.format;
                this.selectRangeType.value = value.range.type;
                this.inputRangeFrom.input.value = value.range.from;
                this.inputRangeTo.input.value = value.range.to;
                this.inputCapacity.input.value = value.capacity;
                this.selectOrder.value = value.order;
                this.onChange();
            }
        }
        toInterval(target) {
            try {
                const result = parseInt(target, 10);
                if (result === result) {
                    return Math.max(0, result);
                }
            }
            catch (_a) {
                // DO NOTHING
            }
            return 1000;
        }
        getResolvedValue() {
            return this.value;
        }
        getType() {
            return "EDialogDataValue";
        }
    }

    class EDialogLayer extends wcardinalUi.DDialogLayered {
        newContentChildren(theme, options) {
            const result = super.newContentChildren(theme, options);
            result.push(this.inputName, this.inputPositionLayout, this.inputSizeLayout, this.checkBackgroundLayout, this.colorBackgroundLayout, this.selectGestureLayout, this.checkVisibleLayout, this.checkInteractiveLayout);
            return result;
        }
        newLabel(label) {
            return new wcardinalUi.DInputLabel({
                width: 60,
                text: {
                    value: label
                }
            });
        }
        newSpace() {
            return new wcardinalUi.DLayoutSpace({
                width: 60
            });
        }
        newLabeled(label, inputA, inputB) {
            return new wcardinalUi.DLayoutHorizontal({
                width: "padding",
                height: "auto",
                children: [
                    label != null ? this.newLabel(label) : this.newSpace(),
                    inputA,
                    inputB,
                    this.newSpace()
                ]
            });
        }
        get inputName() {
            let result = this._inputName;
            if (result == null) {
                result = this.newInputName();
                this._inputName = result;
            }
            return result;
        }
        newInputName() {
            return new wcardinalUi.DInputTextAndLabel({
                width: "padding",
                height: "auto",
                label: {
                    width: 60,
                    text: {
                        value: this.theme.getInputNameLabel()
                    }
                },
                input: {
                    weight: 1,
                    text: {
                        value: ""
                    },
                    on: {
                        enter: () => {
                            this.ok();
                        }
                    }
                },
                space: {
                    width: 60
                }
            });
        }
        get inputX() {
            let result = this._inputX;
            if (result == null) {
                result = this.newInputX();
                this._inputX = result;
            }
            return result;
        }
        newInputX() {
            return new wcardinalUi.DInputReal({
                weight: 1,
                on: {
                    enter: () => {
                        this.ok();
                    }
                }
            });
        }
        get inputY() {
            let result = this._inputY;
            if (result == null) {
                result = this.newInputY();
                this._inputY = result;
            }
            return result;
        }
        newInputY() {
            return new wcardinalUi.DInputReal({
                weight: 1,
                on: {
                    enter: () => {
                        this.ok();
                    }
                }
            });
        }
        get inputPositionLayout() {
            let result = this._inputPositionLayout;
            if (result == null) {
                result = this.newLabeled(this.theme.getInputPositionLabel(), this.inputX, this.inputY);
                this._inputPositionLayout = result;
            }
            return result;
        }
        get inputWidth() {
            let result = this._inputWidth;
            if (result == null) {
                result = this.newInputWidth();
                this._inputWidth = result;
            }
            return result;
        }
        newInputWidth() {
            return new wcardinalUi.DInputReal({
                weight: 1,
                on: {
                    enter: () => {
                        this.ok();
                    }
                }
            });
        }
        get inputHeight() {
            let result = this._inputHeight;
            if (result == null) {
                result = this.newInputHeight();
                this._inputHeight = result;
            }
            return result;
        }
        newInputHeight() {
            return new wcardinalUi.DInputReal({
                weight: 1,
                on: {
                    enter: () => {
                        this.ok();
                    }
                }
            });
        }
        get inputSizeLayout() {
            let result = this._inputSizeLayout;
            if (result == null) {
                result = this.newLabeled(this.theme.getInputSizeLabel(), this.inputWidth, this.inputHeight);
                this._inputSizeLayout = result;
            }
            return result;
        }
        get checkBackground() {
            let result = this._checkBackground;
            if (result == null) {
                result = this.newCheckBackground();
                this._checkBackground = result;
            }
            return result;
        }
        newCheckBackground() {
            return new wcardinalUi.DButtonCheck({
                weight: 1,
                text: {
                    value: this.theme.getCheckBackgroundLabel(),
                    align: {
                        horizontal: "LEFT"
                    }
                },
                on: {
                    active: () => {
                        this.onCheckBackgroundChange(true);
                    },
                    inactive: () => {
                        this.onCheckBackgroundChange(false);
                    }
                }
            });
        }
        onCheckBackgroundChange(isActive) {
            this.colorBackground.state.isDisabled = !isActive;
        }
        get checkBackgroundLayout() {
            let result = this._checkBackgroundLayout;
            if (result == null) {
                result = this.newLabeled(this.theme.getTextBackgroundLabel(), this.checkBackground, null);
                this._checkBackgroundLayout = result;
            }
            return result;
        }
        get colorBackground() {
            let result = this._colorBackground;
            if (result == null) {
                result = this.newColorBackground();
                this._colorBackground = result;
            }
            return result;
        }
        newColorBackground() {
            return new wcardinalUi.DButtonColor({
                weight: 1
            });
        }
        get colorBackgroundLayout() {
            let result = this._colorBackgroundLayout;
            if (result == null) {
                result = this.newLabeled(null, this.colorBackground, null);
                this._colorBackgroundLayout = result;
            }
            return result;
        }
        get checkVisible() {
            let result = this._checkVisible;
            if (result == null) {
                result = this.newCheckVisible();
                this._checkVisible = result;
            }
            return result;
        }
        newCheckVisible() {
            return new wcardinalUi.DButtonCheck({
                weight: 1,
                text: {
                    value: this.theme.getCheckVisibleLabel(),
                    align: {
                        horizontal: "LEFT"
                    }
                }
            });
        }
        get checkVisibleLayout() {
            let result = this._checkVisibleLayout;
            if (result == null) {
                result = this.newLabeled(null, this.checkVisible, null);
                this._checkVisibleLayout = result;
            }
            return result;
        }
        get checkInteractive() {
            let result = this._checkInteractive;
            if (result == null) {
                result = this.newCheckInteractive();
                this._checkInteractive = result;
            }
            return result;
        }
        newCheckInteractive() {
            return new wcardinalUi.DButtonCheck({
                weight: 1,
                text: {
                    value: this.theme.getCheckInteractiveLabel(),
                    align: {
                        horizontal: "LEFT"
                    }
                }
            });
        }
        get checkInteractiveLayout() {
            let result = this._checkInteractiveLayout;
            if (result == null) {
                result = this.newLabeled(null, this.checkInteractive, null);
                this._checkInteractiveLayout = result;
            }
            return result;
        }
        get selectGesture() {
            let result = this._selectGesture;
            if (result == null) {
                result = this.newSelectGesture();
                this._selectGesture = result;
            }
            return result;
        }
        newSelectGesture() {
            const theme = this.theme;
            return new wcardinalUi.DSelectMultiple({
                weight: 1,
                values: this.fromGestureOperationType(wcardinalUi.EShapeActionValueGestureOperationType.ALL),
                menu: {
                    items: [
                        {
                            value: wcardinalUi.EShapeActionValueGestureOperationType.DRAG,
                            text: {
                                value: theme.getSelectGestureValueLabel(wcardinalUi.EShapeActionValueGestureOperationType.DRAG)
                            },
                            check: true
                        },
                        {
                            value: wcardinalUi.EShapeActionValueGestureOperationType.PINCH,
                            text: {
                                value: theme.getSelectGestureValueLabel(wcardinalUi.EShapeActionValueGestureOperationType.PINCH)
                            },
                            check: true
                        }
                    ]
                }
            });
        }
        toGestureOperationType(types) {
            let result = wcardinalUi.EShapeActionValueGestureOperationType.NONE;
            for (let i = 0, imax = types.length; i < imax; ++i) {
                result |= types[i];
            }
            return result;
        }
        fromGestureOperationType(type) {
            const result = [];
            if (type & wcardinalUi.EShapeActionValueGestureOperationType.DRAG) {
                result.push(wcardinalUi.EShapeActionValueGestureOperationType.DRAG);
            }
            if (type & wcardinalUi.EShapeActionValueGestureOperationType.PINCH) {
                result.push(wcardinalUi.EShapeActionValueGestureOperationType.PINCH);
            }
            return result;
        }
        get selectGestureLayout() {
            let result = this._selectGestureLayout;
            if (result == null) {
                result = this.newLabeled(this.theme.getSelectGestureLabel(), this.selectGesture, null);
                this._selectGestureLayout = result;
            }
            return result;
        }
        reset(width, height) {
            this.inputName.input.value = "";
            this.inputX.value = 0;
            this.inputY.value = 0;
            this.inputWidth.value = width;
            this.inputHeight.value = height;
            this.checkBackground.state.isActive = false;
            this.colorBackground.value.color = 0xffffff;
            this.colorBackground.value.alpha = 1;
            this.checkVisible.state.isActive = true;
            this.checkInteractive.state.isActive = true;
            this.selectGesture.values = [];
            this.onCheckBackgroundChange(false);
            return this;
        }
        get value() {
            return new EDialogLayerValue(this.inputName.input.value, this.inputX.value, this.inputY.value, this.inputWidth.value, this.inputHeight.value, new EDialogLayerValueBackground(this.checkBackground.state.isActive, this.colorBackground.value.color, this.colorBackground.value.alpha), this.checkVisible.state.isActive, this.checkInteractive.state.isActive, this.toGestureOperationType(this.selectGesture.values));
        }
        set value(value) {
            if (value != null) {
                this.inputName.input.value = value.name;
                this.inputX.value = value.x;
                this.inputY.value = value.y;
                this.inputWidth.value = value.width;
                this.inputHeight.value = value.height;
                this.checkBackground.state.isActive = value.background.enable;
                this.colorBackground.value.color = value.background.color;
                this.colorBackground.value.alpha = value.background.alpha;
                this.checkVisible.state.isActive = value.visible;
                this.checkInteractive.state.isActive = value.interactive;
                this.selectGesture.values = this.fromGestureOperationType(value.gesture);
                this.onCheckBackgroundChange(value.background.enable);
            }
        }
        getResolvedValue() {
            return this.value;
        }
        getType() {
            return "EDialogLayer";
        }
    }

    class EDialogProcessing extends wcardinalUi.DDialogProcessing {
        toReasonMalformedLabel(target) {
            switch (target) {
                case "uid":
                    return "An ID";
                case "password":
                    return "A password";
                case "description":
                    return "A description";
                case "name":
                    return "A name";
                case "label":
                    return "A label";
                case "summary":
                    return "A summary";
                default:
                    return "Something";
            }
        }
        toReasonMalformedRange(target) {
            switch (target) {
                case "uid":
                    return {
                        lower: 1,
                        upper: 32
                    };
                case "password":
                    return {
                        lower: 6,
                        upper: 32
                    };
                case "description":
                    return {
                        lower: 0,
                        upper: 256
                    };
                case "name":
                    return {
                        lower: 1,
                        upper: 32
                    };
                case "label":
                    return {
                        lower: 0,
                        upper: 16
                    };
                case "summary":
                    return {
                        lower: 0,
                        upper: 32
                    };
                default:
                    return {
                        lower: 1,
                        upper: 32
                    };
            }
        }
        toReasonMalformed(at, target, reason) {
            const label = this.toReasonMalformedLabel(target);
            switch (reason) {
                case "short":
                case "long":
                    const range = this.toReasonMalformedRange(target);
                    return `Failed to save '${at}'.\n${label} must be of ${range.lower} to ${range.upper}\ncharacters long.`;
                case "simple":
                    return `Failed to save '${at}'.\n${label} must contain letters (A-Za-z_)\nand digits (0-9).`;
                case "slash":
                    return `Failed to save '${at}'.\n${label} must not contain the slash mark (/).`;
                case "non-alphanumeric":
                    return (`Failed to save '${at}'.\n${label} must contain only letters (A-Za-z_),\n` +
                        `digits (0-9) and a sharp symbol (#).`);
                default:
                    return `Failed to save '${at}'.\n${label} is invalid.`;
            }
        }
        toReasonTarget(at, target, targetLabel) {
            if (target != null) {
                return `Failed to save '${at}'.\n${targetLabel} '${target}' does not exit.`;
            }
            else {
                return `Failed to save '${at}'.\n${targetLabel} is missing.`;
            }
        }
        toReasonTargetAt(at, target, atLabel, targetLabel) {
            if (target != null) {
                return `Failed to save.\n${atLabel} '${at}'\nrequires ${targetLabel} '${target}'.`;
            }
            else {
                return `Failed to save.\n${atLabel} '${at}'\nrequires ${targetLabel}.`;
            }
        }
        toReason(reason) {
            if (reason == null) {
                return undefined;
            }
            else {
                if (0 < reason.length && reason[0] === "{") {
                    try {
                        const parsed = JSON.parse(reason);
                        switch (parsed.id) {
                            case "no-sensor-found":
                                return this.toReasonTarget(parsed.at, parsed.target, "Sensor");
                            case "no-device-model-found":
                                return this.toReasonTarget(parsed.at, parsed.target, "Device model");
                            case "malformed":
                                return this.toReasonMalformed(parsed.at, parsed.target, parsed.reason);
                            case "invalid-operation-mode":
                                return "Failed to save.\nInvalid operation mode.";
                            case "no-graphic-found":
                                return this.toReasonTargetAt(parsed.at, parsed.target, "A graphic sensor mapping", "a graphic");
                            case "no-alarm-list-found":
                                return this.toReasonTargetAt(parsed.at, parsed.target, "An alarm mapping", "an alarm list");
                            case "no-trend-graph-found":
                                return this.toReasonTargetAt(parsed.at, parsed.target, "A trend graph sensor mapping", "a trend graph");
                        }
                    }
                    catch (_a) {
                        return undefined;
                    }
                }
                else {
                    switch (reason) {
                        case "duplication":
                            return "Failed to save.\nThe name has already been used.";
                        case "duplications":
                            return "Failed to save.\nIDs must be unique.";
                        case "invalid-operation-mode":
                            return "Failed to save.\nInvalid operation mode.";
                        case "validation":
                            return "A validation error has occurred.";
                        case "validation-fail":
                            return "A validation failed.";
                    }
                }
            }
            return undefined;
        }
        toButtonText(reason) {
            if (reason === "validation" || reason === "validation-fail" || reason != undefined) {
                return "OK";
            }
            return "Save";
        }
        reject(reason) {
            super.reject(this.toReason(reason));
            // Button text
            const footer = this.footer;
            if (footer) {
                const buttonOk = footer.buttonOk;
                if (buttonOk) {
                    buttonOk.text = this.toButtonText(reason);
                }
            }
        }
    }

    let dialogSelectThumbnailSize = 128;
    const getDialogSelectThumbnailSize = () => {
        return dialogSelectThumbnailSize;
    };
    const setDialogSelectThumbnailSize = (size) => {
        dialogSelectThumbnailSize = size;
    };
    let dialogSelectTHumbnailNotFound;
    const getDialogSelectThumbnailNotFound = () => {
        let result = dialogSelectTHumbnailNotFound;
        if (result == null) {
            result = newDialogTHumbnailNotFound();
            dialogSelectTHumbnailNotFound = result;
        }
        return result;
    };
    const newDialogTHumbnailNotFound = () => {
        const thumbnailSize = getDialogSelectThumbnailSize();
        const resolution = window.devicePixelRatio || 1;
        const svgSize = thumbnailSize * resolution;
        return wcardinalUi.toSvgTexture(`<svg xmlns="http://www.w3.org/2000/svg" height="${svgSize}px" width="${svgSize}px" viewBox="0 0 24 24" fill="#000000" fill-opacity="0.05">` +
            `<path d="M19,5v11.17l2,2V5c0-1.1-0.9-2-2-2H5.83l2,2H19z"/>` +
            `<path d="M2.81,2.81L1.39,4.22L3,5.83V19c0,1.1,0.9,2,2,2h13.17l1.61,1.61l1.41-1.41L2.81,2.81z M5,19V7.83l7.07,7.07L11.25,16 L9,13l-3,4h8.17l2,2H5z"/>` +
            `</svg>`, resolution);
    };
    const newDialogSelectWithThumbnailsOptions = (controller, toThumbnail, onSelect) => {
        const thumbnailSize = getDialogSelectThumbnailSize();
        const thumbnailNotFound = getDialogSelectThumbnailNotFound();
        const itemPadding = 8;
        const itemLabelHeight = 30;
        const itemSize = itemPadding + thumbnailSize + itemLabelHeight + itemPadding;
        const textures = new Map();
        const items = new Set();
        const toImage = (item) => {
            if (toThumbnail) {
                const image = toThumbnail(item.id);
                if (wcardinalUi.isString(image)) {
                    let texture = textures.get(image);
                    if (texture == null) {
                        const newTexture = pixi_js.Texture.from(image);
                        newTexture.baseTexture.on("error", () => {
                            checkTextures(newTexture, image);
                        });
                        texture = newTexture;
                        textures.set(image, newTexture);
                    }
                    return texture;
                }
                else if (image != null) {
                    return image;
                }
            }
            return thumbnailNotFound;
        };
        const openTextures = () => {
            items.forEach((item) => {
                const value = item.value;
                if (value != null) {
                    item.image = toImage(value);
                }
            });
        };
        let clearTimeoutId = null;
        const clearTextures = () => {
            items.forEach((item) => {
                item.image = null;
            });
            textures.forEach((texture, url) => {
                if (texture !== thumbnailNotFound) {
                    const baseTexture = texture.baseTexture;
                    texture.destroy();
                    if (baseTexture) {
                        baseTexture.destroy();
                        baseTexture.off("error");
                    }
                }
            });
            textures.clear();
        };
        const checkTextures = (texture, url) => {
            if (texture !== thumbnailNotFound && !texture.valid) {
                items.forEach((item) => {
                    const image = item.image.get(0);
                    if (image != null && image.source === texture) {
                        image.source = thumbnailNotFound;
                    }
                });
                const baseTexture = texture.baseTexture;
                texture.destroy();
                if (baseTexture) {
                    baseTexture.destroy();
                    baseTexture.off("error");
                }
                textures.set(url, thumbnailNotFound);
            }
        };
        return {
            width: "auto",
            height: "auto",
            layout: {
                width: "auto",
                height: "auto"
            },
            content: {
                width: "auto",
                height: "auto"
            },
            list: {
                width: itemSize * 3,
                height: itemSize * 2 + itemPadding * 4,
                data: {
                    toImage
                },
                updater: {
                    newItem: function (data) {
                        const result = new wcardinalUi.DDialogSelectListItem(data, {
                            width: itemSize,
                            height: itemSize,
                            padding: itemPadding,
                            text: {
                                align: {
                                    vertical: "BOTTOM",
                                    horizontal: "CENTER"
                                }
                            },
                            image: {
                                align: {
                                    vertical: "TOP",
                                    horizontal: "CENTER",
                                    with: "PADDING"
                                },
                                margin: {
                                    vertical: 0
                                },
                                tint: {
                                    color: 0xffffff,
                                    alpha: 1.0
                                }
                            }
                        });
                        items.add(result);
                        return result;
                    }
                }
            },
            controller,
            on: {
                open: () => {
                    if (clearTimeoutId != null) {
                        window.clearTimeout(clearTimeoutId);
                        clearTimeoutId = null;
                        clearTextures();
                    }
                    openTextures();
                },
                close: () => {
                    if (clearTimeoutId == null) {
                        clearTimeoutId = window.setTimeout(() => {
                            clearTimeoutId = null;
                            clearTextures();
                        }, 1000);
                    }
                },
                select: onSelect
            }
        };
    };
    const newDialogSelectWithThumbnails = (controller, toThumbnail, onSelect) => {
        return new wcardinalUi.DDialogSelect(newDialogSelectWithThumbnailsOptions(controller, toThumbnail, onSelect));
    };

    class EDialogSnap extends wcardinalUi.DDialogLayered {
        newContentChildren(theme, options) {
            const result = super.newContentChildren(theme, options);
            result.push(new wcardinalUi.DLayoutHorizontal({
                width: "padding",
                height: "auto",
                children: [
                    new wcardinalUi.DInputLabel({
                        width: 60,
                        text: {
                            value: theme.getSelectDirectionLabel()
                        }
                    }),
                    this.selectType,
                    new wcardinalUi.DLayoutSpace({
                        width: 60
                    })
                ]
            }));
            result.push(new wcardinalUi.DLayoutHorizontal({
                width: "padding",
                height: "auto",
                children: [
                    new wcardinalUi.DInputLabel({
                        width: 60,
                        text: {
                            value: theme.getInputPositionLabel()
                        }
                    }),
                    this.inputPosition,
                    new wcardinalUi.DLayoutSpace({
                        width: 60
                    })
                ]
            }));
            return result;
        }
        get selectType() {
            let result = this._selectType;
            if (result == null) {
                result = this.newSelectType();
                this._selectType = result;
            }
            return result;
        }
        newSelectType() {
            const theme = this.theme;
            return new wcardinalUi.DSelect({
                weight: 1,
                value: wcardinalUi.ESnapperTargetValueType.VERTICAL,
                menu: {
                    items: [
                        {
                            value: wcardinalUi.ESnapperTargetValueType.VERTICAL,
                            text: {
                                value: theme.getSelectDirectionValueLabel(wcardinalUi.ESnapperTargetValueType.VERTICAL)
                            }
                        },
                        {
                            value: wcardinalUi.ESnapperTargetValueType.HORIZONTAL,
                            text: {
                                value: theme.getSelectDirectionValueLabel(wcardinalUi.ESnapperTargetValueType.HORIZONTAL)
                            }
                        }
                    ]
                }
            });
        }
        get inputPosition() {
            let result = this._inputPosition;
            if (result == null) {
                result = this.newInputPosition();
                this._inputPosition = result;
            }
            return result;
        }
        newInputPosition() {
            return new wcardinalUi.DInputReal({
                weight: 1,
                text: {
                    value: 0
                },
                step: 1,
                on: {
                    enter: () => {
                        this.ok();
                    }
                }
            });
        }
        reset() {
            this.selectType.value = wcardinalUi.ESnapperTargetValueType.VERTICAL;
            this.inputPosition.value = 0;
            return this;
        }
        get value() {
            const type = this.selectType.value;
            const position = this.inputPosition.value;
            if (type != null) {
                return new wcardinalUi.ESnapperTargetValue(type, position);
            }
            return null;
        }
        set value(value) {
            if (value != null) {
                this.selectType.value = value.type;
                this.inputPosition.value = value.position;
            }
        }
        getResolvedValue() {
            return this.value;
        }
        getType() {
            return "EDialogSnap";
        }
    }

    class EEditorAction extends wcardinalUi.DLayoutVertical {
        constructor(options) {
            super(options);
            this._icons = options.icons;
            const selection = options.selection;
            this._selection = selection;
            this._diagram = options.diagram;
            this.addChild(new wcardinalUi.DLayoutHorizontal({
                width: "padding",
                height: "auto",
                children: [
                    this.newTextLabel(),
                    this.buttonNew,
                    this.buttonDelete,
                    this.buttonBringForward,
                    this.buttonSendBackward
                ]
            }));
            this.addChild(this.actionList);
            this.addChild(this.checkInteractive);
            this.addChild(this.checkFocusable);
            this.addChild(this.labelTitle);
            this.addChild(this.inputTitle);
            this.addChild(this.labelShortcut);
            this.addChild(this.inputShortcut);
            this.addChild(this.labelCursor);
            this.addChild(this.dropdownCursor);
            selection.on("change", () => {
                this.onSelectionChange(selection);
            });
            const actionList = this.actionList;
            actionList.data.selection.on("change", () => {
                this.onListSelectionChange(actionList);
            });
            this.onSelectionChange(selection);
        }
        newTextLabel() {
            return new wcardinalUi.DText({
                weight: 1,
                text: {
                    value: this.theme.getLabel()
                }
            });
        }
        get buttonNew() {
            var _a;
            return ((_a = this._buttonNew) !== null && _a !== void 0 ? _a : (this._buttonNew = this.newButtonNew()));
        }
        newButtonNew() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.new
                },
                title: this.theme.getButtonNewTitle(),
                on: {
                    active: (emitter) => {
                        this.onButtonNewActive(emitter);
                    }
                }
            });
        }
        onButtonNewActive(opener) {
            this.actionDialog
                .reset()
                .open(opener)
                .then((value) => {
                if (value != null) {
                    this._selection.addActionValue(value);
                }
            });
        }
        get buttonDelete() {
            var _a;
            return ((_a = this._buttonDelete) !== null && _a !== void 0 ? _a : (this._buttonDelete = this.newButtonDelete()));
        }
        newButtonDelete() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.delete
                },
                title: this.theme.getButtonDeleteTitle(),
                state: wcardinalUi.DBaseState.DISABLED,
                on: {
                    active: () => {
                        const first = this.actionList.data.selection.first;
                        if (first != null) {
                            this._selection.removeActionValue(first);
                        }
                    }
                }
            });
        }
        onListSelectionChangeButtonDelete(actionList) {
            this.buttonDelete.state.isDisabled = actionList.data.selection.isEmpty();
        }
        get buttonBringForward() {
            var _a;
            return ((_a = this._buttonBringForward) !== null && _a !== void 0 ? _a : (this._buttonBringForward = this.newButtonBringForward()));
        }
        newButtonBringForward() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.arrow_up
                },
                title: this.theme.getButtonBringForwardTitle(),
                state: wcardinalUi.DBaseState.DISABLED,
                on: {
                    active: () => {
                        const actionList = this.actionList;
                        const first = actionList.data.selection.first;
                        const items = actionList.data.items;
                        if (first != null && items[0] !== first) {
                            this._selection.bringActionValueForward(first);
                        }
                    }
                }
            });
        }
        onListSelectionChangeButtonBringForward(actionList) {
            const first = actionList.data.selection.first;
            const items = actionList.data.items;
            this.buttonBringForward.state.isDisabled = first == null || items[0] === first;
        }
        get buttonSendBackward() {
            var _a;
            return ((_a = this._buttonSendBackward) !== null && _a !== void 0 ? _a : (this._buttonSendBackward = this.newButtonSendBackward()));
        }
        newButtonSendBackward() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.arrow_down
                },
                title: this.theme.getButtonSendBackwardTitle(),
                state: wcardinalUi.DBaseState.DISABLED,
                on: {
                    active: () => {
                        const actionList = this.actionList;
                        const first = actionList.data.selection.first;
                        const items = actionList.data.items;
                        if (first != null && items[items.length - 1] !== first) {
                            this._selection.sendActionValueBackward(first);
                        }
                    }
                }
            });
        }
        onListSelectionChangeButtonSendBackward(actionList) {
            const first = actionList.data.selection.first;
            const items = actionList.data.items;
            this.buttonSendBackward.state.isDisabled =
                first == null || items[items.length - 1] === first;
        }
        get actionDialog() {
            var _a;
            return ((_a = this._actionDialog) !== null && _a !== void 0 ? _a : (this._actionDialog = this.newActionDialog()));
        }
        newActionDialog() {
            return new EDialogAction({
                icons: this._icons,
                diagram: this._diagram
            });
        }
        get actionList() {
            var _a;
            return ((_a = this._actionList) !== null && _a !== void 0 ? _a : (this._actionList = this.newActionList()));
        }
        newActionList() {
            const result = new wcardinalUi.DList({
                width: "padding",
                weight: 1,
                data: {
                    toLabel: (item) => {
                        return item.toLabel();
                    }
                },
                updater: {
                    newItem: (data) => {
                        return new wcardinalUi.DListItem(data, {
                            image: {
                                tint: {
                                    color: null
                                }
                            },
                            on: {
                                dblclick: (e, _, item) => {
                                    this.onActionListDblClick(e, _, item, result);
                                },
                                set: (value, index, item) => {
                                    this.onActionListSet(item, value);
                                },
                                unset: (item) => {
                                    this.onActionListUnset(item);
                                }
                            }
                        });
                    }
                }
            });
            return result;
        }
        onActionListDblClick(e, _, item, list) {
            const oldActionValue = item.value;
            if (oldActionValue != null) {
                const actionDialog = this.actionDialog;
                actionDialog.reset();
                actionDialog.value = oldActionValue;
                actionDialog.open(item).then(() => {
                    const newActionValue = actionDialog.value;
                    if (newActionValue != null) {
                        this._selection.replaceActionValue(oldActionValue, newActionValue, list);
                    }
                });
            }
        }
        onActionListSet(item, value) {
            if (value instanceof wcardinalUi.EShapeActionValueChangeColor) {
                const image = item.image.get(0);
                if (image != null) {
                    const theme = wcardinalUi.DThemes.get("DButtonColor");
                    image.source = theme.getImageSource(item.state);
                    image.tint.color = value.color;
                }
            }
            else {
                item.image = null;
            }
        }
        onActionListUnset(item) {
            item.image = null;
        }
        onSelectionChangeActionList(selection) {
            const last = selection.last();
            const actionList = this.actionList;
            actionList.data.items = last != null ? last.action.values : [];
            this.onListSelectionChange(actionList);
        }
        get checkInteractive() {
            var _a;
            return ((_a = this._checkInteractive) !== null && _a !== void 0 ? _a : (this._checkInteractive = this.newCheckInteractive()));
        }
        newCheckInteractive() {
            return new wcardinalUi.DButtonCheckRight({
                width: "padding",
                text: {
                    value: this.theme.getCheckInteractiveLabel()
                },
                padding: 0,
                background: {
                    color: null
                },
                on: {
                    active: () => {
                        this._selection.setInteractive(true);
                    },
                    inactive: () => {
                        this._selection.setInteractive(false);
                    }
                }
            });
        }
        onSelectionChangeCheckInteractive(selection) {
            const last = selection.last();
            const checkInteractive = this.checkInteractive;
            if (last != null) {
                checkInteractive.state.isActive = last.interactive;
                checkInteractive.state.isDisabled = false;
            }
            else {
                checkInteractive.state.isDisabled = true;
            }
        }
        get checkFocusable() {
            var _a;
            return ((_a = this._checkFocusable) !== null && _a !== void 0 ? _a : (this._checkFocusable = this.newCheckFocusable()));
        }
        newCheckFocusable() {
            return new wcardinalUi.DButtonCheckRight({
                width: "padding",
                text: {
                    value: this.theme.getCheckFocusableLabel()
                },
                padding: 0,
                background: {
                    color: null
                },
                on: {
                    active: () => {
                        this._selection.setFocusable(true);
                    },
                    inactive: () => {
                        this._selection.setFocusable(false);
                    }
                }
            });
        }
        onSelectionChangeCheckFocusable(selection) {
            const last = selection.last();
            const checkFocusable = this.checkFocusable;
            if (last != null) {
                checkFocusable.state.isActive = last.state.isFocusable;
                checkFocusable.state.isDisabled = false;
            }
            else {
                checkFocusable.state.isDisabled = true;
            }
        }
        get labelShortcut() {
            var _a;
            return ((_a = this._labelShortcut) !== null && _a !== void 0 ? _a : (this._labelShortcut = this.newLabelShortcut()));
        }
        newLabelShortcut() {
            return new wcardinalUi.DText({
                width: "padding",
                text: {
                    value: this.theme.getInputShortcutLabel()
                }
            });
        }
        get inputShortcut() {
            var _a;
            return ((_a = this._inputShortcut) !== null && _a !== void 0 ? _a : (this._inputShortcut = this.newInputShortcut()));
        }
        newInputShortcut() {
            return new wcardinalUi.DInputText({
                width: "padding",
                on: {
                    change: (value) => {
                        this._selection.setShortcut(this.toNormalizedShortcut(value));
                    }
                }
            });
        }
        toNormalizedShortcut(value) {
            const trimmed = value.trim();
            if (0 < trimmed.length) {
                return trimmed;
            }
        }
        onSelectionChangeInputShortcut(selection) {
            var _a;
            this.inputShortcut.value = ((_a = selection.last()) === null || _a === void 0 ? void 0 : _a.shortcut) || "";
        }
        get labelTitle() {
            var _a;
            return ((_a = this._labelTitle) !== null && _a !== void 0 ? _a : (this._labelTitle = this.newLabelTitle()));
        }
        newLabelTitle() {
            return new wcardinalUi.DText({
                width: "padding",
                text: {
                    value: this.theme.getInputTitleLabel()
                }
            });
        }
        get inputTitle() {
            var _a;
            return ((_a = this._inputTitle) !== null && _a !== void 0 ? _a : (this._inputTitle = this.newInputTitle()));
        }
        newInputTitle() {
            return new wcardinalUi.DInputText({
                width: "padding",
                on: {
                    change: (value) => {
                        this._selection.setTitle(this.toNormalizedTitle(value));
                    }
                }
            });
        }
        toNormalizedTitle(value) {
            if (0 < value.trim().length) {
                return value;
            }
        }
        onSelectionChangeInputTitle(selection) {
            var _a;
            this.inputTitle.value = ((_a = selection.last()) === null || _a === void 0 ? void 0 : _a.title) || "";
        }
        get labelCursor() {
            var _a;
            return ((_a = this._labelCursor) !== null && _a !== void 0 ? _a : (this._labelCursor = this.newLabelCursor()));
        }
        newLabelCursor() {
            return new wcardinalUi.DText({
                width: "padding",
                text: {
                    value: this.theme.getDropdownCursorLabel()
                }
            });
        }
        get dropdownCursor() {
            var _a;
            return ((_a = this._dropdownCursor) !== null && _a !== void 0 ? _a : (this._dropdownCursor = this.newDropdownCursor()));
        }
        newDropdownCursor() {
            return new wcardinalUi.DDropdown({
                width: "padding",
                menu: {
                    width: "auto",
                    column: 3,
                    fit: false,
                    items: this.newDropdownCursorMenuItems()
                },
                on: {
                    select: (value) => {
                        var _a;
                        this.dropdownCursor.text = (_a = this.cursors.get(value)) !== null && _a !== void 0 ? _a : value;
                        this._selection.setCursor(value);
                    }
                }
            });
        }
        newDropdownCursorMenuItems() {
            const result = [];
            this.cursors.forEach((label, cursor) => {
                result.push({
                    width: 200,
                    value: cursor,
                    text: {
                        value: label
                    }
                });
            });
            return result;
        }
        get cursors() {
            var _a;
            return ((_a = this._cursors) !== null && _a !== void 0 ? _a : (this._cursors = this.theme.getCursors()));
        }
        onSelectionChangeDropdownCursor(selection) {
            var _a, _b, _c;
            const cursor = (_b = (_a = selection.last()) === null || _a === void 0 ? void 0 : _a.cursor) !== null && _b !== void 0 ? _b : "";
            this.dropdownCursor.text = (_c = this.cursors.get(cursor)) !== null && _c !== void 0 ? _c : cursor;
        }
        onSelectionChange(selection) {
            this.state.isDisabled = selection.isEmpty();
            this.onSelectionChangeActionList(selection);
            this.onSelectionChangeCheckInteractive(selection);
            this.onSelectionChangeCheckFocusable(selection);
            this.onSelectionChangeInputShortcut(selection);
            this.onSelectionChangeInputTitle(selection);
            this.onSelectionChangeDropdownCursor(selection);
        }
        onListSelectionChange(actionList) {
            this.onListSelectionChangeButtonDelete(actionList);
            this.onListSelectionChangeButtonBringForward(actionList);
            this.onListSelectionChangeButtonSendBackward(actionList);
        }
        getType() {
            return "EEditorAction";
        }
    }

    class EDialogCanvas extends wcardinalUi.DDialogLayered {
        constructor(options) {
            super(options);
            const canvas = options.canvas;
            this._canvas = options.canvas;
            this.onDefaultChange(canvas);
        }
        onDefaultChange(def) {
            const category = def.category;
            const categoryDefault = category.default;
            const categoryItems = category.items;
            const layout = this.layoutCategory;
            if (categoryDefault != null && 0 < categoryItems.length) {
                const items = [];
                for (let i = 0, imax = categoryItems.length; i < imax; ++i) {
                    const categoryItem = categoryItems[i];
                    items.push({
                        value: categoryItem.id,
                        text: {
                            value: categoryItem.label
                        }
                    });
                }
                const selectCategory = this.selectCategory;
                selectCategory.menu = new wcardinalUi.DMenu({
                    fit: true,
                    items
                });
                selectCategory.value = category.default;
                layout.state.isEnabled = category.writable;
                layout.show();
            }
            else {
                layout.hide();
            }
        }
        newContentChildren(theme, options) {
            const result = super.newContentChildren(theme, options);
            result.push(this.layoutName, this.layoutLabel, this.layoutWidth, this.layoutHeight, this.layoutCategory, this.layoutSummary, this.layoutDescription, this.layoutBackground);
            return result;
        }
        get layoutName() {
            let result = this._layoutName;
            if (result == null) {
                result = this.newLayoutName();
                this._layoutName = result;
            }
            return result;
        }
        newLayoutName() {
            return new wcardinalUi.DInputTextAndLabel({
                width: "padding",
                label: {
                    text: {
                        value: this.theme.getInputNameLabel()
                    }
                },
                input: {
                    weight: 1,
                    on: {
                        enter: () => {
                            this.ok();
                        }
                    }
                },
                space: {
                    width: 60
                }
            });
        }
        get layoutLabel() {
            let result = this._layoutLabel;
            if (result == null) {
                result = this.newLayoutLabel();
                this._layoutLabel = result;
            }
            return result;
        }
        newLayoutLabel() {
            return new wcardinalUi.DInputTextAndLabel({
                width: "padding",
                label: {
                    text: {
                        value: this.theme.getInputLabelLabel()
                    }
                },
                input: {
                    weight: 1,
                    on: {
                        enter: () => {
                            this.ok();
                        }
                    }
                },
                space: {
                    width: 60
                }
            });
        }
        get layoutWidth() {
            let result = this._layoutWidth;
            if (result == null) {
                result = this.newLayoutWidth();
                this._layoutWidth = result;
            }
            return result;
        }
        newLayoutWidth() {
            return new wcardinalUi.DInputIntegerAndLabel({
                width: "padding",
                label: {
                    text: {
                        value: this.theme.getInputWidthLabel()
                    }
                },
                input: {
                    weight: 1,
                    min: 1,
                    on: {
                        enter: () => {
                            this.ok();
                        }
                    }
                },
                space: {
                    width: 60
                }
            });
        }
        get layoutHeight() {
            let result = this._layoutHeight;
            if (result == null) {
                result = this.newLayoutHeight();
                this._layoutHeight = result;
            }
            return result;
        }
        newLayoutHeight() {
            return new wcardinalUi.DInputIntegerAndLabel({
                width: "padding",
                label: {
                    text: {
                        value: this.theme.getInputHeightLabel()
                    }
                },
                input: {
                    weight: 1,
                    min: 1,
                    on: {
                        enter: () => {
                            this.ok();
                        }
                    }
                },
                space: {
                    width: 60
                }
            });
        }
        get layoutCategory() {
            let result = this._layoutCategory;
            if (result == null) {
                result = this.newLayoutCategory();
                this._layoutCategory = result;
            }
            return result;
        }
        newLayoutCategory() {
            return new wcardinalUi.DLayoutHorizontal({
                width: "padding",
                visible: false,
                children: [
                    new wcardinalUi.DInputLabel({
                        text: {
                            value: this.theme.getSelectCategoryLabel()
                        }
                    }),
                    this.selectCategory,
                    new wcardinalUi.DLayoutSpace({
                        width: 60
                    })
                ]
            });
        }
        get selectCategory() {
            let result = this._selectCategory;
            if (result == null) {
                result = this.newSelectCategory();
                this._selectCategory = result;
            }
            return result;
        }
        newSelectCategory() {
            return new wcardinalUi.DSelect({
                weight: 1
            });
        }
        get layoutSummary() {
            let result = this._layoutSummary;
            if (result == null) {
                result = this.newLayoutSummary();
                this._layoutSummary = result;
            }
            return result;
        }
        newLayoutSummary() {
            return new wcardinalUi.DLayoutHorizontal({
                width: "padding",
                height: "auto",
                children: [
                    this.newLabelSummary(),
                    this.inputSummary,
                    new wcardinalUi.DLayoutSpace({
                        width: 60
                    })
                ]
            });
        }
        newLabelSummary() {
            return new wcardinalUi.DInputLabel({
                width: 60,
                text: {
                    value: this.theme.getInputSummaryLabel()
                }
            });
        }
        get inputSummary() {
            let result = this._inputSummary;
            if (result == null) {
                result = this.newInputSummary();
                this._inputSummary = result;
            }
            return result;
        }
        newInputSummary() {
            return new wcardinalUi.DInputTextArea({
                weight: 1,
                height: 60
            });
        }
        get layoutDescription() {
            let result = this._layoutDescription;
            if (result == null) {
                result = this.newLayoutDescription();
                this._layoutDescription = result;
            }
            return result;
        }
        newLayoutDescription() {
            return new wcardinalUi.DLayoutHorizontal({
                width: "padding",
                height: "auto",
                children: [
                    this.newLabelDescription(),
                    this.inputDescription,
                    new wcardinalUi.DLayoutSpace({
                        width: 60
                    })
                ]
            });
        }
        newLabelDescription() {
            return new wcardinalUi.DInputLabel({
                width: 60,
                text: {
                    value: this.theme.getInputDescriptionLabel()
                }
            });
        }
        get inputDescription() {
            let result = this._inputDescription;
            if (result == null) {
                result = this.newInputDescription();
                this._inputDescription = result;
            }
            return result;
        }
        newInputDescription() {
            return new wcardinalUi.DInputTextArea({
                weight: 1,
                height: 100
            });
        }
        get layoutBackground() {
            let result = this._layoutBackground;
            if (result == null) {
                result = this.newLayoutBackground();
                this._layoutBackground = result;
            }
            return result;
        }
        newLayoutBackground() {
            return new wcardinalUi.DLayoutHorizontal({
                width: "padding",
                height: "auto",
                children: [
                    this.newLabelBackground(),
                    this.inputBackground,
                    new wcardinalUi.DLayoutSpace({
                        width: 60
                    })
                ]
            });
        }
        newLabelBackground() {
            return new wcardinalUi.DInputLabel({
                width: 60,
                text: {
                    value: this.theme.getInputBackgroundLabel()
                }
            });
        }
        get inputBackground() {
            let result = this._inputBackground;
            if (result == null) {
                result = this.newInputBackground();
                this._inputBackground = result;
            }
            return result;
        }
        newInputBackground() {
            const result = new wcardinalUi.DButtonColor({
                weight: 1
            });
            result.dialog.on("open", () => {
                const dialog = result.dialog;
                const dialogNew = dialog.new;
                const dialogCurrent = dialog.current;
                dialogNew.color = dialogCurrent.color;
                dialogNew.alpha = dialogCurrent.alpha;
            });
            return result;
        }
        reset(diagram) {
            const diagramCanvas = diagram === null || diagram === void 0 ? void 0 : diagram.canvas;
            if (diagramCanvas != null) {
                const background = diagramCanvas.background;
                const backgroundColor = background.color;
                const backgroundAlpha = background.alpha;
                this.value = {
                    name: diagramCanvas.name,
                    label: diagramCanvas.label,
                    width: diagramCanvas.width,
                    height: diagramCanvas.height,
                    category: diagramCanvas.category,
                    summary: diagramCanvas.summary,
                    description: diagramCanvas.description,
                    background: {
                        color: wcardinalUi.isNumber(backgroundColor) ? backgroundColor : 0xffffff,
                        alpha: wcardinalUi.isNumber(backgroundAlpha) ? backgroundAlpha : 1
                    }
                };
            }
            else {
                const canvas = this._canvas;
                this.value = {
                    name: canvas.name,
                    label: canvas.label,
                    width: canvas.width,
                    height: canvas.height,
                    category: canvas.category.default,
                    summary: canvas.summary,
                    description: canvas.description,
                    background: {
                        color: canvas.background.color,
                        alpha: canvas.background.alpha
                    }
                };
            }
            return this;
        }
        get value() {
            return {
                name: this.layoutName.input.value,
                label: this.layoutLabel.input.value,
                width: this.layoutWidth.input.value,
                height: this.layoutHeight.input.value,
                category: this.selectCategory.value,
                summary: this.inputSummary.value,
                description: this.inputDescription.value,
                background: this.inputBackground.value
            };
        }
        set value(value) {
            var _a, _b;
            this.layoutName.input.value = value.name;
            this.layoutLabel.input.value = value.label;
            this.layoutWidth.input.value = value.width;
            this.layoutHeight.input.value = value.height;
            this.selectCategory.value = (_b = (_a = value.category) !== null && _a !== void 0 ? _a : this._canvas.category.default) !== null && _b !== void 0 ? _b : null;
            this.inputSummary.value = value.summary;
            this.inputDescription.value = value.description;
            this.inputBackground.value.color = value.background.color;
            this.inputBackground.value.alpha = value.background.alpha;
        }
        getResolvedValue() {
            return this.value;
        }
        getType() {
            return "EDialogCanvas";
        }
    }

    const toOptions = (options) => {
        var _a, _b, _c, _d, _e;
        (_a = options.width) !== null && _a !== void 0 ? _a : (options.width = 200);
        (_b = options.height) !== null && _b !== void 0 ? _b : (options.height = 30);
        (_c = options.padding) !== null && _c !== void 0 ? _c : (options.padding = 0);
        (_d = options.corner) !== null && _d !== void 0 ? _d : (options.corner = { mask: "BOTTOM" });
        (_e = options.shadow) !== null && _e !== void 0 ? _e : (options.shadow = "WEAK");
        return options;
    };
    class EEditorCanvas extends wcardinalUi.DBoard {
        constructor(options) {
            super(toOptions(options));
            this._icons = options.icons;
            const diagram = options.diagram;
            this._diagram = diagram;
            diagram.on("change", () => {
                const canvas = diagram.canvas;
                if (canvas != null) {
                    this.inputName.value = canvas.name;
                }
            });
            diagram.on("set", (canvas) => {
                this.inputName.value = canvas.name;
                this.show();
            });
            diagram.on("unset", (canvas) => {
                this.hide();
            });
            this._canvas = options.canvas;
            this.addChild(new wcardinalUi.DLayoutHorizontal({
                x: "padding",
                y: "padding",
                width: "padding",
                height: "padding",
                margin: 0,
                children: [this.inputName, this.buttonEditor]
            }));
            this.hide();
        }
        get inputName() {
            let result = this._inputName;
            if (result == null) {
                result = this.newInputName();
                this._inputName = result;
            }
            return result;
        }
        newInputName() {
            return new wcardinalUi.DInputText({
                weight: 1,
                background: {
                    color: null
                },
                border: {
                    color: null
                },
                corner: {
                    mask: wcardinalUi.DCornerMask.ALL & ~wcardinalUi.DCornerMask.TOP_LEFT
                },
                on: {
                    change: (value) => {
                        this.onInputNameChange(value);
                    }
                }
            });
        }
        onInputNameChange(value) {
            const diagram = this._diagram;
            const canvas = diagram.canvas;
            if (canvas != null && canvas.name !== value) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandDocumentName(diagram, canvas, value));
            }
        }
        get buttonEditor() {
            let result = this._buttonEditor;
            if (result == null) {
                result = this.newButtonEditor();
                this._buttonEditor = result;
            }
            return result;
        }
        newButtonEditor() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.editor_canvas
                },
                on: {
                    active: (emitter) => {
                        this.onButtonEditorActive(emitter);
                    }
                }
            });
        }
        onButtonEditorActive(opener) {
            this.dialogEditor.then((dialogEditor) => {
                const diagram = this._diagram;
                dialogEditor
                    .reset(diagram)
                    .open(opener)
                    .then((value) => {
                    const canvas = diagram.canvas;
                    if (canvas != null) {
                        wcardinalUi.DControllers.getCommandController().push(new ECommandDocumentAll(diagram, canvas, value.name, value.label, value.width, value.height, value.category, value.summary, value.description, value.background.color, value.background.alpha));
                    }
                });
            });
        }
        get dialogEditor() {
            let result = this._dialogEditor;
            if (result == null) {
                result = this.newDialogEditor();
                this._dialogEditor = result;
            }
            return result;
        }
        newDialogEditor() {
            return this._canvas.get().then((canvas) => {
                return new EDialogCanvas({
                    canvas
                });
            });
        }
        render(renderer) {
            const diagram = this._diagram;
            const canvas = diagram.canvas;
            if (canvas != null) {
                const position = canvas.position;
                this.position.set(position.x, position.y - this.height);
                this.updateTransform();
            }
            super.render(renderer);
        }
        getType() {
            return "EEditorCanvas";
        }
    }

    const textFormat = (value) => {
        return `${+value.toFixed(2)}`;
    };
    const textFormatDegree = (value) => {
        return textFormat((value / Math.PI) * 180);
    };
    const textUnformatDegree = (text) => {
        return (parseFloat(text) / 180) * Math.PI;
    };
    class EEditorCoordinate extends wcardinalUi.DLayoutVertical {
        constructor(options) {
            super(options);
            this._icons = options.icons;
            this._selection = options.selection;
            this._workRectangle = new pixi_js.Rectangle();
            // Input updater
            this._updateInputShape = null;
            this._updateInputId = null;
            this._isUpdateInputShapeChanged = false;
            this._renderInputsBound = () => {
                this.renderInputs();
            };
            //
            this.addChild(this.newTextLabel());
            this.addChild(this.inputId);
            this.addChild(this.inputPositionX);
            this.addChild(this.inputPositionY);
            this.addChild(this.inputPositionLeft);
            this.addChild(this.inputPositionTop);
            this.addChild(this.inputSizeX);
            this.addChild(this.inputSizeY);
            this.addChild(this.inputRotation);
            this.addChild(this.inputSkew);
            this.addChild(this.layoutAlignHorizontally);
            this.addChild(this.layoutAlignVertically);
            //
            const selection = this._selection;
            selection.on("change", () => {
                this.onSelectionChange(selection);
            });
            this.onSelectionChange(selection);
        }
        newTextLabel() {
            return new wcardinalUi.DText({
                width: "100%",
                text: {
                    value: this.theme.getLabel()
                }
            });
        }
        get inputId() {
            let result = this._inputId;
            if (result == null) {
                result = this.newInputId();
                this._inputId = result;
            }
            return result;
        }
        newInputId() {
            return new wcardinalUi.DInputTextAndLabel({
                width: "padding",
                height: "auto",
                label: {
                    text: {
                        value: this.theme.getInputIdLabel()
                    }
                },
                input: {
                    weight: 1,
                    on: {
                        change: (value) => {
                            this._selection.setId(value);
                        }
                    }
                }
            });
        }
        get inputPositionX() {
            let result = this._inputPositionX;
            if (result == null) {
                result = this.newInputPositionX();
                this._inputPositionX = result;
            }
            return result;
        }
        newInputPositionX() {
            return new wcardinalUi.DInputRealAndLabel({
                width: "padding",
                height: "auto",
                label: {
                    text: {
                        value: this.theme.getInputPositionXLabel()
                    }
                },
                input: {
                    weight: 1,
                    step: 1,
                    text: {
                        value: 0,
                        formatter: textFormat
                    },
                    on: {
                        input: (value) => {
                            this._selection.setPositionX(value);
                        }
                    }
                }
            });
        }
        get inputPositionY() {
            let result = this._inputPositionY;
            if (result == null) {
                result = this.newInputPositionY();
                this._inputPositionY = result;
            }
            return result;
        }
        newInputPositionY() {
            return new wcardinalUi.DInputRealAndLabel({
                width: "padding",
                height: "auto",
                label: {
                    text: {
                        value: this.theme.getInputPositionYLabel()
                    }
                },
                input: {
                    weight: 1,
                    step: 1,
                    text: {
                        value: 0,
                        formatter: textFormat
                    },
                    on: {
                        input: (value) => {
                            this._selection.setPositionY(value);
                        }
                    }
                }
            });
        }
        get inputPositionLeft() {
            let result = this._inputPositionLeft;
            if (result == null) {
                result = this.newInputPositionLeft();
                this._inputPositionLeft = result;
            }
            return result;
        }
        newInputPositionLeft() {
            return new wcardinalUi.DInputRealAndLabel({
                width: "padding",
                height: "auto",
                label: {
                    text: {
                        value: this.theme.getInputPositionLeftLabel()
                    }
                },
                input: {
                    weight: 1,
                    step: 1,
                    text: {
                        value: 0,
                        formatter: textFormat
                    },
                    on: {
                        input: (value) => {
                            this._selection.setPositionLeft(value);
                        }
                    }
                }
            });
        }
        get inputPositionTop() {
            let result = this._inputPositionTop;
            if (result == null) {
                result = this.newInputPositionTop();
                this._inputPositionTop = result;
            }
            return result;
        }
        newInputPositionTop() {
            return new wcardinalUi.DInputRealAndLabel({
                width: "padding",
                height: "auto",
                label: {
                    text: {
                        value: this.theme.getInputPositionTopLabel()
                    }
                },
                input: {
                    weight: 1,
                    step: 1,
                    text: {
                        value: 0,
                        formatter: textFormat
                    },
                    on: {
                        input: (value) => {
                            this._selection.setPositionTop(value);
                        }
                    }
                }
            });
        }
        get inputSizeX() {
            let result = this._inputSizeX;
            if (result == null) {
                result = this.newInputSizeX();
                this._inputSizeX = result;
            }
            return result;
        }
        newInputSizeX() {
            return new wcardinalUi.DInputRealAndLabel({
                width: "padding",
                height: "auto",
                label: {
                    text: {
                        value: this.theme.getInputSizeXLabel()
                    }
                },
                input: {
                    weight: 1,
                    step: 1,
                    text: {
                        value: 0,
                        formatter: textFormat
                    },
                    on: {
                        input: (value) => {
                            this._selection.setSizeX(value);
                        }
                    }
                }
            });
        }
        get inputSizeY() {
            let result = this._inputSizeY;
            if (result == null) {
                result = this.newInputSizeY();
                this._inputSizeY = result;
            }
            return result;
        }
        newInputSizeY() {
            return new wcardinalUi.DInputRealAndLabel({
                width: "padding",
                height: "auto",
                label: {
                    text: {
                        value: this.theme.getInputSizeYLabel()
                    }
                },
                input: {
                    weight: 1,
                    step: 1,
                    text: {
                        value: 0,
                        formatter: textFormat
                    },
                    on: {
                        input: (value) => {
                            this._selection.setSizeY(value);
                        }
                    }
                }
            });
        }
        get inputRotation() {
            let result = this._inputRotation;
            if (result == null) {
                result = this.newInputRotation();
                this._inputRotation = result;
            }
            return result;
        }
        newInputRotation() {
            return new wcardinalUi.DInputRealAndLabel({
                width: "padding",
                height: "auto",
                label: {
                    text: {
                        value: this.theme.getInputRotationLabel()
                    }
                },
                input: {
                    weight: 1,
                    step: 1,
                    text: {
                        value: 0,
                        formatter: textFormatDegree
                    },
                    editing: {
                        unformatter: textUnformatDegree
                    },
                    on: {
                        input: (value) => {
                            this._selection.setRotation(value);
                        }
                    }
                }
            });
        }
        get inputSkew() {
            let result = this._inputSkew;
            if (result == null) {
                result = this.newInputSkew();
                this._inputSkew = result;
            }
            return result;
        }
        newInputSkew() {
            return new wcardinalUi.DInputRealAndLabel({
                width: "padding",
                height: "auto",
                label: {
                    text: {
                        value: this.theme.getInputSkewLabel()
                    }
                },
                input: {
                    weight: 1,
                    step: 1,
                    text: {
                        value: 0,
                        formatter: textFormatDegree
                    },
                    editing: {
                        unformatter: textUnformatDegree
                    },
                    on: {
                        input: (value) => {
                            this._selection.setSkew(value);
                        }
                    }
                }
            });
        }
        get layoutAlignHorizontally() {
            let result = this._layoutAlignHorizontally;
            if (result == null) {
                result = this.newLayoutAlignHorizontally();
                this._layoutAlignHorizontally = result;
            }
            return result;
        }
        newLayoutAlignHorizontally() {
            return new wcardinalUi.DLayoutHorizontal({
                width: "padding",
                height: "auto",
                children: [
                    new wcardinalUi.DLayoutSpace({ weight: 1 }),
                    this.buttonAlignLeft,
                    this.buttonAlignCenter,
                    this.buttonAlignRight,
                    this.buttonDistributeHorizontally,
                    this.buttonDistributeVertically,
                    this.buttonLock,
                    new wcardinalUi.DLayoutSpace({ weight: 1 })
                ]
            });
        }
        get layoutAlignVertically() {
            let result = this._layoutAlignVertically;
            if (result == null) {
                result = this.newLayoutAlignVertically();
                this._layoutAlignVertically = result;
            }
            return result;
        }
        newLayoutAlignVertically() {
            return new wcardinalUi.DLayoutHorizontal({
                width: "padding",
                height: "auto",
                children: [
                    new wcardinalUi.DLayoutSpace({ weight: 1 }),
                    this.buttonAlignTop,
                    this.buttonAlignMiddle,
                    this.buttonAlignBottom,
                    this.buttonRotateLeft,
                    this.buttonRotateRight,
                    new wcardinalUi.DLayoutSpace({ weight: 1 })
                ]
            });
        }
        get buttonAlignLeft() {
            let result = this._buttonAlignLeft;
            if (result == null) {
                result = this.newButtonAlignLeft();
                this._buttonAlignLeft = result;
            }
            return result;
        }
        newButtonAlignLeft() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.editor_coordinate_align_left
                },
                title: this.theme.getButtonAlignLeftTitle(),
                on: {
                    active: () => {
                        const selection = this._selection;
                        selection.saveForTranslate();
                        selection.alignLeft();
                    }
                }
            });
        }
        get buttonAlignCenter() {
            let result = this._buttonAlignCenter;
            if (result == null) {
                result = this.newButtonAlignCenter();
                this._buttonAlignCenter = result;
            }
            return result;
        }
        newButtonAlignCenter() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.editor_coordinate_align_center
                },
                title: this.theme.getButtonAlignCenterTitle(),
                on: {
                    active: () => {
                        const selection = this._selection;
                        selection.saveForTranslate();
                        selection.alignCenter();
                    }
                }
            });
        }
        get buttonAlignRight() {
            let result = this._buttonAlignRight;
            if (result == null) {
                result = this.newButtonAlignRight();
                this._buttonAlignRight = result;
            }
            return result;
        }
        newButtonAlignRight() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.editor_coordinate_align_right
                },
                title: this.theme.getButtonAlignRightTitle(),
                on: {
                    active: () => {
                        const selection = this._selection;
                        selection.saveForTranslate();
                        selection.alignRight();
                    }
                }
            });
        }
        get buttonAlignTop() {
            let result = this._buttonAlignTop;
            if (result == null) {
                result = this.newButtonAlignTop();
                this._buttonAlignTop = result;
            }
            return result;
        }
        newButtonAlignTop() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.editor_coordinate_align_top
                },
                title: this.theme.getButtonAlignTopTitle(),
                on: {
                    active: () => {
                        const selection = this._selection;
                        selection.saveForTranslate();
                        selection.alignTop();
                    }
                }
            });
        }
        get buttonAlignMiddle() {
            let result = this._buttonAlignMiddle;
            if (result == null) {
                result = this.newButtonAlignMiddle();
                this._buttonAlignMiddle = result;
            }
            return result;
        }
        newButtonAlignMiddle() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.editor_coordinate_align_middle
                },
                title: this.theme.getButtonAlignMiddleTitle(),
                on: {
                    active: () => {
                        const selection = this._selection;
                        selection.saveForTranslate();
                        selection.alignMiddle();
                    }
                }
            });
        }
        get buttonAlignBottom() {
            let result = this._buttonAlignBottom;
            if (result == null) {
                result = this.newButtonAlignBottom();
                this._buttonAlignBottom = result;
            }
            return result;
        }
        newButtonAlignBottom() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.editor_coordinate_align_bottom
                },
                title: this.theme.getButtonAlignBottomTitle(),
                on: {
                    active: () => {
                        const selection = this._selection;
                        selection.saveForTranslate();
                        selection.alignBottom();
                    }
                }
            });
        }
        get buttonDistributeHorizontally() {
            let result = this._buttonDistributeHorizontally;
            if (result == null) {
                result = this.newButtonDistributeHorizontally();
                this._buttonDistributeHorizontally = result;
            }
            return result;
        }
        newButtonDistributeHorizontally() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.editor_coordinate_distribute_horizontally
                },
                title: this.theme.getButtonDistributeHorizontallyTitle(),
                on: {
                    active: () => {
                        const selection = this._selection;
                        selection.saveForTranslate();
                        selection.distributeHorizontally();
                    }
                }
            });
        }
        get buttonDistributeVertically() {
            let result = this._buttonDistributeVertically;
            if (result == null) {
                result = this.newButtonDistributeVertically();
                this._buttonDistributeVertically = result;
            }
            return result;
        }
        newButtonDistributeVertically() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.editor_coordinate_distribute_vertically
                },
                title: this.theme.getButtonDistributeVerticallyTitle(),
                on: {
                    active: () => {
                        const selection = this._selection;
                        selection.saveForTranslate();
                        selection.distributeVertically();
                    }
                }
            });
        }
        get buttonRotateLeft() {
            let result = this._buttonRotateLeft;
            if (result == null) {
                result = this.newButtonRotateLeft();
                this._buttonRotateLeft = result;
            }
            return result;
        }
        newButtonRotateLeft() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.editor_coordinate_rotate_left
                },
                title: this.theme.getButtonRotateLeftTitle(),
                on: {
                    active: () => {
                        const selection = this._selection;
                        if (selection.prepareRotate()) {
                            selection.saveForRotate();
                            selection.rotate(-0.5 * Math.PI);
                            selection.finalize();
                        }
                    }
                }
            });
        }
        get buttonRotateRight() {
            let result = this._buttonRotateRight;
            if (result == null) {
                result = this.newButtonRotateRight();
                this._buttonRotateRight = result;
            }
            return result;
        }
        newButtonRotateRight() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.editor_coordinate_rotate_right
                },
                title: this.theme.getButtonRotateRightTitle(),
                on: {
                    active: () => {
                        const selection = this._selection;
                        if (selection.prepareRotate()) {
                            selection.saveForRotate();
                            selection.rotate(+0.5 * Math.PI);
                            selection.finalize();
                        }
                    }
                }
            });
        }
        get buttonLock() {
            let result = this._buttonLock;
            if (result == null) {
                result = this.newButtonLock();
                this._buttonLock = result;
            }
            return result;
        }
        newButtonLock() {
            return new wcardinalUi.DButtonCheck({
                theme: "EButtonEditorLock",
                on: {
                    active: () => {
                        this._selection.lockCapability(wcardinalUi.EShapeCapability.COORDINATE);
                    },
                    inactive: () => {
                        this._selection.unlockCapability(wcardinalUi.EShapeCapability.COORDINATE);
                    }
                }
            });
        }
        onSelectionChange(selection) {
            const last = selection.last();
            this.state.isDisabled = last == null;
            const hasPositionCapability = wcardinalUi.EShapeCapabilities.contains(last, wcardinalUi.EShapeCapability.POSITION);
            this.inputPositionX.state.isEnabled = hasPositionCapability;
            this.inputPositionY.state.isEnabled = hasPositionCapability;
            this.inputPositionLeft.state.isEnabled = hasPositionCapability;
            this.inputPositionTop.state.isEnabled = hasPositionCapability;
            this.inputRotation.state.isEnabled = wcardinalUi.EShapeCapabilities.contains(last, wcardinalUi.EShapeCapability.ROTATION);
            this.inputSizeX.state.isEnabled = wcardinalUi.EShapeCapabilities.contains(last, wcardinalUi.EShapeCapability.WIDTH);
            this.inputSizeY.state.isEnabled = wcardinalUi.EShapeCapabilities.contains(last, wcardinalUi.EShapeCapability.HEIGHT);
            this.inputSkew.state.isEnabled = wcardinalUi.EShapeCapabilities.contains(last, wcardinalUi.EShapeCapability.SKEW);
            this.buttonLock.state.isActive = this.isLocked(last);
            this.updateInputs(selection.get());
        }
        isLocked(last) {
            if (last == null) {
                return false;
            }
            const capability = last.getCapability();
            if (capability == null) {
                return false;
            }
            const target = wcardinalUi.EShapeCapability.COORDINATE;
            if (capability.locked & target) {
                return true;
            }
            return false;
        }
        renderInputs() {
            this._updateInputId = null;
            if (this._isUpdateInputShapeChanged) {
                this._isUpdateInputShapeChanged = false;
                const shape = this._updateInputShape;
                if (shape != null) {
                    const transform = shape.transform;
                    const position = transform.position;
                    const size = shape.size;
                    this.inputId.input.value = shape.id;
                    this.inputPositionX.input.value = position.x;
                    this.inputPositionY.input.value = position.y;
                    this.inputSizeX.input.value = size.x;
                    this.inputSizeY.input.value = size.y;
                    this.inputRotation.input.value = transform.rotation;
                    this.inputSkew.input.value = transform.skew.x;
                    const rectangle = this._workRectangle;
                    shape.getBoundsLocal(false, rectangle);
                    this.inputPositionLeft.input.value = rectangle.x;
                    this.inputPositionTop.input.value = rectangle.y;
                }
                this._updateInputId = window.setTimeout(this._renderInputsBound, 100);
            }
        }
        updateInputs(shapes) {
            const shape = 0 < shapes.length ? shapes[shapes.length - 1] : null;
            this._updateInputShape = shape;
            this._isUpdateInputShapeChanged = true;
            if (this._updateInputId == null) {
                this.renderInputs();
            }
        }
        getType() {
            return "EEditorCoordinate";
        }
    }

    class EEditorDataMapping extends wcardinalUi.DLayoutVertical {
        constructor(options) {
            super(options);
            // Selection
            const selection = options.selection;
            this._selection = selection;
            // Icons
            this._icons = options.icons;
            // Layout
            this.addChild(new wcardinalUi.DLayoutHorizontal({
                x: "padding",
                width: "padding",
                height: "auto",
                children: [
                    this.newTextLabel(),
                    this.buttonNew,
                    this.buttonDelete,
                    this.buttonBringForward,
                    this.buttonSendBackward
                ]
            }));
            this.addChild(this.listDataMappingValue);
            // Initialize
            selection.on("change", () => {
                this.onSelectionChange(selection);
            });
            const listDataMappingValue = this.listDataMappingValue;
            listDataMappingValue.selection.on("change", () => {
                this.onListDataMappingValueSelectionChange(listDataMappingValue);
            });
            this.onSelectionChange(selection);
        }
        newTextLabel() {
            return new wcardinalUi.DText({
                weight: 1,
                text: {
                    value: this.theme.getLabel()
                }
            });
        }
        get buttonNew() {
            let result = this._buttonNew;
            if (result == null) {
                result = this.newButtonNew();
                this._buttonNew = result;
            }
            return result;
        }
        newButtonNew() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.new
                },
                title: this.theme.getButtonNewTitle(),
                on: {
                    active: (emitter) => {
                        this.onButtonNewActive(emitter);
                    }
                }
            });
        }
        onButtonNewActive(opener) {
            this.dialogDataMappingValue
                .set(null, this._selection.last())
                .open(opener)
                .then((value) => {
                if (value != null) {
                    this._selection.addDataMappingValue(value);
                }
            });
        }
        get buttonDelete() {
            let result = this._buttonDelete;
            if (result == null) {
                result = this.newButtonDelete();
                this._buttonDelete = result;
            }
            return result;
        }
        newButtonDelete() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.delete
                },
                title: this.theme.getButtonDeleteTitle(),
                state: wcardinalUi.DBaseState.DISABLED,
                on: {
                    active: () => {
                        const first = this.listDataMappingValue.selection.first;
                        if (first != null) {
                            this._selection.removeDataMappingValue(first);
                        }
                    }
                }
            });
        }
        onListDataMappingValueSelectionChangeButtonDelete(listDataMappingValue) {
            this.buttonDelete.state.isDisabled = listDataMappingValue.data.selection.isEmpty();
        }
        get buttonBringForward() {
            let result = this._buttonBringForward;
            if (result == null) {
                result = this.newButtonBringForward();
                this._buttonBringForward = result;
            }
            return result;
        }
        newButtonBringForward() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.arrow_up
                },
                title: this.theme.getButtonBringForwardTitle(),
                state: wcardinalUi.DBaseState.DISABLED,
                on: {
                    active: () => {
                        const listDataMappingValue = this.listDataMappingValue;
                        const first = listDataMappingValue.data.selection.first;
                        const items = listDataMappingValue.data.items;
                        if (first != null && items[0] !== first) {
                            this._selection.bringDataMappingValueForward(first);
                        }
                    }
                }
            });
        }
        onListDataMappingValueSelectionChangeButtonBringForward(listDataMappingValue) {
            const first = listDataMappingValue.data.selection.first;
            const items = listDataMappingValue.data.items;
            this.buttonBringForward.state.isDisabled = first == null || items[0] === first;
        }
        get buttonSendBackward() {
            let result = this._buttonSendBackward;
            if (result == null) {
                result = this.newButtonSendBackward();
                this._buttonSendBackward = result;
            }
            return result;
        }
        newButtonSendBackward() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.arrow_down
                },
                title: this.theme.getButtonSendBackwardTitle(),
                state: wcardinalUi.DBaseState.DISABLED,
                on: {
                    active: () => {
                        const listDataMappingValue = this.listDataMappingValue;
                        const first = listDataMappingValue.data.selection.first;
                        const items = listDataMappingValue.data.items;
                        if (first != null && items[items.length - 1] !== first) {
                            this._selection.sendDataMappingValueBackward(first);
                        }
                    }
                }
            });
        }
        onListDataMappingValueSelectionChangeButtonSendBackward(listDataMappingValue) {
            const first = listDataMappingValue.data.selection.first;
            const items = listDataMappingValue.data.items;
            this.buttonSendBackward.state.isDisabled =
                first == null || items[items.length - 1] === first;
        }
        get dialogDataMappingValue() {
            let result = this._dialogDataMappingValue;
            if (result == null) {
                result = this.newDialogDataMappingValue();
                this._dialogDataMappingValue = result;
            }
            return result;
        }
        newDialogDataMappingValue() {
            return new EDialogDataMappingValue();
        }
        get listDataMappingValue() {
            let result = this._listDataMappingValue;
            if (result == null) {
                result = this.newListDataMappingValue();
                this._listDataMappingValue = result;
            }
            return result;
        }
        newListDataMappingValue() {
            const result = new wcardinalUi.DList({
                width: "padding",
                weight: 1,
                data: {
                    toLabel: (value) => {
                        const source = value[0];
                        const destination = value[1];
                        const initial = value[2];
                        if (0 < destination.length) {
                            if (0 < initial.length) {
                                return `${source} -> ${destination}, ${initial}`;
                            }
                            else {
                                return `${source} -> ${destination}`;
                            }
                        }
                        else {
                            if (0 < initial.length) {
                                return `${source} -> ${initial}`;
                            }
                            else {
                                return `${source}`;
                            }
                        }
                    }
                },
                updater: {
                    newItem: (data) => {
                        return new wcardinalUi.DListItem(data, {
                            on: {
                                dblclick: (e, _, item) => {
                                    this.onListDataMappingValueDblClick(e, _, item, result);
                                }
                            }
                        });
                    }
                }
            });
            return result;
        }
        onListDataMappingValueDblClick(e, _, item, list) {
            const oldValue = item.value;
            if (oldValue != null) {
                this.dialogDataMappingValue
                    .set(oldValue, this._selection.last())
                    .open(item)
                    .then((newValue) => {
                    if (newValue != null) {
                        this._selection.replaceDataMappingValue(oldValue, newValue, list);
                    }
                });
            }
        }
        onSelectionChangeListDataMappingValue(selection) {
            var _a, _b;
            const listDataMappingValue = this.listDataMappingValue;
            listDataMappingValue.data.items = ((_b = (_a = selection.last()) === null || _a === void 0 ? void 0 : _a.data.getMapping()) === null || _b === void 0 ? void 0 : _b.values) || [];
            this.onListDataMappingValueSelectionChange(listDataMappingValue);
        }
        onSelectionChange(selection) {
            this.state.isDisabled = !wcardinalUi.EShapeCapabilities.contains(selection.last(), wcardinalUi.EShapeCapability.DATA_MAPPING);
            this.onSelectionChangeListDataMappingValue(selection);
        }
        onListDataMappingValueSelectionChange(listDataMappingValue) {
            this.onListDataMappingValueSelectionChangeButtonDelete(listDataMappingValue);
            this.onListDataMappingValueSelectionChangeButtonBringForward(listDataMappingValue);
            this.onListDataMappingValueSelectionChangeButtonSendBackward(listDataMappingValue);
        }
        getType() {
            return "EEditorDataMapping";
        }
    }

    class EEditorData extends wcardinalUi.DLayoutVertical {
        constructor(options) {
            super(options);
            // Selection
            const selection = options.selection;
            this._selection = selection;
            // Icons
            this._icons = options.icons;
            // Layout
            this.addChild(new wcardinalUi.DLayoutHorizontal({
                x: "padding",
                width: "padding",
                height: "auto",
                children: [
                    this.newTextLabel(),
                    this.buttonNew,
                    this.buttonDelete,
                    this.buttonBringForward,
                    this.buttonSendBackward
                ]
            }));
            this.addChild(this.listDataValue);
            // Initialize
            selection.on("change", () => {
                this.onSelectionChange(selection);
            });
            const listDataValue = this.listDataValue;
            listDataValue.selection.on("change", () => {
                this.onListDataValueSelectionChange(listDataValue);
            });
            this.onSelectionChange(selection);
        }
        newTextLabel() {
            return new wcardinalUi.DText({
                weight: 1,
                text: {
                    value: this.theme.getLabel()
                }
            });
        }
        get buttonNew() {
            let result = this._buttonNew;
            if (result == null) {
                result = this.newButtonNew();
                this._buttonNew = result;
            }
            return result;
        }
        newButtonNew() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.new
                },
                title: this.theme.getButtonNewTitle(),
                on: {
                    active: (emitter) => {
                        this.onButtonNewActive(emitter);
                    }
                }
            });
        }
        onButtonNewActive(opener) {
            this.dialogDataValue
                .reset()
                .open(opener)
                .then((value) => {
                if (value != null) {
                    this._selection.addDataValue(value);
                }
            });
        }
        get buttonDelete() {
            let result = this._buttonDelete;
            if (result == null) {
                result = this.newButtonDelete();
                this._buttonDelete = result;
            }
            return result;
        }
        newButtonDelete() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.delete
                },
                title: this.theme.getButtonDeleteTitle(),
                state: wcardinalUi.DBaseState.DISABLED,
                on: {
                    active: () => {
                        const first = this.listDataValue.selection.first;
                        if (first != null) {
                            this._selection.removeDataValue(first);
                        }
                    }
                }
            });
        }
        onListDataValueSelectionChangeButtonDelete(listDataValue) {
            this.buttonDelete.state.isDisabled = listDataValue.data.selection.isEmpty();
        }
        get buttonBringForward() {
            let result = this._buttonBringForward;
            if (result == null) {
                result = this.newButtonBringForward();
                this._buttonBringForward = result;
            }
            return result;
        }
        newButtonBringForward() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.arrow_up
                },
                title: this.theme.getButtonBringForwardTitle(),
                state: wcardinalUi.DBaseState.DISABLED,
                on: {
                    active: () => {
                        const listDataValue = this.listDataValue;
                        const first = listDataValue.data.selection.first;
                        const items = listDataValue.data.items;
                        if (first != null && items[0] !== first) {
                            this._selection.bringDataValueForward(first);
                        }
                    }
                }
            });
        }
        onListDataValueSelectionChangeButtonBringForward(listDataValue) {
            const first = listDataValue.data.selection.first;
            const items = listDataValue.data.items;
            this.buttonBringForward.state.isDisabled = first == null || items[0] === first;
        }
        get buttonSendBackward() {
            let result = this._buttonSendBackward;
            if (result == null) {
                result = this.newButtonSendBackward();
                this._buttonSendBackward = result;
            }
            return result;
        }
        newButtonSendBackward() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.arrow_down
                },
                title: this.theme.getButtonSendBackwardTitle(),
                state: wcardinalUi.DBaseState.DISABLED,
                on: {
                    active: () => {
                        const listDataValue = this.listDataValue;
                        const first = listDataValue.data.selection.first;
                        const items = listDataValue.data.items;
                        if (first != null && items[items.length - 1] !== first) {
                            this._selection.sendDataValueBackward(first);
                        }
                    }
                }
            });
        }
        onListDataValueSelectionChangeButtonSendBackward(listDataValue) {
            const first = listDataValue.data.selection.first;
            const items = listDataValue.data.items;
            this.buttonSendBackward.state.isDisabled =
                first == null || items[items.length - 1] === first;
        }
        get dialogDataValue() {
            let result = this._dialogDataValue;
            if (result == null) {
                result = this.newDialogDataValue();
                this._dialogDataValue = result;
            }
            return result;
        }
        newDialogDataValue() {
            return new EDialogDataValue();
        }
        get listDataValue() {
            let result = this._listDataValue;
            if (result == null) {
                result = this.newListDataValue();
                this._listDataValue = result;
            }
            return result;
        }
        newListDataValue() {
            const result = new wcardinalUi.DList({
                width: "padding",
                weight: 1,
                data: {
                    toLabel: (value) => {
                        const type = value.type;
                        const as = value.as;
                        const prefix = 0 < as.length ? `${as}: ` : "";
                        switch (type) {
                            case wcardinalUi.EShapeDataValueType.BOOLEAN:
                            case wcardinalUi.EShapeDataValueType.BOOLEAN_ARRAY:
                            case wcardinalUi.EShapeDataValueType.NUMBER:
                            case wcardinalUi.EShapeDataValueType.NUMBER_ARRAY:
                            case wcardinalUi.EShapeDataValueType.STRING:
                            case wcardinalUi.EShapeDataValueType.STRING_ARRAY:
                            case wcardinalUi.EShapeDataValueType.OBJECT:
                            case wcardinalUi.EShapeDataValueType.OBJECT_ARRAY:
                                return prefix + value.id;
                            case wcardinalUi.EShapeDataValueType.TICKER:
                                return prefix + `Ticker ${value.initial} ms`;
                            default:
                                const extension = wcardinalUi.EShapeDataValueExtensions.get(type);
                                if (extension) {
                                    return prefix + extension.label;
                                }
                                return prefix + "Unknown";
                        }
                    }
                },
                updater: {
                    newItem: (data) => {
                        return new wcardinalUi.DListItem(data, {
                            on: {
                                dblclick: (e, _, item) => {
                                    this.onListDataValueDblClick(e, _, item, result);
                                }
                            }
                        });
                    }
                }
            });
            return result;
        }
        onListDataValueDblClick(e, _, item, list) {
            const oldValue = item.value;
            if (oldValue != null) {
                const dialogDataValue = this.dialogDataValue;
                dialogDataValue.value = oldValue;
                dialogDataValue.open(item).then((newValue) => {
                    if (newValue != null) {
                        this._selection.replaceDataValue(oldValue, newValue, list);
                    }
                });
            }
        }
        onSelectionChangeListDataValue(selection) {
            var _a;
            const listDataValue = this.listDataValue;
            listDataValue.data.items = ((_a = selection.last()) === null || _a === void 0 ? void 0 : _a.data.values) || [];
            this.onListDataValueSelectionChange(listDataValue);
        }
        onSelectionChange(selection) {
            this.state.isDisabled = selection.isEmpty();
            this.onSelectionChangeListDataValue(selection);
        }
        onListDataValueSelectionChange(listDataValue) {
            this.onListDataValueSelectionChangeButtonDelete(listDataValue);
            this.onListDataValueSelectionChangeButtonBringForward(listDataValue);
            this.onListDataValueSelectionChangeButtonSendBackward(listDataValue);
        }
        getType() {
            return "EEditorData";
        }
    }

    class EEditorLayerItem extends wcardinalUi.DListItem {
        constructor(iconsEye, iconsEyeSlash, work, data, options) {
            super(data, options);
            this._iconsEye = iconsEye;
            this._iconsEyeSlash = iconsEyeSlash;
            this._iconsWork = work;
        }
        onSelect(e, value) {
            if (e != null) {
                const local = this._iconsWork;
                if ("data" in e) {
                    this.toLocal(e.data.global, undefined, local);
                    if (local.x <= this._iconsEye.width + this.padding.getLeft()) {
                        this.emit("eyeclick", e, value, this);
                        return;
                    }
                }
            }
            super.onSelect(e, value);
        }
        onDblClick(e, interactionManager) {
            const global = wcardinalUi.UtilPointerEvent.toGlobal(e, interactionManager, this._iconsWork);
            const local = this.toLocal(global, undefined, global);
            if (this._iconsEye.width + this.padding.getLeft() < local.x) {
                return super.onDblClick(e, interactionManager);
            }
            else {
                this.emit("eyedblclick", e, interactionManager, this);
                return false;
            }
        }
    }

    class EEditorLayer extends wcardinalUi.DLayoutVertical {
        constructor(options) {
            super(options);
            this._icons = options.icons;
            this._diagram = options.diagram;
            this._selection = options.selection;
            this._isInitialized = false;
            this._canvas = null;
        }
        show() {
            super.show();
            this.onShow();
            return this;
        }
        onShow() {
            if (!this._isInitialized) {
                this._isInitialized = true;
                this.initLayout();
            }
            this.onCanvasChange(this._diagram.canvas, true);
        }
        initLayout() {
            this.addChild(new wcardinalUi.DLayoutHorizontal({
                x: "padding",
                width: "padding",
                height: "auto",
                children: [
                    this.newTextLabel(),
                    this.buttonNew,
                    this.buttonDelete,
                    this.buttonBringForward,
                    this.buttonSendBackward
                ]
            }));
            this.addChild(this.list);
            // Layer change even handling
            const diagram = this._diagram;
            diagram.on("set", (newCanvas) => {
                if (this.isShown()) {
                    this.onCanvasChange(newCanvas, false);
                }
            });
            diagram.on("ready", () => {
                if (this.isShown()) {
                    this.onLayerChange();
                }
            });
            diagram.on("unset", () => {
                if (this.isShown()) {
                    this.onCanvasChange(null, false);
                }
            });
        }
        newTextLabel() {
            return new wcardinalUi.DText({
                weight: 1,
                text: {
                    value: this.theme.getLabel()
                }
            });
        }
        get onLayerChangeBound() {
            let result = this._onLayerChangeBound;
            if (result == null) {
                result = () => {
                    this.onLayerChange();
                };
                this._onLayerChangeBound = result;
            }
            return result;
        }
        get dialog() {
            let result = this._dialog;
            if (result == null) {
                result = this.newDialog();
                this._dialog = result;
            }
            return result;
        }
        newDialog() {
            return new EDialogLayer();
        }
        get buttonNew() {
            let result = this._buttonNew;
            if (result == null) {
                result = this.newButtonNew();
                this._buttonNew = result;
            }
            return result;
        }
        newButtonNew() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.new
                },
                title: this.theme.getButtonNewTitle(),
                on: {
                    active: (emitter) => {
                        this.onButtonNewActive(emitter);
                    }
                }
            });
        }
        onButtonNewActive(opener) {
            const canvas = this._canvas;
            if (canvas) {
                const dialogLayer = this.dialog;
                dialogLayer
                    .reset(canvas.width, canvas.height)
                    .open(opener)
                    .then((value) => {
                    if (value) {
                        wcardinalUi.DControllers.getCommandController().push(new ECommandLayerCreate(value, canvas.layer, this._selection));
                    }
                });
            }
        }
        get buttonDelete() {
            let result = this._buttonDelete;
            if (result == null) {
                result = this.newButtonDelete();
                this._buttonDelete = result;
            }
            return result;
        }
        newButtonDelete() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.delete
                },
                title: this.theme.getButtonDeleteTitle(),
                on: {
                    active: () => {
                        const canvas = this._canvas;
                        if (canvas) {
                            const layer = canvas.layer;
                            const size = layer.size();
                            const active = layer.active;
                            if (1 < size && active) {
                                wcardinalUi.DControllers.getCommandController().push(new ECommandLayerDelete(active, canvas.layer, this._selection));
                            }
                        }
                    }
                }
            });
        }
        get buttonBringForward() {
            let result = this._buttonBringForward;
            if (result == null) {
                result = this.newButtonBringForward();
                this._buttonBringForward = result;
            }
            return result;
        }
        newButtonBringForward() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.arrow_up
                },
                title: this.theme.getButtonBringForwardTitle(),
                on: {
                    active: () => {
                        const canvas = this._canvas;
                        if (canvas) {
                            const layer = canvas.layer;
                            const active = layer.active;
                            if (active) {
                                const index = layer.children.indexOf(active);
                                wcardinalUi.DControllers.getCommandController().push(new ECommandLayerBringForward(index, layer));
                            }
                        }
                    }
                }
            });
        }
        get buttonSendBackward() {
            let result = this._buttonSendBackward;
            if (result == null) {
                result = this.newButtonSendBackward();
                this._buttonSendBackward = result;
            }
            return result;
        }
        newButtonSendBackward() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.arrow_down
                },
                title: this.theme.getButtonSendBackwardTitle(),
                on: {
                    active: () => {
                        const canvas = this._canvas;
                        if (canvas) {
                            const layer = canvas.layer;
                            const active = layer.active;
                            if (active) {
                                const index = layer.children.indexOf(active);
                                wcardinalUi.DControllers.getCommandController().push(new ECommandLayerSendBackward(index, layer));
                            }
                        }
                    }
                }
            });
        }
        get list() {
            let result = this._list;
            if (result == null) {
                result = this.newList();
                this._list = result;
            }
            return result;
        }
        newList() {
            const icons = this._icons;
            const iconsEye = icons.eye;
            const iconsEyeSlash = icons.eye_slash;
            const work = new pixi_js.Point();
            const result = new wcardinalUi.DList({
                x: "padding",
                width: "padding",
                weight: 1,
                data: {
                    selection: {
                        on: {
                            change: () => {
                                this.onListSelectionChange();
                            }
                        }
                    },
                    toImage: (layer) => {
                        return layer.visible ? iconsEye : iconsEyeSlash;
                    }
                },
                updater: {
                    newItem: (data) => {
                        return new EEditorLayerItem(iconsEye, iconsEyeSlash, work, data, {
                            on: {
                                eyeclick: (e, value, item) => {
                                    if (value) {
                                        if (value.visible) {
                                            value.visible = false;
                                            item.image = iconsEyeSlash;
                                        }
                                        else {
                                            value.visible = true;
                                            item.image = iconsEye;
                                        }
                                    }
                                },
                                dblclick: (e, _, item) => {
                                    this.onListDblClick(e, _, item, result);
                                }
                            }
                        });
                    }
                },
                on: {
                    keydown: (e) => {
                        if (wcardinalUi.UtilKeyboardEvent.isDeleteKey(e)) {
                            const canvas = this._canvas;
                            if (canvas) {
                                const layer = canvas.layer;
                                const size = layer.size();
                                const active = layer.active;
                                if (1 < size && active) {
                                    wcardinalUi.DControllers.getCommandController().push(new ECommandLayerDelete(active, layer, this._selection));
                                }
                            }
                        }
                    }
                }
            });
            return result;
        }
        onListDblClick(e, _, item, list) {
            const canvas = this._canvas;
            if (canvas) {
                const layerActive = canvas.layer.active;
                if (layerActive) {
                    const oldValue = EDialogLayerValue.from(layerActive);
                    const dialogLayer = this.dialog;
                    dialogLayer.value = oldValue;
                    dialogLayer.open(item).then((newValue) => {
                        if (newValue && !newValue.isEqual(oldValue)) {
                            wcardinalUi.DControllers.getCommandController().push(new ECommandLayerChange(layerActive, newValue, canvas.layer));
                        }
                    });
                }
            }
        }
        onListLayerChange() {
            const listLayer = this.list;
            const canvas = this._canvas;
            if (canvas) {
                const layerContainer = canvas.layer;
                const layers = layerContainer.children;
                const layerActive = layerContainer.active;
                const items = listLayer.data.items;
                for (let i = 0, imax = layers.length; i < imax; ++i) {
                    items[i] = layers[imax - 1 - i];
                }
                items.length = layers.length;
                listLayer.update(true);
                if (layerActive != null) {
                    listLayer.data.selection.clearAndAdd(layerActive);
                }
                else {
                    listLayer.data.selection.clear();
                }
            }
            else {
                listLayer.data.items = [];
            }
        }
        onListSelectionChange() {
            const first = this.list.data.selection.first;
            if (first) {
                const canvas = this._canvas;
                if (canvas) {
                    const layerActive = canvas.layer.active;
                    if (layerActive !== first) {
                        // Unselect
                        const selection = this._selection;
                        if (!selection.isEmpty()) {
                            const before = selection.store();
                            if (selection.clear()) {
                                const after = selection.store();
                                wcardinalUi.DControllers.getCommandController().push(new ECommandShapeSelect(before, after, selection));
                            }
                        }
                        // Change the active layer
                        canvas.layer.active = first;
                    }
                }
            }
        }
        onCanvasChange(newCanvas, forcibly) {
            const oldCanvas = this._canvas;
            if (newCanvas !== this._canvas) {
                const onLayerChangeBound = this.onLayerChangeBound;
                if (oldCanvas != null) {
                    oldCanvas.layer.off("change", onLayerChangeBound);
                }
                this._canvas = newCanvas;
                if (newCanvas != null) {
                    this.state.isDisabled = false;
                    newCanvas.layer.on("change", onLayerChangeBound);
                }
                else {
                    this.state.isDisabled = true;
                }
                this.onLayerChange();
            }
            else if (forcibly) {
                this.onLayerChange();
            }
        }
        isActiveDeletable(canvas) {
            if (canvas) {
                return 1 < canvas.layer.size();
            }
            return false;
        }
        isActiveNotLast(canvas) {
            if (canvas) {
                const layer = canvas.layer;
                const layers = layer.children;
                const active = layer.active;
                if (active) {
                    return active !== layers[layers.length - 1];
                }
            }
            return false;
        }
        isActiveNotFirst(canvas) {
            if (canvas) {
                const layer = canvas.layer;
                const layers = layer.children;
                const active = layer.active;
                if (active) {
                    return active !== layers[0];
                }
            }
            return false;
        }
        onLayerChange() {
            // Update buttons
            const canvas = this._canvas;
            this.state.isEnabled = canvas != null;
            this.buttonDelete.state.isEnabled = this.isActiveDeletable(canvas);
            this.buttonSendBackward.state.isEnabled = this.isActiveNotFirst(canvas);
            this.buttonBringForward.state.isEnabled = this.isActiveNotLast(canvas);
            // Update the list
            this.onListLayerChange();
            // Update the modifier
            this._selection.updateModifier();
        }
        getType() {
            return "EEditorLayer";
        }
    }

    let shapeTypeTheme;
    const getShapeTypeTheme = () => {
        return (shapeTypeTheme !== null && shapeTypeTheme !== void 0 ? shapeTypeTheme : (shapeTypeTheme = wcardinalUi.DThemes.get("FShapeType")));
    };

    const toShapeLabel = (shape) => {
        const id = shape.id;
        if (0 < id.length) {
            return id;
        }
        const shapeType = shape.type;
        if (wcardinalUi.EShapeType.EXTENSION <= shapeType) {
            const extension = EShapeExtensions.get(shapeType);
            if (extension && "name" in extension) {
                const name = extension.name;
                if (name != null) {
                    return name;
                }
            }
            return getShapeTypeTheme().getLabel(shapeType);
        }
        else if (shapeType === wcardinalUi.EShapeType.EMBEDDED) {
            if (shape instanceof wcardinalUi.EShapeEmbedded) {
                return shape.name;
            }
            else {
                return getShapeTypeTheme().getLabel(shapeType);
            }
        }
        return getShapeTypeTheme().getLabel(shapeType);
    };

    const EEditorSearchConditionState = {
        NONE: -1,
        UNCONNECTED: 0,
        CONNECTED_PARTIALLY: 1,
        CONNECTED_FULLY: 2
    };

    const EEditorSearchConditionType = {
        NONE: -1
    };

    const toShapeTypeLabel = (shapeType) => {
        if (wcardinalUi.EShapeType.EXTENSION <= shapeType) {
            const extension = EShapeExtensions.get(shapeType);
            if (extension && "name" in extension) {
                const name = extension.name;
                if (name != null) {
                    return name;
                }
            }
            return getShapeTypeTheme().getLabel(shapeType);
        }
        return getShapeTypeTheme().getLabel(shapeType);
    };

    class EEditorSearch extends wcardinalUi.DLayoutVertical {
        constructor(options) {
            var _a;
            super(options);
            // Selection
            const selection = options.selection;
            this._selection = selection;
            // Icons
            this._icons = options.icons;
            // Finder
            this._finder = options.finder;
            // Interval
            this._interval = (_a = options.interval) !== null && _a !== void 0 ? _a : 333;
            // Diagram
            const diagram = options.diagram;
            this._diagram = diagram;
            this.state.isDisabled = diagram.canvas == null;
            diagram.on("unset", () => {
                this.list.data.clear();
                this.state.isDisabled = true;
            });
            diagram.on("set", () => {
                this.state.isDisabled = false;
            });
            // Layout
            this.addChild(this.newTextLabel());
            if (this._finder != null) {
                this.addChild(this.inputSearch);
            }
            else {
                this.addChild(new wcardinalUi.DLayoutHorizontal({
                    width: "padding",
                    height: "auto",
                    children: [
                        new wcardinalUi.DInputLabel({
                            width: 60,
                            text: {
                                value: this.theme.getInputIdLabel()
                            }
                        }),
                        this.inputId
                    ]
                }));
                this.addChild(new wcardinalUi.DLayoutHorizontal({
                    width: "padding",
                    height: "auto",
                    children: [
                        new wcardinalUi.DInputLabel({
                            width: 60,
                            text: {
                                value: this.theme.getSelectTypeLabel()
                            }
                        }),
                        this.selectType
                    ]
                }));
                this.addChild(new wcardinalUi.DLayoutHorizontal({
                    width: "padding",
                    height: "auto",
                    children: [
                        new wcardinalUi.DInputLabel({
                            width: 60,
                            text: {
                                value: this.theme.getSelectStateLabel()
                            }
                        }),
                        this.selectState
                    ]
                }));
                this.addChild(this.buttonExecute);
            }
            this.addChild(this.list);
        }
        newTextLabel() {
            return new wcardinalUi.DText({
                x: "padding",
                width: "padding",
                text: {
                    value: this.theme.getLabel()
                }
            });
        }
        get inputSearch() {
            var _a;
            return ((_a = this._inputSearch) !== null && _a !== void 0 ? _a : (this._inputSearch = this.newInputSearch()));
        }
        newInputSearch() {
            return new wcardinalUi.DInputSearch({
                x: "padding",
                width: "padding",
                on: {
                    input: (newValue) => {
                        this.search(newValue);
                    },
                    enter: (emitter) => {
                        this.search(emitter.value);
                    }
                }
            });
        }
        get inputId() {
            var _a;
            return ((_a = this._inputId) !== null && _a !== void 0 ? _a : (this._inputId = this.newInputId()));
        }
        newInputId() {
            return new wcardinalUi.DInputText({
                weight: 1,
                on: {
                    enter: () => {
                        this.buttonExecute.activate();
                    }
                }
            });
        }
        get selectType() {
            var _a;
            return ((_a = this._selectType) !== null && _a !== void 0 ? _a : (this._selectType = this.newSelectType()));
        }
        newSelectType() {
            return new wcardinalUi.DSelect({
                weight: 1,
                value: EEditorSearchConditionType.NONE,
                menu: {
                    width: "auto",
                    column: 3,
                    fit: false,
                    items: this.newSelectTypeMenuItems()
                }
            });
        }
        newSelectTypeMenuItems() {
            const result = [
                this.newSelectTypeMenuItem(EEditorSearchConditionType.NONE, this.theme.toTypeLabel(EEditorSearchConditionType.NONE)),
                this.newSelectTypeMenuItemShape(wcardinalUi.EShapeType.CIRCLE),
                this.newSelectTypeMenuItemShape(wcardinalUi.EShapeType.SEMICIRCLE),
                this.newSelectTypeMenuItemShape(wcardinalUi.EShapeType.RECTANGLE),
                this.newSelectTypeMenuItemShape(wcardinalUi.EShapeType.RECTANGLE_ROUNDED),
                this.newSelectTypeMenuItemShape(wcardinalUi.EShapeType.TRIANGLE),
                this.newSelectTypeMenuItemShape(wcardinalUi.EShapeType.TRIANGLE_ROUNDED),
                this.newSelectTypeMenuItemShape(wcardinalUi.EShapeType.LINE),
                this.newSelectTypeMenuItemShape(wcardinalUi.EShapeType.CONNECTOR_LINE),
                this.newSelectTypeMenuItemShape(wcardinalUi.EShapeType.CONNECTOR_ELBOW),
                this.newSelectTypeMenuItemShape(wcardinalUi.EShapeType.IMAGE),
                this.newSelectTypeMenuItemShape(wcardinalUi.EShapeType.GROUP),
                this.newSelectTypeMenuItemShape(wcardinalUi.EShapeType.BAR),
                this.newSelectTypeMenuItemShape(wcardinalUi.EShapeType.BUTTON),
                this.newSelectTypeMenuItemShape(wcardinalUi.EShapeType.EMBEDDED),
                this.newSelectTypeMenuItemShape(wcardinalUi.EShapeType.EMBEDDED_LAYER),
                this.newSelectTypeMenuItemShape(wcardinalUi.EShapeType.EMBEDDED_ACCEPTOR_EDGE)
            ];
            EShapeExtensions.each((extension) => {
                if ("type" in extension) {
                    result.push(this.newSelectTypeMenuItemShape(extension.type));
                }
            });
            return result;
        }
        newSelectTypeMenuItem(type, label) {
            return {
                width: 200,
                value: type,
                text: {
                    value: label
                }
            };
        }
        newSelectTypeMenuItemShape(type) {
            return this.newSelectTypeMenuItem(type, toShapeTypeLabel(type));
        }
        getSelectTypeValue() {
            const selectType = this._selectType;
            if (selectType != null) {
                const value = selectType.value;
                if (value != null && 0 <= value) {
                    return value;
                }
            }
            return null;
        }
        get selectState() {
            var _a;
            return ((_a = this._selectState) !== null && _a !== void 0 ? _a : (this._selectState = this.newSelectState()));
        }
        newSelectState() {
            const theme = this.theme;
            return new wcardinalUi.DSelect({
                weight: 1,
                value: EEditorSearchConditionState.NONE,
                menu: {
                    items: [
                        this.newSelectStateMenuItem(EEditorSearchConditionState.NONE, theme),
                        this.newSelectStateMenuItem(EEditorSearchConditionState.CONNECTED_FULLY, theme),
                        this.newSelectStateMenuItem(EEditorSearchConditionState.CONNECTED_PARTIALLY, theme),
                        this.newSelectStateMenuItem(EEditorSearchConditionState.UNCONNECTED, theme)
                    ]
                }
            });
        }
        newSelectStateMenuItem(state, theme) {
            return {
                value: state,
                text: {
                    value: theme.toStateLabel(state)
                }
            };
        }
        getSelectStateValue() {
            const result = this.selectState.value;
            if (result != null && 0 <= result) {
                return result;
            }
            return null;
        }
        get buttonExecute() {
            var _a;
            return ((_a = this._buttonExecute) !== null && _a !== void 0 ? _a : (this._buttonExecute = this.newButtonExecute()));
        }
        newButtonExecute() {
            return new wcardinalUi.DButtonPrimary({
                width: "padding",
                text: {
                    value: this.theme.getButtonExecuteTitle()
                },
                image: {
                    source: this._icons.editor_search
                },
                on: {
                    active: (emitter) => {
                        this.onButtonExecuteActive(emitter);
                    }
                }
            });
        }
        onButtonExecuteActive(opener) {
            var _a, _b;
            const indicator = this.indicatorExecute;
            indicator.start();
            const shapes = [];
            const canvas = this._diagram.canvas;
            if (canvas != null) {
                const id = this.inputId.value.trim();
                const type = (_a = this.selectType.value) !== null && _a !== void 0 ? _a : EEditorSearchConditionType.NONE;
                const state = (_b = this.selectState.value) !== null && _b !== void 0 ? _b : EEditorSearchConditionState.NONE;
                canvas.shape.each((shape) => {
                    if (0 < id.length && shape.id.indexOf(id) < 0) {
                        return true;
                    }
                    if (type !== EEditorSearchConditionType.NONE && type !== shape.type) {
                        return true;
                    }
                    switch (state) {
                        case EEditorSearchConditionState.CONNECTED_FULLY:
                            if (shape instanceof wcardinalUi.EShapeConnectorLine) {
                                const edge = shape.edge;
                                const tail = edge.tail.acceptor.shape;
                                const head = edge.head.acceptor.shape;
                                if (tail == null || head == null) {
                                    return true;
                                }
                            }
                            else {
                                if (shape.connector.size() <= 0) {
                                    return true;
                                }
                            }
                            break;
                        case EEditorSearchConditionState.CONNECTED_PARTIALLY:
                            if (shape instanceof wcardinalUi.EShapeConnectorLine) {
                                const edge = shape.edge;
                                const tail = edge.tail.acceptor.shape;
                                const head = edge.head.acceptor.shape;
                                if ((tail == null && head == null) || (tail != null && head != null)) {
                                    return true;
                                }
                            }
                            else {
                                return true;
                            }
                            break;
                        case EEditorSearchConditionState.UNCONNECTED:
                            if (shape instanceof wcardinalUi.EShapeConnectorLine) {
                                const edge = shape.edge;
                                const tail = edge.tail.acceptor.shape;
                                const head = edge.head.acceptor.shape;
                                if (tail != null || head != null) {
                                    return true;
                                }
                            }
                            else {
                                if (0 < shape.connector.size()) {
                                    return true;
                                }
                            }
                            break;
                    }
                    shapes.push(shape);
                    return true;
                });
            }
            this.list.data.clearAndAddAll(shapes);
            indicator.resolve();
        }
        get indicatorExecute() {
            var _a;
            return ((_a = this._indicatorExecute) !== null && _a !== void 0 ? _a : (this._indicatorExecute = this.newIndicatorExecute()));
        }
        newIndicatorExecute() {
            return new wcardinalUi.DIndicatorProcessing(this.buttonExecute);
        }
        search(word) {
            const threshold = 500;
            const searching = this._searching;
            const searched = this._searched;
            const searchedAt = this._searchedAt;
            if (searching !== searched || (searchedAt != null && Date.now() - searchedAt < threshold)) {
                this._requested = word;
                if (this._timeoutId == null) {
                    this._timeoutId = window.setTimeout(() => {
                        this._timeoutId = null;
                        const newWord = this._requested;
                        if (newWord != null) {
                            this._requested = undefined;
                            this.search(newWord);
                        }
                    }, threshold);
                }
            }
            else {
                const timeoutId = this._timeoutId;
                if (timeoutId != null) {
                    this._timeoutId = null;
                    window.clearTimeout(timeoutId);
                }
                this._searching = word;
                this.doSearch(word).then((result) => {
                    this.list.data.clearAndAddAll(result.shapes);
                    this._searched = result.word;
                    this._searchedAt = Date.now();
                });
            }
        }
        doSearch(word) {
            const finder = this._finder;
            if (finder == null) {
                return Promise.resolve({
                    word,
                    shapes: []
                });
            }
            const canvas = this._diagram.canvas;
            if (canvas == null) {
                return Promise.resolve({
                    word,
                    shapes: []
                });
            }
            const trimmed = word.trim();
            if (trimmed.length <= 0) {
                return Promise.resolve({
                    word,
                    shapes: []
                });
            }
            try {
                const found = finder(canvas, trimmed);
                if (wcardinalUi.isArray(found)) {
                    return Promise.resolve({
                        word,
                        shapes: found
                    });
                }
                else {
                    return found.then((shapes) => {
                        return {
                            word,
                            shapes
                        };
                    }, () => {
                        return {
                            word,
                            shapes: []
                        };
                    });
                }
            }
            catch (_a) {
                return Promise.resolve({
                    word,
                    shapes: []
                });
            }
        }
        get list() {
            var _a;
            return ((_a = this._list) !== null && _a !== void 0 ? _a : (this._list = this.newList()));
        }
        newList() {
            return new wcardinalUi.DList({
                width: "padding",
                weight: 1,
                data: {
                    toLabel: (value) => {
                        return toShapeLabel(value);
                    },
                    toTitle: (value) => {
                        return undefined;
                    },
                    toImage: (value) => {
                        return null;
                    }
                },
                updater: {
                    newItem: (data) => {
                        return new wcardinalUi.DListItem(data, {
                            on: {
                                select: (value, item) => {
                                    this.onListItemDown(value, item);
                                }
                            }
                        });
                    }
                }
            });
        }
        onListItemDown(value, item) {
            const shape = value;
            if (shape != null) {
                const canvas = this._diagram.canvas;
                const layer = shape.root.parent;
                if (canvas != null && layer != null) {
                    // Selection
                    const selection = this._selection;
                    const before = selection.store();
                    if (selection.set(shape)) {
                        selection.focus();
                        const after = selection.store();
                        wcardinalUi.DControllers.getCommandController().push(new ECommandShapeSelect(before, after, selection));
                    }
                    else {
                        selection.focus();
                    }
                    // Change the active layer
                    const layerActive = canvas.layer.active;
                    if (layerActive !== layer) {
                        canvas.layer.active = layer;
                    }
                }
                else {
                    this.dialogError.open(item);
                }
            }
        }
        get dialogError() {
            var _a;
            return ((_a = this._dialogError) !== null && _a !== void 0 ? _a : (this._dialogError = this.newDialogError()));
        }
        newDialogError() {
            return new wcardinalUi.DDialogMessage({
                message: this.theme.getDialogErrorLabel()
            });
        }
        get dialogProcessing() {
            var _a;
            return ((_a = this._dialogProcessing) !== null && _a !== void 0 ? _a : (this._dialogProcessing = this.newDialogProcessing()));
        }
        newDialogProcessing() {
            return new wcardinalUi.DDialogProcessing();
        }
        getType() {
            return "EEditorSearch";
        }
    }

    const EEDITOR_BUTTON_COUNT = 7;

    class EEditorShape extends wcardinalUi.DPane {
        constructor(options) {
            super(options);
            this._icons = options.icons;
            this._canvas = options.canvas;
            this._selection = options.selection;
            this._isInitialized = false;
            const piece = options.piece;
            if (piece) {
                this._isPieceEnabled = piece.enable;
                this._pieceExcluder = piece.exclude;
                this._controller = piece.controller;
            }
            else {
                this._isPieceEnabled = false;
            }
            this._isChangeable = options.changeable;
        }
        show() {
            super.show();
            this.onShow();
            return this;
        }
        onShow() {
            if (!this._isInitialized) {
                this._isInitialized = true;
                this.initLayout();
            }
            this.onSelectionChange();
        }
        initLayout() {
            new wcardinalUi.DLayoutVertical({
                parent: this.content,
                x: "padding",
                y: "padding",
                width: "padding",
                height: "auto",
                children: [
                    this.layoutChangeTo,
                    this.buttonFill,
                    this.buttonFillColor,
                    this.layoutTexture,
                    this.buttonStroke,
                    this.buttonStrokeColor,
                    this.inputStrokeWidth,
                    this.inputStrokeAlign,
                    this.layoutStrokeSide,
                    this.textCorner,
                    this.inputCornerRadius,
                    this.layoutCorner,
                    this.layoutLine,
                    this.selectLineStyle,
                    this.selectLineType,
                    this.layoutLineTail,
                    this.selectLineTailType,
                    this.layoutLineTailSize,
                    this.buttonLineTailColor,
                    this.inputLineTailMargin,
                    this.layoutLineHead,
                    this.selectLineHeadType,
                    this.layoutLineHeadSize,
                    this.buttonLineHeadColor,
                    this.inputLineHeadMargin
                ]
            });
            // Selection change handling
            this._selection.on("change", () => {
                if (this.isShown()) {
                    this.onSelectionChange();
                }
            });
        }
        get layoutChangeTo() {
            let result = this._layoutChangeTo;
            if (result === undefined) {
                result = this._isChangeable !== false ? this.newLayoutChangeTo() : null;
                this._layoutChangeTo = result;
            }
            return result;
        }
        newLayoutChangeTo() {
            const children = [
                this.newTextChangeToLabel(),
                this.buttonCircle,
                this.buttonSemicircle,
                this.buttonRectangle,
                this.buttonRectangleRounded,
                this.buttonTriangle,
                this.buttonTriangleRounded,
                this.buttonLine,
                this.buttonLineConnector,
                this.buttonElbowConnector,
                this.buttonImage,
                this.buttonGraphicPiece
            ];
            EShapeExtensionFactories.each((factory) => {
                children.push(this.newButtonExtensionFactory(factory));
            });
            EShapeExtensions.each((extension) => {
                if (this.isExtensionReplacable(extension)) {
                    const creator = extension.creator;
                    if (wcardinalUi.isFunction(creator)) {
                        children.push(this.newButtonExtension(extension, creator));
                    }
                }
            });
            children.push(this.buttonGroup, this.buttonUngroup);
            return new wcardinalUi.DLayoutVertical({
                width: "100%",
                height: "auto",
                column: EEDITOR_BUTTON_COUNT,
                children
            });
        }
        isExtensionReplacable(extension) {
            if ("icon" in extension) {
                if ("type" in extension) {
                    const capability = wcardinalUi.EShapeCapabilities.get(extension.type);
                    if (capability != null) {
                        if (capability & wcardinalUi.EShapeCapability.REPLACING) {
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                }
                return true;
            }
            return false;
        }
        newTextChangeToLabel() {
            return new wcardinalUi.DText({
                width: "100%",
                text: {
                    value: this.theme.getTextChangeToLabel()
                },
                clear: "AFTER"
            });
        }
        newButtonExtensionFactory(factory) {
            let selectDialog = null;
            return new wcardinalUi.DButtonAmbient({
                image: {
                    source: factory.icon.texture
                },
                title: this.toExtensionTitle(factory),
                theme: "EButtonEditor",
                on: {
                    active: (emitter) => {
                        selectDialog = selectDialog || this.newDialogSelectExtensionFactory(factory);
                        selectDialog.open(emitter);
                    }
                }
            });
        }
        newDialogSelectExtensionFactory(factory) {
            return new wcardinalUi.DDialogSelect({
                controller: factory,
                list: {
                    data: {
                        toLabel: factory.item.toLabel
                    }
                },
                on: {
                    select: (value) => {
                        factory.item.toCreator(value).then((creator) => {
                            this._selection.replace(creator);
                        });
                    }
                }
            });
        }
        newButtonExtension(extension, creator) {
            return new wcardinalUi.DButtonAmbient({
                image: {
                    source: extension.icon.texture
                },
                title: this.toExtensionTitle(extension),
                theme: "EButtonEditor",
                on: {
                    active: () => {
                        this._selection.replace(creator);
                    }
                }
            });
        }
        toExtensionTitle(extension) {
            const title = extension.title;
            if (wcardinalUi.isString(title)) {
                return title;
            }
            return title.change;
        }
        get buttonCircle() {
            var _a;
            return ((_a = this._buttonCircle) !== null && _a !== void 0 ? _a : (this._buttonCircle = this.newButtonCircle()));
        }
        newButtonCircle() {
            return new wcardinalUi.DButtonAmbient({
                image: {
                    source: this._icons.shape_circle
                },
                title: this.theme.getButtonCircleTitle(),
                theme: "EButtonEditor",
                on: {
                    active: () => {
                        this._selection.replace((existing) => {
                            if (existing.type !== wcardinalUi.EShapeType.CIRCLE) {
                                return new wcardinalUi.EShapeCircle().copy(existing);
                            }
                            return null;
                        });
                    }
                }
            });
        }
        get buttonSemicircle() {
            var _a;
            return ((_a = this._buttonSemicircle) !== null && _a !== void 0 ? _a : (this._buttonSemicircle = this.newButtonSemicircle()));
        }
        newButtonSemicircle() {
            return new wcardinalUi.DButtonAmbient({
                image: {
                    source: this._icons.shape_semicircle
                },
                title: this.theme.getButtonSemicircleTitle(),
                theme: "EButtonEditor",
                on: {
                    active: () => {
                        this._selection.replace((existing) => {
                            if (existing.type !== wcardinalUi.EShapeType.SEMICIRCLE) {
                                return new wcardinalUi.EShapeSemicircle().copy(existing);
                            }
                            return null;
                        });
                    }
                }
            });
        }
        get buttonRectangle() {
            var _a;
            return ((_a = this._buttonRectangle) !== null && _a !== void 0 ? _a : (this._buttonRectangle = this.newButtonRectangle()));
        }
        newButtonRectangle() {
            return new wcardinalUi.DButtonAmbient({
                image: {
                    source: this._icons.shape_rectangle
                },
                title: this.theme.getButtonRectangleTitle(),
                theme: "EButtonEditor",
                on: {
                    active: () => {
                        this._selection.replace((existing) => {
                            if (existing.type !== wcardinalUi.EShapeType.RECTANGLE) {
                                return new wcardinalUi.EShapeRectangle().copy(existing);
                            }
                            return null;
                        });
                    }
                }
            });
        }
        get buttonRectangleRounded() {
            var _a;
            return ((_a = this._buttonRectangleRounded) !== null && _a !== void 0 ? _a : (this._buttonRectangleRounded = this.newButtonRectangleRounded()));
        }
        newButtonRectangleRounded() {
            return new wcardinalUi.DButtonAmbient({
                image: {
                    source: this._icons.shape_rectangle_rounded
                },
                title: this.theme.getButtonRectangleRoundedTitle(),
                theme: "EButtonEditor",
                on: {
                    active: () => {
                        this._selection.replace((existing) => {
                            if (existing.type !== wcardinalUi.EShapeType.RECTANGLE_ROUNDED) {
                                return new wcardinalUi.EShapeRectangleRounded().copy(existing);
                            }
                            return null;
                        });
                    }
                }
            });
        }
        get buttonTriangle() {
            var _a;
            return ((_a = this._buttonTriangle) !== null && _a !== void 0 ? _a : (this._buttonTriangle = this.newButtonTriangle()));
        }
        newButtonTriangle() {
            return new wcardinalUi.DButtonAmbient({
                image: {
                    source: this._icons.shape_triangle
                },
                title: this.theme.getButtonTriangleTitle(),
                theme: "EButtonEditor",
                on: {
                    active: () => {
                        this._selection.replace((existing) => {
                            if (existing.type !== wcardinalUi.EShapeType.TRIANGLE) {
                                return new wcardinalUi.EShapeTriangle().copy(existing);
                            }
                            return null;
                        });
                    }
                }
            });
        }
        get buttonTriangleRounded() {
            var _a;
            return ((_a = this._buttonTriangleRounded) !== null && _a !== void 0 ? _a : (this._buttonTriangleRounded = this.newButtonTriangleRounded()));
        }
        newButtonTriangleRounded() {
            return new wcardinalUi.DButtonAmbient({
                image: {
                    source: this._icons.shape_triangle_rounded
                },
                title: this.theme.getButtonTriangleRoundedTitle(),
                theme: "EButtonEditor",
                on: {
                    active: () => {
                        this._selection.replace((existing) => {
                            if (existing.type !== wcardinalUi.EShapeType.TRIANGLE_ROUNDED) {
                                return new wcardinalUi.EShapeTriangleRounded().copy(existing);
                            }
                            return null;
                        });
                    }
                }
            });
        }
        get buttonLine() {
            var _a;
            return ((_a = this._buttonLine) !== null && _a !== void 0 ? _a : (this._buttonLine = this.newButtonLine()));
        }
        newButtonLine() {
            return new wcardinalUi.DButtonAmbient({
                image: {
                    source: this._icons.shape_line
                },
                title: this.theme.getButtonLineTitle(),
                theme: "EButtonEditor",
                on: {
                    active: () => {
                        this._selection.replace((existing) => {
                            return this.replaceLine(existing);
                        });
                    }
                }
            });
        }
        replaceLine(existing) {
            if (existing.type !== wcardinalUi.EShapeType.LINE) {
                if (existing instanceof wcardinalUi.EShapeConnectorLine) {
                    return new wcardinalUi.EShapeLine().copy(existing);
                }
                else {
                    const size = existing.size;
                    const sxh = size.x * 0.5;
                    const syh = size.y * 0.5;
                    return wcardinalUi.createLine([-sxh, -syh, +sxh, +syh], [], wcardinalUi.EShapeDefaults.STROKE_WIDTH, wcardinalUi.EShapePointsStyle.NONE).copy(existing, wcardinalUi.EShapeCopyPart.ALL & ~(wcardinalUi.EShapeCopyPart.SIZE | wcardinalUi.EShapeCopyPart.POINTS));
                }
            }
            return null;
        }
        isDanglingConnectorAllowed() {
            var _a, _b, _c;
            return (_c = (_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.connector) === null || _b === void 0 ? void 0 : _b.dangling) !== null && _c !== void 0 ? _c : false;
        }
        get buttonLineConnector() {
            var _a;
            return ((_a = this._buttonLineConnector) !== null && _a !== void 0 ? _a : (this._buttonLineConnector = this.newButtonLineConnector()));
        }
        newButtonLineConnector() {
            return new wcardinalUi.DButtonAmbient({
                image: {
                    source: this._icons.shape_line_connector
                },
                title: this.theme.getButtonLineConnectorTitle(),
                theme: "EButtonEditor",
                on: {
                    active: () => {
                        const isDanglingConnectorAllowed = this.isDanglingConnectorAllowed();
                        this._selection.replace((existing) => {
                            return this.replaceLineConnector(existing, isDanglingConnectorAllowed);
                        });
                    }
                }
            });
        }
        replaceLineConnector(existing, isDanglingConnectorAllowed) {
            if (existing.type !== wcardinalUi.EShapeType.CONNECTOR_LINE) {
                if (existing instanceof wcardinalUi.EShapeConnectorLine) {
                    return new wcardinalUi.EShapeConnectorLine().copy(existing);
                }
                else if (isDanglingConnectorAllowed) {
                    return this.replaceConnector(existing, new wcardinalUi.EShapeConnectorLine());
                }
            }
            return null;
        }
        get buttonElbowConnector() {
            var _a;
            return ((_a = this._buttonElbowConnector) !== null && _a !== void 0 ? _a : (this._buttonElbowConnector = this.newButtonElbowConnector()));
        }
        newButtonElbowConnector() {
            return new wcardinalUi.DButtonAmbient({
                image: {
                    source: this._icons.shape_elbow_connector
                },
                title: this.theme.getButtonElbowConnectorTitle(),
                theme: "EButtonEditor",
                on: {
                    active: () => {
                        const isDanglingConnectorAllowed = this.isDanglingConnectorAllowed();
                        this._selection.replace((existing) => {
                            return this.replaceElbowConnector(existing, isDanglingConnectorAllowed);
                        });
                    }
                }
            });
        }
        replaceElbowConnector(existing, isDanglingConnectorAllowed) {
            if (existing.type !== wcardinalUi.EShapeType.CONNECTOR_ELBOW) {
                if (existing instanceof wcardinalUi.EShapeConnectorLine) {
                    return new wcardinalUi.EShapeConnectorElbow().copy(existing);
                }
                else if (isDanglingConnectorAllowed) {
                    return this.replaceConnector(existing, new wcardinalUi.EShapeConnectorElbow());
                }
            }
            return null;
        }
        replaceConnector(existing, result) {
            result.lock(wcardinalUi.EShapeLockPart.ALL);
            result.fill.alpha = 1;
            const marker = result.points.marker;
            marker.tail.type = wcardinalUi.EShapePointsMarkerType.CIRCLE;
            marker.head.type = wcardinalUi.EShapePointsMarkerType.TRIANGLE;
            result.copy(existing, wcardinalUi.EShapeCopyPart.ALL &
                ~(wcardinalUi.EShapeCopyPart.SIZE | wcardinalUi.EShapeCopyPart.POINTS | wcardinalUi.EShapeCopyPart.TRANSFORM));
            const size = existing.size;
            const sxh = size.x * 0.5;
            const syh = size.y * 0.5;
            const localTransform = existing.transform.localTransform;
            const rx = localTransform.a * sxh + localTransform.c * syh;
            const ry = localTransform.b * sxh + localTransform.d * syh;
            const tx = localTransform.tx;
            const ty = localTransform.ty;
            const edge = result.edge;
            edge.lock();
            edge.tail.set(null, null, null, null, 0, -rx + tx, -ry + ty, undefined, undefined, wcardinalUi.EShapeAcceptorEdgeSide.TOP);
            edge.head.set(null, null, null, null, 0, +rx + tx, +ry + ty, undefined, undefined, wcardinalUi.EShapeAcceptorEdgeSide.TOP);
            edge.unlock();
            result.unlock(wcardinalUi.EShapeLockPart.ALL, true);
            return result;
        }
        get buttonImage() {
            var _a;
            return ((_a = this._buttonImage) !== null && _a !== void 0 ? _a : (this._buttonImage = this.newButtonImage()));
        }
        newButtonImage() {
            return new wcardinalUi.DButtonFile({
                image: {
                    source: this._icons.editor_image
                },
                as: wcardinalUi.DButtonFileAs.DATA_URL,
                title: this.theme.getButtonImageTitle(),
                theme: "EButtonEditor",
                on: {
                    open: (dataUrl) => {
                        wcardinalUi.toImageElement(dataUrl).then((item) => {
                            this._selection.replace((existing) => {
                                return new wcardinalUi.EShapeImage(item).copy(existing, wcardinalUi.EShapeCopyPart.ALL & ~wcardinalUi.EShapeCopyPart.IMAGE);
                            });
                        });
                    }
                }
            });
        }
        get buttonGraphicPiece() {
            let result = this._buttonGraphicPiece;
            if (result === undefined) {
                result = this._isPieceEnabled ? this.newButtonGraphicPiece() : null;
                this._buttonGraphicPiece = result;
            }
            return result;
        }
        newButtonGraphicPiece() {
            return new wcardinalUi.DButtonAmbient({
                image: {
                    source: this._icons.graphic_piece
                },
                title: this.theme.getButtonGraphicPieceTitle(),
                theme: "EButtonEditor",
                on: {
                    active: (emitter) => {
                        this.onButtonGraphicPieceActive(emitter);
                    }
                }
            });
        }
        onButtonGraphicPieceActive(opener) {
            this.dialogSelectGraphicPiece.then((dialogSelectGraphicPiece) => {
                dialogSelectGraphicPiece.open(opener);
            });
        }
        get dialogSelectGraphicPiece() {
            var _a;
            return ((_a = this._dialogSelectGraphicPiece) !== null && _a !== void 0 ? _a : (this._dialogSelectGraphicPiece = this.newDialogSelectGraphicPiece()));
        }
        newDialogSelectGraphicPiece() {
            return this._canvas.get().then((canvas) => {
                const controller = this._controller;
                if (controller) {
                    if (controller.toPieceThumbnail) {
                        const result = this.newDialogSelectGraphicPieceImage(controller);
                        result.categories = canvas.category.items;
                        return result;
                    }
                    else {
                        const result = this.newDialogSelectGraphicPieceNoImage(controller);
                        result.categories = canvas.category.items;
                        return result;
                    }
                }
                else {
                    const result = this.newDialogSelectGraphicPieceNoController();
                    result.categories = canvas.category.items;
                    return result;
                }
            });
        }
        newDialogSelectGraphicPieceNoImage(controller) {
            return new wcardinalUi.DDialogSelect({
                controller: this.newDialogSelectGraphicPieceController(controller),
                on: {
                    select: (value) => {
                        this.onDialogSelectGraphicPieceSelect(value, controller);
                    }
                }
            });
        }
        newDialogSelectGraphicPieceImage(controller) {
            return newDialogSelectWithThumbnails(this.newDialogSelectGraphicPieceController(controller), controller.toPieceThumbnail, (value) => {
                this.onDialogSelectGraphicPieceSelect(value, controller);
            });
        }
        newDialogSelectGraphicPieceNoController() {
            return new wcardinalUi.DDialogSelect({
                controller: {
                    search: () => {
                        return Promise.resolve([]);
                    }
                }
            });
        }
        newDialogSelectGraphicPieceController(controller) {
            const graphicPiece = controller.graphic.piece;
            return {
                search: (word, categoryId) => {
                    return graphicPiece.search(word, categoryId).then((pieces) => {
                        return this.toDialogSelectGraphicPieceResult(pieces);
                    });
                }
            };
        }
        toDialogSelectGraphicPieceResult(targets) {
            var _a;
            const pieceId = (_a = this._pieceExcluder) === null || _a === void 0 ? void 0 : _a.call(this);
            if (pieceId == null) {
                return targets;
            }
            const result = [];
            for (let i = 0, imax = targets.length; i < imax; ++i) {
                const target = targets[i];
                if (target.id !== pieceId) {
                    result.push(target);
                }
            }
            return result;
        }
        onDialogSelectGraphicPieceSelect(value, controller) {
            controller.graphic.piece.get(value.id).then((serialized) => {
                wcardinalUi.EShapeEmbeddeds.from(serialized, controller.graphic, wcardinalUi.EShapeResourceManagerDeserializationMode.EDITOR).then((shape) => {
                    this._selection.replace((existing) => {
                        return shape.clone().copy(existing);
                    });
                });
            });
        }
        get buttonGroup() {
            var _a;
            return ((_a = this._buttonGroup) !== null && _a !== void 0 ? _a : (this._buttonGroup = this.newButtonGroup()));
        }
        newButtonGroup() {
            return new wcardinalUi.DButtonAmbient({
                image: {
                    source: this._icons.shape_group
                },
                title: this.theme.getButtonGroupTitle(),
                theme: "EButtonEditor",
                on: {
                    active: () => {
                        this._selection.group();
                    }
                }
            });
        }
        get buttonUngroup() {
            var _a;
            return ((_a = this._buttonUngroup) !== null && _a !== void 0 ? _a : (this._buttonUngroup = this.newButtonUngroup()));
        }
        newButtonUngroup() {
            return new wcardinalUi.DButtonAmbient({
                image: {
                    source: this._icons.shape_ungroup
                },
                title: this.theme.getButtonUngroupTitle(),
                theme: "EButtonEditor",
                on: {
                    active: () => {
                        this._selection.ungroup();
                    }
                }
            });
        }
        get buttonFill() {
            var _a;
            return ((_a = this._buttonFill) !== null && _a !== void 0 ? _a : (this._buttonFill = this.newButtonFill()));
        }
        newButtonFill() {
            const selection = this._selection;
            return new wcardinalUi.DButtonCheckRight({
                width: "100%",
                text: {
                    value: this.theme.getButtonFillLabel()
                },
                padding: 0,
                background: {
                    color: null
                },
                on: {
                    active: () => {
                        selection.setFillEnabled(true);
                    },
                    inactive: () => {
                        selection.setFillEnabled(false);
                    }
                }
            });
        }
        get buttonFillColor() {
            var _a;
            return ((_a = this._buttonFillColor) !== null && _a !== void 0 ? _a : (this._buttonFillColor = this.newButtonFillColor()));
        }
        newButtonFillColor() {
            const result = new wcardinalUi.DButtonColor({
                width: "100%",
                on: {
                    change: (value) => {
                        this._selection.setFill(value.color, value.alpha);
                    }
                }
            });
            result.dialog.on("open", () => {
                const dialog = result.dialog;
                const dialogNew = dialog.new;
                const dialogCurrent = dialog.current;
                dialogNew.color = dialogCurrent.color;
                dialogNew.alpha = dialogCurrent.alpha;
            });
            return result;
        }
        get buttonStroke() {
            var _a;
            return ((_a = this._buttonStroke) !== null && _a !== void 0 ? _a : (this._buttonStroke = this.newButtonStroke()));
        }
        newButtonStroke() {
            const selection = this._selection;
            return new wcardinalUi.DButtonCheckRight({
                width: "100%",
                text: {
                    value: this.theme.getButtonStrokeLabel()
                },
                padding: 0,
                background: {
                    color: null
                },
                on: {
                    active: () => {
                        selection.setStrokeEnabled(true);
                    },
                    inactive: () => {
                        selection.setStrokeEnabled(false);
                    }
                }
            });
        }
        get buttonStrokeColor() {
            var _a;
            return ((_a = this._buttonStrokeColor) !== null && _a !== void 0 ? _a : (this._buttonStrokeColor = this.newButtonStrokeColor()));
        }
        newButtonStrokeColor() {
            const result = new wcardinalUi.DButtonColor({
                width: "100%",
                on: {
                    change: (value) => {
                        this._selection.setStroke(value.color, value.alpha);
                    }
                }
            });
            result.dialog.on("open", () => {
                const dialog = result.dialog;
                const dialogNew = dialog.new;
                const dialogCurrent = dialog.current;
                dialogNew.color = dialogCurrent.color;
                dialogNew.alpha = dialogCurrent.alpha;
            });
            return result;
        }
        get inputStrokeWidth() {
            var _a;
            return ((_a = this._inputStrokeWidth) !== null && _a !== void 0 ? _a : (this._inputStrokeWidth = this.newInputStrokeWidth()));
        }
        newInputStrokeWidth() {
            return new wcardinalUi.DInputRealAndLabel({
                width: "100%",
                label: {
                    text: {
                        value: this.theme.getInputStrokeWidthLabel()
                    }
                },
                input: {
                    weight: 1,
                    min: 0,
                    on: {
                        change: (value) => {
                            this._selection.setStrokeWidth(value);
                        }
                    }
                }
            });
        }
        get inputStrokeAlign() {
            var _a;
            return ((_a = this._inputStrokeAlign) !== null && _a !== void 0 ? _a : (this._inputStrokeAlign = this.newInputStrokeAlign()));
        }
        newInputStrokeAlign() {
            return new wcardinalUi.DInputRealAndLabel({
                width: "100%",
                label: {
                    text: {
                        value: this.theme.getInputStrokeAlignLabel()
                    }
                },
                input: {
                    weight: 1,
                    min: 0,
                    max: 1,
                    on: {
                        change: (value) => {
                            this._selection.setStrokeAlign(value);
                        }
                    }
                }
            });
        }
        get layoutStrokeSide() {
            var _a;
            return ((_a = this._layoutStrokeSide) !== null && _a !== void 0 ? _a : (this._layoutStrokeSide = this.newLayoutStrokeSide()));
        }
        newLayoutStrokeSide() {
            return new wcardinalUi.DLayoutHorizontal({
                width: "100%",
                height: "auto",
                children: [
                    new wcardinalUi.DLayoutSpace({ weight: 1 }),
                    this.buttonStrokeSideTop,
                    this.buttonStrokeSideRight,
                    this.buttonStrokeSideBottom,
                    this.buttonStrokeSideLeft,
                    this.buttonStrokeExpandable,
                    this.buttonStrokeShrinkable,
                    this.buttonStrokeScalableDotDash,
                    new wcardinalUi.DLayoutSpace({ weight: 1 })
                ]
            });
        }
        get buttonStrokeSideTop() {
            var _a;
            return ((_a = this._buttonStrokeSideTop) !== null && _a !== void 0 ? _a : (this._buttonStrokeSideTop = this.newButtonStrokeSideTop()));
        }
        newButtonStrokeSideTop() {
            const selection = this._selection;
            return new wcardinalUi.DButtonCheck({
                image: {
                    source: this._icons.stroke_side_top
                },
                title: this.theme.getButtonStrokeSideTopTitle(),
                theme: "EButtonEditorCheck",
                on: {
                    active: () => {
                        selection.setStrokeSide(wcardinalUi.EShapeStrokeSide.TOP, true);
                    },
                    inactive: () => {
                        selection.setStrokeSide(wcardinalUi.EShapeStrokeSide.TOP, false);
                    }
                }
            });
        }
        get buttonStrokeSideRight() {
            var _a;
            return ((_a = this._buttonStrokeSideRight) !== null && _a !== void 0 ? _a : (this._buttonStrokeSideRight = this.newButtonStrokeSideRight()));
        }
        newButtonStrokeSideRight() {
            const selection = this._selection;
            return new wcardinalUi.DButtonCheck({
                image: {
                    source: this._icons.stroke_side_right
                },
                title: this.theme.getButtonStrokeSideRightTitle(),
                theme: "EButtonEditorCheck",
                on: {
                    active: () => {
                        selection.setStrokeSide(wcardinalUi.EShapeStrokeSide.RIGHT, true);
                    },
                    inactive: () => {
                        selection.setStrokeSide(wcardinalUi.EShapeStrokeSide.RIGHT, false);
                    }
                }
            });
        }
        get buttonStrokeSideBottom() {
            var _a;
            return ((_a = this._buttonStrokeSideBottom) !== null && _a !== void 0 ? _a : (this._buttonStrokeSideBottom = this.newButtonStrokeSideBottom()));
        }
        newButtonStrokeSideBottom() {
            const selection = this._selection;
            return new wcardinalUi.DButtonCheck({
                image: {
                    source: this._icons.stroke_side_bottom
                },
                title: this.theme.getButtonStrokeSideBottomTitle(),
                theme: "EButtonEditorCheck",
                on: {
                    active: () => {
                        selection.setStrokeSide(wcardinalUi.EShapeStrokeSide.BOTTOM, true);
                    },
                    inactive: () => {
                        selection.setStrokeSide(wcardinalUi.EShapeStrokeSide.BOTTOM, false);
                    }
                }
            });
        }
        get buttonStrokeSideLeft() {
            var _a;
            return ((_a = this._buttonStrokeSideLeft) !== null && _a !== void 0 ? _a : (this._buttonStrokeSideLeft = this.newButtonStrokeSideLeft()));
        }
        newButtonStrokeSideLeft() {
            const selection = this._selection;
            return new wcardinalUi.DButtonCheck({
                image: {
                    source: this._icons.stroke_side_left
                },
                title: this.theme.getButtonStrokeSideLeftTitle(),
                theme: "EButtonEditorCheck",
                on: {
                    active: () => {
                        selection.setStrokeSide(wcardinalUi.EShapeStrokeSide.LEFT, true);
                    },
                    inactive: () => {
                        selection.setStrokeSide(wcardinalUi.EShapeStrokeSide.LEFT, false);
                    }
                }
            });
        }
        get textCorner() {
            var _a;
            return ((_a = this._textCorner) !== null && _a !== void 0 ? _a : (this._textCorner = this.newTextCorner()));
        }
        newTextCorner() {
            return new wcardinalUi.DText({
                width: "100%",
                text: {
                    value: this.theme.getTextCornerLabel()
                }
            });
        }
        get inputCornerRadius() {
            var _a;
            return ((_a = this._inputCornerRadius) !== null && _a !== void 0 ? _a : (this._inputCornerRadius = this.newInputCornerRadius()));
        }
        newInputCornerRadius() {
            return new wcardinalUi.DInputReal({
                width: "100%",
                min: 0,
                step: 1,
                max: 100,
                text: {
                    formatter: (value) => {
                        return `${+(value * 100).toFixed(2)} %`;
                    }
                },
                editing: {
                    formatter: (value) => {
                        return `${+(value * 100).toFixed(2)}`;
                    },
                    unformatter: (text) => {
                        return parseFloat(text) * 0.01;
                    }
                },
                on: {
                    change: (value) => {
                        this._selection.setRadius(value);
                    }
                }
            });
        }
        get layoutCorner() {
            var _a;
            return ((_a = this._layoutCorner) !== null && _a !== void 0 ? _a : (this._layoutCorner = this.newLayoutCorner()));
        }
        newLayoutCorner() {
            return new wcardinalUi.DLayoutHorizontal({
                width: "100%",
                height: "auto",
                children: [
                    new wcardinalUi.DLayoutSpace({ weight: 1 }),
                    this.buttonCornerTopLeft,
                    this.buttonCornerTopRight,
                    this.buttonCornerBottomRight,
                    this.buttonCornerBottomLeft,
                    new wcardinalUi.DLayoutSpace({ weight: 1 })
                ]
            });
        }
        get buttonCornerTopLeft() {
            var _a;
            return ((_a = this._buttonCornerTopLeft) !== null && _a !== void 0 ? _a : (this._buttonCornerTopLeft = this.newButtonCornerTopLeft()));
        }
        newButtonCornerTopLeft() {
            const selection = this._selection;
            return new wcardinalUi.DButtonCheck({
                image: {
                    source: this._icons.corner_top_left
                },
                title: this.theme.getButtonCornerTopLeftTitle(),
                theme: "EButtonEditorCheck",
                on: {
                    active: () => {
                        selection.setCorner(wcardinalUi.EShapeCorner.TOP_LEFT, true);
                    },
                    inactive: () => {
                        selection.setCorner(wcardinalUi.EShapeCorner.TOP_LEFT, false);
                    }
                }
            });
        }
        get buttonCornerTopRight() {
            var _a;
            return ((_a = this._buttonCornerTopRight) !== null && _a !== void 0 ? _a : (this._buttonCornerTopRight = this.newButtonCornerTopRight()));
        }
        newButtonCornerTopRight() {
            const selection = this._selection;
            return new wcardinalUi.DButtonCheck({
                image: {
                    source: this._icons.corner_top_right
                },
                title: this.theme.getButtonCornerTopRightTitle(),
                theme: "EButtonEditorCheck",
                on: {
                    active: () => {
                        selection.setCorner(wcardinalUi.EShapeCorner.TOP_RIGHT, true);
                    },
                    inactive: () => {
                        selection.setCorner(wcardinalUi.EShapeCorner.TOP_RIGHT, false);
                    }
                }
            });
        }
        get buttonCornerBottomRight() {
            var _a;
            return ((_a = this._buttonCornerBottomRight) !== null && _a !== void 0 ? _a : (this._buttonCornerBottomRight = this.newButtonCornerBottomRight()));
        }
        newButtonCornerBottomRight() {
            const selection = this._selection;
            return new wcardinalUi.DButtonCheck({
                image: {
                    source: this._icons.corner_bottom_right
                },
                title: this.theme.getButtonCornerBottomRightTitle(),
                theme: "EButtonEditorCheck",
                on: {
                    active: () => {
                        selection.setCorner(wcardinalUi.EShapeCorner.BOTTOM_RIGHT, true);
                    },
                    inactive: () => {
                        selection.setCorner(wcardinalUi.EShapeCorner.BOTTOM_RIGHT, false);
                    }
                }
            });
        }
        get buttonCornerBottomLeft() {
            var _a;
            return ((_a = this._buttonCornerBottomLeft) !== null && _a !== void 0 ? _a : (this._buttonCornerBottomLeft = this.newButtonCornerBottomLeft()));
        }
        newButtonCornerBottomLeft() {
            const selection = this._selection;
            return new wcardinalUi.DButtonCheck({
                image: {
                    source: this._icons.corner_bottom_left
                },
                title: this.theme.getButtonCornerBottomLeftTitle(),
                theme: "EButtonEditorCheck",
                on: {
                    active: () => {
                        selection.setCorner(wcardinalUi.EShapeCorner.BOTTOM_LEFT, true);
                    },
                    inactive: () => {
                        selection.setCorner(wcardinalUi.EShapeCorner.BOTTOM_LEFT, false);
                    }
                }
            });
        }
        get layoutLine() {
            var _a;
            return ((_a = this._layoutLine) !== null && _a !== void 0 ? _a : (this._layoutLine = this.newLayoutLine()));
        }
        newLayoutLine() {
            return new wcardinalUi.DLayoutHorizontal({
                width: "100%",
                children: [this.textLine, this.buttonLineClosed, this.buttonLineLock]
            });
        }
        get textLine() {
            var _a;
            return ((_a = this._textLine) !== null && _a !== void 0 ? _a : (this._textLine = this.newTextLine()));
        }
        newTextLine() {
            return new wcardinalUi.DText({
                weight: 1,
                text: {
                    value: this.theme.getTextLineLabel()
                }
            });
        }
        get buttonLineLock() {
            var _a;
            return ((_a = this._buttonLineLock) !== null && _a !== void 0 ? _a : (this._buttonLineLock = this.newButtonLineLock()));
        }
        newButtonLineLock() {
            return new wcardinalUi.DButtonCheck({
                theme: "EButtonEditorLock",
                on: {
                    active: () => {
                        this._selection.lockCapability(wcardinalUi.EShapeCapability.LINE);
                    },
                    inactive: () => {
                        this._selection.unlockCapability(wcardinalUi.EShapeCapability.LINE);
                    }
                }
            });
        }
        isLocked(last, target) {
            if (last == null) {
                return false;
            }
            const capability = last.getCapability();
            if (capability == null) {
                return false;
            }
            if (capability.locked & target) {
                return true;
            }
            return false;
        }
        get selectLineStyle() {
            var _a;
            return ((_a = this._selectLineStyle) !== null && _a !== void 0 ? _a : (this._selectLineStyle = this.newSelectLineStyle()));
        }
        newSelectLineStyle() {
            const theme = this.theme;
            return new wcardinalUi.DSelect({
                width: "100%",
                value: wcardinalUi.EShapeStrokeStyle.NONE,
                menu: {
                    items: [
                        {
                            value: wcardinalUi.EShapeStrokeStyle.NONE,
                            text: {
                                value: theme.getSelectLineStyleLabel(wcardinalUi.EShapeStrokeStyle.NONE)
                            }
                        },
                        {
                            value: wcardinalUi.EShapeStrokeStyle.DOTTED,
                            text: {
                                value: theme.getSelectLineStyleLabel(wcardinalUi.EShapeStrokeStyle.DOTTED)
                            }
                        },
                        {
                            value: wcardinalUi.EShapeStrokeStyle.DOTTED_DENSELY,
                            text: {
                                value: theme.getSelectLineStyleLabel(wcardinalUi.EShapeStrokeStyle.DOTTED_DENSELY)
                            }
                        },
                        {
                            value: wcardinalUi.EShapeStrokeStyle.DOTTED_LOOSELY,
                            text: {
                                value: theme.getSelectLineStyleLabel(wcardinalUi.EShapeStrokeStyle.DOTTED_LOOSELY)
                            }
                        },
                        {
                            value: wcardinalUi.EShapeStrokeStyle.DASHED,
                            text: {
                                value: theme.getSelectLineStyleLabel(wcardinalUi.EShapeStrokeStyle.DASHED)
                            }
                        },
                        {
                            value: wcardinalUi.EShapeStrokeStyle.DASHED_DENSELY,
                            text: {
                                value: theme.getSelectLineStyleLabel(wcardinalUi.EShapeStrokeStyle.DASHED_DENSELY)
                            }
                        },
                        {
                            value: wcardinalUi.EShapeStrokeStyle.DASHED_LOOSELY,
                            text: {
                                value: theme.getSelectLineStyleLabel(wcardinalUi.EShapeStrokeStyle.DASHED_LOOSELY)
                            }
                        }
                    ]
                },
                on: {
                    change: (value) => {
                        this._selection.setLineStyle(value !== null && value !== void 0 ? value : wcardinalUi.EShapeStrokeStyle.NONE, wcardinalUi.EShapeStrokeStyle.DOTTED_MASK | wcardinalUi.EShapeStrokeStyle.DASHED_MASK);
                    }
                }
            });
        }
        get selectLineType() {
            var _a;
            return ((_a = this._selectLineType) !== null && _a !== void 0 ? _a : (this._selectLineType = this.newSelectLineType()));
        }
        newSelectLineType() {
            return new wcardinalUi.DSelect({
                width: "100%",
                value: wcardinalUi.EShapePointsStyle.NONE,
                menu: {
                    items: this.newSelectLineTypeMenuItems()
                },
                on: {
                    change: (value) => {
                        this._selection.setPointsStyle(value !== null && value !== void 0 ? value : wcardinalUi.EShapePointsStyle.NONE, wcardinalUi.EShapePointsStyle.FORMATTER_MASK);
                    }
                }
            });
        }
        newSelectLineTypeMenuItems() {
            const result = [
                {
                    value: wcardinalUi.EShapePointsStyle.NONE,
                    text: {
                        value: this.theme.getSelectLineTypeLabel(wcardinalUi.EShapePointsStyle.NONE)
                    }
                }
            ];
            wcardinalUi.EShapePointsFormatters.each((id, datum) => {
                result.push({
                    value: id << wcardinalUi.EShapePointsStyle.FORMATTER_SHIFT,
                    text: {
                        value: datum.label
                    }
                });
            });
            return result;
        }
        get buttonLineClosed() {
            var _a;
            return ((_a = this._buttonLineClosed) !== null && _a !== void 0 ? _a : (this._buttonLineClosed = this.newButtonLineClosed()));
        }
        newButtonLineClosed() {
            const selection = this._selection;
            return new wcardinalUi.DButtonCheck({
                image: {
                    source: this._icons.line_closed
                },
                title: this.theme.getButtonLineClosedTitle(),
                theme: "EButtonEditorCheck",
                on: {
                    active: () => {
                        selection.setPointsStyle(wcardinalUi.EShapePointsStyle.CLOSED, wcardinalUi.EShapePointsStyle.NONE);
                    },
                    inactive: () => {
                        selection.setPointsStyle(wcardinalUi.EShapePointsStyle.NONE, wcardinalUi.EShapePointsStyle.CLOSED);
                    }
                }
            });
        }
        get buttonStrokeExpandable() {
            var _a;
            return ((_a = this._buttonStrokeExpandable) !== null && _a !== void 0 ? _a : (this._buttonStrokeExpandable = this.newButtonStrokeExpandable()));
        }
        newButtonStrokeExpandable() {
            const selection = this._selection;
            return new wcardinalUi.DButtonCheck({
                image: {
                    source: this._icons.stroke_expandable
                },
                title: this.theme.getButtonStrokeExpandableTitle(),
                theme: "EButtonEditorCheck",
                on: {
                    active: () => {
                        selection.setStrokeStyle(wcardinalUi.EShapeStrokeStyle.NONE, wcardinalUi.EShapeStrokeStyle.NON_EXPANDING_WIDTH);
                    },
                    inactive: () => {
                        selection.setStrokeStyle(wcardinalUi.EShapeStrokeStyle.NON_EXPANDING_WIDTH, wcardinalUi.EShapeStrokeStyle.NONE);
                    }
                }
            });
        }
        get buttonStrokeShrinkable() {
            var _a;
            return ((_a = this._buttonStrokeShrinkable) !== null && _a !== void 0 ? _a : (this._buttonStrokeShrinkable = this.newButtonStrokeShrinkable()));
        }
        newButtonStrokeShrinkable() {
            const selection = this._selection;
            return new wcardinalUi.DButtonCheck({
                image: {
                    source: this._icons.stroke_shrinkable
                },
                title: this.theme.getButtonStrokeShrinkableTitle(),
                theme: "EButtonEditorCheck",
                on: {
                    active: () => {
                        selection.setStrokeStyle(wcardinalUi.EShapeStrokeStyle.NONE, wcardinalUi.EShapeStrokeStyle.NON_SHRINKING_WIDTH);
                    },
                    inactive: () => {
                        selection.setStrokeStyle(wcardinalUi.EShapeStrokeStyle.NON_SHRINKING_WIDTH, wcardinalUi.EShapeStrokeStyle.NONE);
                    }
                }
            });
        }
        get buttonStrokeScalableDotDash() {
            var _a;
            return ((_a = this._buttonStrokeScalableDotDash) !== null && _a !== void 0 ? _a : (this._buttonStrokeScalableDotDash = this.newButtonStrokeScalableDotDash()));
        }
        newButtonStrokeScalableDotDash() {
            const selection = this._selection;
            return new wcardinalUi.DButtonCheckRight({
                image: {
                    source: this._icons.stroke_scalable_dot_dash
                },
                title: this.theme.getButtonStrokeScalableDotDashTitle(),
                theme: "EButtonEditorCheck",
                on: {
                    active: () => {
                        selection.setStrokeStyle(wcardinalUi.EShapeStrokeStyle.NONE, wcardinalUi.EShapeStrokeStyle.NON_SCALING_DOT_AND_DASH);
                    },
                    inactive: () => {
                        selection.setStrokeStyle(wcardinalUi.EShapeStrokeStyle.NON_SCALING_DOT_AND_DASH, wcardinalUi.EShapeStrokeStyle.NONE);
                    }
                }
            });
        }
        get layoutLineTail() {
            var _a;
            return ((_a = this._layoutLineTail) !== null && _a !== void 0 ? _a : (this._layoutLineTail = this.newLayoutLineTail()));
        }
        newLayoutLineTail() {
            return new wcardinalUi.DLayoutHorizontal({
                width: "100%",
                children: [this.textLineTail, this.buttonLineTailLock]
            });
        }
        get textLineTail() {
            var _a;
            return ((_a = this._textLineTail) !== null && _a !== void 0 ? _a : (this._textLineTail = this.newTextLineTail()));
        }
        newTextLineTail() {
            return new wcardinalUi.DText({
                weight: 1,
                text: {
                    value: this.theme.getTextLineTailLabel()
                }
            });
        }
        get buttonLineTailLock() {
            var _a;
            return ((_a = this._buttonLineTailLock) !== null && _a !== void 0 ? _a : (this._buttonLineTailLock = this.newButtonLineTailLock()));
        }
        newButtonLineTailLock() {
            return new wcardinalUi.DButtonCheck({
                theme: "EButtonEditorLock",
                on: {
                    active: () => {
                        this._selection.lockCapability(wcardinalUi.EShapeCapability.LINE_TAIL);
                    },
                    inactive: () => {
                        this._selection.unlockCapability(wcardinalUi.EShapeCapability.LINE_TAIL);
                    }
                }
            });
        }
        get selectLineTailType() {
            var _a;
            return ((_a = this._selectLineTailType) !== null && _a !== void 0 ? _a : (this._selectLineTailType = this.newSelectLineTailType()));
        }
        newSelectLineTailType() {
            const theme = this.theme;
            return new wcardinalUi.DSelect({
                width: "100%",
                value: wcardinalUi.EShapePointsMarkerType.NONE,
                menu: {
                    items: [
                        {
                            value: wcardinalUi.EShapePointsMarkerType.NONE,
                            text: {
                                value: theme.getSelectLineTailTypeLabel(wcardinalUi.EShapePointsMarkerType.NONE)
                            }
                        },
                        {
                            value: wcardinalUi.EShapePointsMarkerType.CIRCLE,
                            text: {
                                value: theme.getSelectLineTailTypeLabel(wcardinalUi.EShapePointsMarkerType.CIRCLE)
                            }
                        },
                        {
                            value: wcardinalUi.EShapePointsMarkerType.TRIANGLE,
                            text: {
                                value: theme.getSelectLineTailTypeLabel(wcardinalUi.EShapePointsMarkerType.TRIANGLE)
                            }
                        },
                        {
                            value: wcardinalUi.EShapePointsMarkerType.RECTANGLE,
                            text: {
                                value: theme.getSelectLineTailTypeLabel(wcardinalUi.EShapePointsMarkerType.RECTANGLE)
                            }
                        }
                    ]
                },
                on: {
                    change: (value) => {
                        this._selection.setLineTailType(value !== null && value !== void 0 ? value : wcardinalUi.EShapePointsMarkerType.NONE);
                    }
                }
            });
        }
        get layoutLineTailSize() {
            var _a;
            return ((_a = this._layoutLineTailSize) !== null && _a !== void 0 ? _a : (this._layoutLineTailSize = this.newLayoutLineTailSize()));
        }
        newLayoutLineTailSize() {
            return new wcardinalUi.DLayoutHorizontal({
                width: "100%",
                children: [this.inputLineTailSizeX, this.inputLineTailSizeY]
            });
        }
        get inputLineTailSizeX() {
            var _a;
            return ((_a = this._inputLineTailSizeX) !== null && _a !== void 0 ? _a : (this._inputLineTailSizeX = this.newInputLineTailSizeX()));
        }
        newInputLineTailSizeX() {
            return new wcardinalUi.DInputReal({
                weight: 1,
                min: 0,
                on: {
                    change: (value) => {
                        this._selection.setLineTailSizeX(value);
                    }
                }
            });
        }
        get inputLineTailSizeY() {
            var _a;
            return ((_a = this._inputLineTailSizeY) !== null && _a !== void 0 ? _a : (this._inputLineTailSizeY = this.newInputLineTailSizeY()));
        }
        newInputLineTailSizeY() {
            return new wcardinalUi.DInputReal({
                weight: 1,
                min: 0,
                on: {
                    change: (value) => {
                        this._selection.setLineTailSizeY(value);
                    }
                }
            });
        }
        get buttonLineTailColor() {
            var _a;
            return ((_a = this._buttonLineTailColor) !== null && _a !== void 0 ? _a : (this._buttonLineTailColor = this.newButtonLineTailColor()));
        }
        newButtonLineTailColor() {
            const result = new wcardinalUi.DButtonColor({
                width: "100%",
                on: {
                    change: (value) => {
                        this._selection.setLineTailColor(value.color, value.alpha);
                    }
                }
            });
            result.dialog.on("open", () => {
                const dialog = result.dialog;
                const dialogNew = dialog.new;
                const dialogCurrent = dialog.current;
                dialogNew.color = dialogCurrent.color;
                dialogNew.alpha = dialogCurrent.alpha;
            });
            return result;
        }
        get inputLineTailMargin() {
            var _a;
            return ((_a = this._inputLineTailMargin) !== null && _a !== void 0 ? _a : (this._inputLineTailMargin = this.newInputLineTailMargin()));
        }
        newInputLineTailMargin() {
            return new wcardinalUi.DInputRealAndLabel({
                width: "100%",
                label: {
                    text: {
                        value: this.theme.getInputLineTailMarginLabel()
                    }
                },
                input: {
                    weight: 1,
                    on: {
                        change: (value) => {
                            this._selection.setLineTailMargin(value);
                        }
                    }
                }
            });
        }
        get layoutLineHead() {
            var _a;
            return ((_a = this._layoutLineHead) !== null && _a !== void 0 ? _a : (this._layoutLineHead = this.newLayoutLineHead()));
        }
        newLayoutLineHead() {
            return new wcardinalUi.DLayoutHorizontal({
                width: "100%",
                children: [this.textLineHead, this.buttonLineHeadLock]
            });
        }
        get textLineHead() {
            var _a;
            return ((_a = this._textLineHead) !== null && _a !== void 0 ? _a : (this._textLineHead = this.newTextLineHead()));
        }
        newTextLineHead() {
            return new wcardinalUi.DText({
                weight: 1,
                text: {
                    value: this.theme.getTextLineHeadLabel()
                }
            });
        }
        get buttonLineHeadLock() {
            var _a;
            return ((_a = this._buttonLineHeadLock) !== null && _a !== void 0 ? _a : (this._buttonLineHeadLock = this.newButtonLineHeadLock()));
        }
        newButtonLineHeadLock() {
            return new wcardinalUi.DButtonCheck({
                theme: "EButtonEditorLock",
                on: {
                    active: () => {
                        this._selection.lockCapability(wcardinalUi.EShapeCapability.LINE_HEAD);
                    },
                    inactive: () => {
                        this._selection.unlockCapability(wcardinalUi.EShapeCapability.LINE_HEAD);
                    }
                }
            });
        }
        get selectLineHeadType() {
            var _a;
            return ((_a = this._selectLineHeadType) !== null && _a !== void 0 ? _a : (this._selectLineHeadType = this.newSelectLineHeadType()));
        }
        newSelectLineHeadType() {
            const theme = this.theme;
            return new wcardinalUi.DSelect({
                width: "100%",
                value: wcardinalUi.EShapePointsMarkerType.NONE,
                menu: {
                    items: [
                        {
                            value: wcardinalUi.EShapePointsMarkerType.NONE,
                            text: {
                                value: theme.getSelectLineHeadTypeLabel(wcardinalUi.EShapePointsMarkerType.NONE)
                            }
                        },
                        {
                            value: wcardinalUi.EShapePointsMarkerType.CIRCLE,
                            text: {
                                value: theme.getSelectLineHeadTypeLabel(wcardinalUi.EShapePointsMarkerType.CIRCLE)
                            }
                        },
                        {
                            value: wcardinalUi.EShapePointsMarkerType.TRIANGLE,
                            text: {
                                value: theme.getSelectLineHeadTypeLabel(wcardinalUi.EShapePointsMarkerType.TRIANGLE)
                            }
                        },
                        {
                            value: wcardinalUi.EShapePointsMarkerType.RECTANGLE,
                            text: {
                                value: theme.getSelectLineHeadTypeLabel(wcardinalUi.EShapePointsMarkerType.RECTANGLE)
                            }
                        }
                    ]
                },
                on: {
                    change: (value) => {
                        this._selection.setLineHeadType(value !== null && value !== void 0 ? value : wcardinalUi.EShapePointsMarkerType.NONE);
                    }
                }
            });
        }
        get layoutLineHeadSize() {
            var _a;
            return ((_a = this._layoutLineHeadSize) !== null && _a !== void 0 ? _a : (this._layoutLineHeadSize = this.newLayoutLineHeadSize()));
        }
        newLayoutLineHeadSize() {
            return new wcardinalUi.DLayoutHorizontal({
                width: "100%",
                children: [this.inputLineHeadSizeX, this.inputLineHeadSizeY]
            });
        }
        get inputLineHeadSizeX() {
            var _a;
            return ((_a = this._inputLineHeadSizeX) !== null && _a !== void 0 ? _a : (this._inputLineHeadSizeX = this.newInputLineHeadSizeX()));
        }
        newInputLineHeadSizeX() {
            return new wcardinalUi.DInputReal({
                weight: 1,
                min: 0,
                on: {
                    change: (value) => {
                        this._selection.setLineHeadSizeX(value);
                    }
                }
            });
        }
        get inputLineHeadSizeY() {
            var _a;
            return ((_a = this._inputLineHeadSizeY) !== null && _a !== void 0 ? _a : (this._inputLineHeadSizeY = this.newInputLineHeadSizeY()));
        }
        newInputLineHeadSizeY() {
            return new wcardinalUi.DInputReal({
                weight: 1,
                min: 0,
                on: {
                    change: (value) => {
                        this._selection.setLineHeadSizeY(value);
                    }
                }
            });
        }
        get buttonLineHeadColor() {
            var _a;
            return ((_a = this._buttonLineHeadColor) !== null && _a !== void 0 ? _a : (this._buttonLineHeadColor = this.newButtonLineHeadColor()));
        }
        newButtonLineHeadColor() {
            const result = new wcardinalUi.DButtonColor({
                width: "100%",
                on: {
                    change: (value) => {
                        this._selection.setLineHeadColor(value.color, value.alpha);
                    }
                }
            });
            result.dialog.on("open", () => {
                const dialog = result.dialog;
                const dialogNew = dialog.new;
                const dialogCurrent = dialog.current;
                dialogNew.color = dialogCurrent.color;
                dialogNew.alpha = dialogCurrent.alpha;
            });
            return result;
        }
        get inputLineHeadMargin() {
            var _a;
            return ((_a = this._inputLineHeadMargin) !== null && _a !== void 0 ? _a : (this._inputLineHeadMargin = this.newInputLineHeadMargin()));
        }
        newInputLineHeadMargin() {
            return new wcardinalUi.DInputRealAndLabel({
                width: "100%",
                label: {
                    text: {
                        value: this.theme.getInputLineHeadMarginLabel()
                    }
                },
                input: {
                    weight: 1,
                    on: {
                        change: (value) => {
                            this._selection.setLineHeadMargin(value);
                        }
                    }
                }
            });
        }
        get layoutTexture() {
            let result = this._layoutTexture;
            if (result == null) {
                result = this.newLayoutTexture();
                this._layoutTexture = result;
            }
            return result;
        }
        newLayoutTexture() {
            return new wcardinalUi.DLayoutHorizontal({
                width: "100%",
                height: "auto",
                children: [
                    new wcardinalUi.DLayoutSpace({ weight: 1 }),
                    this.buttonTextureImage,
                    this.buttonTextureGradient,
                    this.buttonTextureFitTo,
                    this.buttonTextureClear,
                    new wcardinalUi.DLayoutSpace({ weight: 1 })
                ]
            });
        }
        get buttonTextureImage() {
            var _a;
            return ((_a = this._buttonTextureImage) !== null && _a !== void 0 ? _a : (this._buttonTextureImage = this.newButtonTextureImage()));
        }
        newButtonTextureImage() {
            const theme = this.theme;
            return new wcardinalUi.DButtonFile({
                image: {
                    source: this._icons.editor_image
                },
                as: wcardinalUi.DButtonFileAs.DATA_URL,
                title: theme.getButtonTextureImageTitle(),
                theme: "EButtonEditor",
                on: {
                    open: (dataUrl) => {
                        wcardinalUi.toImageElement(dataUrl).then((imageElement) => {
                            this._selection.setImage(imageElement);
                        });
                    }
                }
            });
        }
        get buttonTextureGradient() {
            var _a;
            return ((_a = this._buttonTextureGradient) !== null && _a !== void 0 ? _a : (this._buttonTextureGradient = this.newButtonTextureGradient()));
        }
        newButtonTextureGradient() {
            const theme = this.theme;
            const result = new wcardinalUi.DButtonColorGradient({
                image: {
                    source: this._icons.texture_gradient
                },
                text: {
                    formatter: () => ""
                },
                title: theme.getButtonTextureGradientTitle(),
                theme: "EButtonEditor",
                on: {
                    change: (value) => {
                        const url = wcardinalUi.toGradientImageUrl(value);
                        wcardinalUi.toImageElement(url).then((imageElement) => {
                            this._selection.setGradient(imageElement, value.toObject());
                        });
                    }
                }
            });
            result.dialog.on("open", () => {
                const last = this._selection.last();
                if (last != null && last.gradient != null) {
                    result.dialog.value.fromObject(last.gradient);
                }
            });
            return result;
        }
        get buttonTextureFitTo() {
            var _a;
            return ((_a = this._buttonTextureFitTo) !== null && _a !== void 0 ? _a : (this._buttonTextureFitTo = this.newButtonTextureFitTo()));
        }
        newButtonTextureFitTo() {
            const theme = this.theme;
            return new wcardinalUi.DButton({
                image: {
                    source: this._icons.texture_fit_to
                },
                title: theme.getButtonTextureFitToTitle(),
                theme: "EButtonEditor",
                on: {
                    active: () => {
                        this._selection.fitToImage();
                    }
                }
            });
        }
        get buttonTextureClear() {
            var _a;
            return ((_a = this._buttonTextureClear) !== null && _a !== void 0 ? _a : (this._buttonTextureClear = this.newButtonTextureClear()));
        }
        newButtonTextureClear() {
            const theme = this.theme;
            return new wcardinalUi.DButton({
                image: {
                    source: this._icons.texture_clear
                },
                title: theme.getButtonTextureClearTitle(),
                theme: "EButtonEditor",
                on: {
                    active: () => {
                        this._selection.clearImage();
                    }
                }
            });
        }
        onSelectionChange() {
            const selection = this._selection;
            this.state.isDisabled = selection.isEmpty();
            const last = selection.last();
            // Shape
            const layoutChangeTo = this.layoutChangeTo;
            if (layoutChangeTo) {
                layoutChangeTo.state.isEnabled = wcardinalUi.EShapeCapabilities.contains(last, wcardinalUi.EShapeCapability.REPLACING);
            }
            // Grouping
            let ngroupable = 0;
            if (2 <= selection.size()) {
                const shapes = selection.get();
                for (let i = 0, imax = shapes.length; i < imax; ++i) {
                    if (wcardinalUi.EShapeCapabilities.contains(shapes[i], wcardinalUi.EShapeCapability.GROUPING)) {
                        ngroupable += 1;
                        if (2 <= ngroupable) {
                            break;
                        }
                    }
                }
            }
            this.buttonGroup.state.isEnabled = 2 <= ngroupable;
            // Ungrouping
            this.buttonUngroup.state.isEnabled =
                last instanceof wcardinalUi.EShapeGroup &&
                    wcardinalUi.EShapeCapabilities.contains(last, wcardinalUi.EShapeCapability.CHILDREN) &&
                    wcardinalUi.EShapeCapabilities.contains(last, wcardinalUi.EShapeCapability.UNGROUPING);
            // Fill
            if (last != null) {
                this.buttonFill.state.isActive = last.fill.enable;
                const fill = last.fill;
                const buttonFillColor = this.buttonFillColor;
                const value = buttonFillColor.value;
                value.color = fill.color;
                value.alpha = fill.alpha;
                buttonFillColor.state.isEnabled = fill.enable;
            }
            // Stroke
            if (last != null) {
                const stroke = last.stroke;
                const strokeEnable = stroke.enable;
                this.buttonStroke.state.isActive = strokeEnable;
                // Stroke color
                const buttonStrokeColor = this.buttonStrokeColor;
                const value = buttonStrokeColor.value;
                value.color = stroke.color;
                value.alpha = stroke.alpha;
                buttonStrokeColor.state.isEnabled = strokeEnable;
                // Stroke align
                const inputStrokeAlign = this.inputStrokeAlign;
                inputStrokeAlign.input.value = stroke.align;
                inputStrokeAlign.state.isEnabled = strokeEnable;
                // Stroke width
                const inputStrokeWidth = this.inputStrokeWidth;
                inputStrokeWidth.input.value = stroke.width;
                inputStrokeWidth.state.isEnabled = strokeEnable;
                // Stroke side
                const side = stroke.side;
                const hasStrokeSide = strokeEnable && wcardinalUi.EShapeCapabilities.contains(last, wcardinalUi.EShapeCapability.STROKE_SIDE);
                const buttonStrokeSideTop = this.buttonStrokeSideTop;
                const buttonStrokeSideRight = this.buttonStrokeSideRight;
                const buttonStrokeSideBottom = this.buttonStrokeSideBottom;
                const buttonStrokeSideLeft = this.buttonStrokeSideLeft;
                buttonStrokeSideTop.state.isEnabled = hasStrokeSide;
                buttonStrokeSideRight.state.isEnabled = hasStrokeSide;
                buttonStrokeSideBottom.state.isEnabled = hasStrokeSide;
                buttonStrokeSideLeft.state.isEnabled = hasStrokeSide;
                buttonStrokeSideTop.state.isActive = !!(side & wcardinalUi.EShapeStrokeSide.TOP);
                buttonStrokeSideRight.state.isActive = !!(side & wcardinalUi.EShapeStrokeSide.RIGHT);
                buttonStrokeSideBottom.state.isActive = !!(side & wcardinalUi.EShapeStrokeSide.BOTTOM);
                buttonStrokeSideLeft.state.isActive = !!(side & wcardinalUi.EShapeStrokeSide.LEFT);
                // Stroke style
                const style = stroke.style;
                const buttonStrokeExpandable = this.buttonStrokeExpandable;
                const buttonStrokeShrinkable = this.buttonStrokeShrinkable;
                const buttonStrokeScalableDotDash = this.buttonStrokeScalableDotDash;
                buttonStrokeExpandable.state.isEnabled = strokeEnable;
                buttonStrokeShrinkable.state.isEnabled = strokeEnable;
                buttonStrokeScalableDotDash.state.isEnabled = strokeEnable;
                buttonStrokeExpandable.state.isActive = !(style & wcardinalUi.EShapeStrokeStyle.NON_EXPANDING_WIDTH);
                buttonStrokeShrinkable.state.isActive = !(style & wcardinalUi.EShapeStrokeStyle.NON_SHRINKING_WIDTH);
                buttonStrokeScalableDotDash.state.isActive = !(style & wcardinalUi.EShapeStrokeStyle.NON_SCALING_DOT_AND_DASH);
            }
            // Line
            const layoutLine = this.layoutLine;
            const buttonLineLock = this.buttonLineLock;
            const selectLineStyle = this.selectLineStyle;
            const selectLineType = this.selectLineType;
            const buttonLineClosed = this.buttonLineClosed;
            const layoutLineTail = this.layoutLineTail;
            const buttonLineTailLock = this.buttonLineTailLock;
            const selectLineTailType = this.selectLineTailType;
            const inputLineTailSizeX = this.inputLineTailSizeX;
            const inputLineTailSizeY = this.inputLineTailSizeY;
            const buttonLineTailColor = this.buttonLineTailColor;
            const inputLineTailMargin = this.inputLineTailMargin;
            const layoutLineHead = this.layoutLineHead;
            const buttonLineHeadLock = this.buttonLineHeadLock;
            const selectLineHeadType = this.selectLineHeadType;
            const inputLineHeadSizeX = this.inputLineHeadSizeX;
            const inputLineHeadSizeY = this.inputLineHeadSizeY;
            const buttonLineHeadColor = this.buttonLineHeadColor;
            const inputLineHeadMargin = this.inputLineHeadMargin;
            if (last != null && last.points != null) {
                const points = last.points;
                const hasLine = wcardinalUi.EShapeCapabilities.contains(last, wcardinalUi.EShapeCapability.LINE);
                layoutLine.state.isEnabled = true;
                buttonLineLock.state.isActive = this.isLocked(last, wcardinalUi.EShapeCapability.LINE);
                buttonLineLock.state.isEnabled = true;
                const lineStrokeMask = wcardinalUi.EShapeStrokeStyle.DOTTED_MASK | wcardinalUi.EShapeStrokeStyle.DASHED_MASK;
                selectLineStyle.value = last.stroke.style & lineStrokeMask;
                selectLineStyle.state.isEnabled = hasLine;
                selectLineType.value = points.style & wcardinalUi.EShapePointsStyle.FORMATTER_MASK;
                selectLineType.state.isEnabled = hasLine;
                buttonLineClosed.state.isActive = (points.style & wcardinalUi.EShapePointsStyle.CLOSED) !== 0;
                buttonLineClosed.state.isEnabled = hasLine;
                const hasLineTail = wcardinalUi.EShapeCapabilities.contains(last, wcardinalUi.EShapeCapability.LINE_TAIL);
                layoutLineTail.state.isEnabled = true;
                buttonLineTailLock.state.isActive = this.isLocked(last, wcardinalUi.EShapeCapability.LINE_TAIL);
                buttonLineTailLock.state.isEnabled = true;
                const markerTail = points.marker.tail;
                selectLineTailType.value = markerTail.type;
                selectLineTailType.state.isEnabled = hasLineTail;
                inputLineTailSizeX.value = markerTail.size.x;
                inputLineTailSizeX.state.isEnabled = hasLineTail;
                inputLineTailSizeY.value = markerTail.size.y;
                inputLineTailSizeY.state.isEnabled = hasLineTail;
                const markerTailFill = markerTail.fill;
                const buttonLineTailColorValue = buttonLineTailColor.value;
                buttonLineTailColorValue.color = markerTailFill.color;
                buttonLineTailColorValue.alpha = markerTailFill.alpha;
                buttonLineTailColor.state.isEnabled = markerTailFill.enable && hasLineTail;
                if (last instanceof wcardinalUi.EShapeConnectorLine) {
                    inputLineTailMargin.input.value = last.edge.tail.margin;
                    inputLineTailMargin.state.isEnabled = hasLineTail;
                }
                else {
                    inputLineTailMargin.state.isEnabled = false;
                }
                const hasLineHead = wcardinalUi.EShapeCapabilities.contains(last, wcardinalUi.EShapeCapability.LINE_HEAD);
                layoutLineHead.state.isEnabled = true;
                buttonLineHeadLock.state.isActive = this.isLocked(last, wcardinalUi.EShapeCapability.LINE_HEAD);
                buttonLineHeadLock.state.isEnabled = true;
                const markerHead = points.marker.head;
                selectLineHeadType.value = markerHead.type;
                selectLineHeadType.state.isEnabled = hasLineHead;
                inputLineHeadSizeX.value = markerHead.size.x;
                inputLineHeadSizeX.state.isEnabled = hasLineHead;
                inputLineHeadSizeY.value = markerHead.size.y;
                inputLineHeadSizeY.state.isEnabled = hasLineHead;
                const markerHeadFill = markerHead.fill;
                const buttonLineHeadColorValue = buttonLineHeadColor.value;
                buttonLineHeadColorValue.color = markerHeadFill.color;
                buttonLineHeadColorValue.alpha = markerHeadFill.alpha;
                buttonLineHeadColor.state.isEnabled = markerHeadFill.enable && hasLineHead;
                if (last instanceof wcardinalUi.EShapeConnectorLine) {
                    inputLineHeadMargin.input.value = last.edge.head.margin;
                    inputLineHeadMargin.state.isEnabled = hasLineHead;
                }
                else {
                    inputLineHeadMargin.state.isEnabled = false;
                }
            }
            else {
                layoutLine.state.isEnabled = false;
                buttonLineLock.state.isEnabled = false;
                selectLineStyle.state.isEnabled = false;
                selectLineType.state.isEnabled = false;
                buttonLineClosed.state.isEnabled = false;
                layoutLineTail.state.isEnabled = false;
                buttonLineTailLock.state.isEnabled = false;
                selectLineTailType.state.isEnabled = false;
                inputLineTailSizeX.state.isEnabled = false;
                inputLineTailSizeY.state.isEnabled = false;
                buttonLineTailColor.state.isEnabled = false;
                inputLineTailMargin.state.isEnabled = false;
                layoutLineHead.state.isEnabled = false;
                buttonLineHeadLock.state.isEnabled = false;
                selectLineHeadType.state.isEnabled = false;
                inputLineHeadSizeX.state.isEnabled = false;
                inputLineHeadSizeY.state.isEnabled = false;
                buttonLineHeadColor.state.isEnabled = false;
                inputLineHeadMargin.state.isEnabled = false;
            }
            // Corner
            if (last != null) {
                const hasBorderRadius = wcardinalUi.EShapeCapabilities.contains(last, wcardinalUi.EShapeCapability.BORDER_RADIUS);
                this.textCorner.state.isEnabled = hasBorderRadius;
                this.inputCornerRadius.value = last.radius;
                this.inputCornerRadius.state.isEnabled = hasBorderRadius;
                this.layoutCorner.state.isEnabled = hasBorderRadius;
                this.buttonCornerBottomLeft.state.isActive = !!(last.corner & wcardinalUi.EShapeCorner.BOTTOM_LEFT);
                this.buttonCornerBottomRight.state.isActive = !!(last.corner & wcardinalUi.EShapeCorner.BOTTOM_RIGHT);
                this.buttonCornerTopLeft.state.isActive = !!(last.corner & wcardinalUi.EShapeCorner.TOP_LEFT);
                this.buttonCornerTopRight.state.isActive = !!(last.corner & wcardinalUi.EShapeCorner.TOP_RIGHT);
            }
            // Texture
            if (last != null) {
                this.buttonTextureFitTo.state.isDisabled = last.image == null;
                this.buttonTextureClear.state.isDisabled = last.image == null;
            }
        }
        getType() {
            return "EEditorShape";
        }
    }

    class EEditorSnap extends wcardinalUi.DLayoutVertical {
        constructor(options) {
            super(options);
            // Icons
            this._icons = options.icons;
            // Diagram
            const diagram = options.diagram;
            this._diagram = diagram;
            this.state.isDisabled = diagram.canvas == null;
            diagram.on("unset", () => {
                this.state.isDisabled = true;
            });
            diagram.on("set", () => {
                this.state.isDisabled = false;
            });
            // Snapper
            const snapper = diagram.snapper;
            this._snapper = snapper;
            snapper.on("change", () => {
                this.onSnapperChange(snapper);
            });
            const snapperTarget = snapper.target;
            snapperTarget.on("change", () => {
                this.onSnapperTargetChange(snapperTarget);
            });
            const snapperGrid = snapper.grid;
            snapperGrid.on("change", () => {
                this.onSnapperGridChange(snapperGrid);
            });
            // Layout
            this.addChild(this.buttonLabel);
            this.addChild(this.buttonGrid);
            this.addChild(new wcardinalUi.DLayoutHorizontal({
                x: "padding",
                width: "padding",
                height: "auto",
                children: [this.buttonGridEye, this.inputGridSize]
            }));
            this.addChild(this.buttonTarget);
            this.addChild(new wcardinalUi.DLayoutHorizontal({
                x: "padding",
                width: "padding",
                height: "auto",
                children: [
                    new wcardinalUi.DLayoutSpace({ weight: 1 }),
                    this.buttonTargetNew,
                    this.buttonTargetDelete,
                    this.buttonTargetBringForward,
                    this.buttonTargetSendBackward,
                    this.buttonTargetEye,
                    new wcardinalUi.DLayoutSpace({ weight: 1 })
                ]
            }));
            this.addChild(this.listTarget);
            // Selection
            const listSnapTarget = this.listTarget;
            listSnapTarget.data.selection.on("change", () => {
                this.onSelectionChange(listSnapTarget);
            });
            // Initialization
            this.onSnapperChange(snapper);
            this.onSnapperTargetChange(snapperTarget);
            this.onSnapperGridChange(snapperGrid);
            this.onSelectionChange(listSnapTarget);
        }
        get buttonLabel() {
            let result = this._buttonLabel;
            if (result == null) {
                result = this.newButtonLabel();
                this._buttonLabel = result;
            }
            return result;
        }
        newButtonLabel() {
            const snapper = this._diagram.snapper;
            return new wcardinalUi.DButtonCheckRight({
                x: "padding",
                width: "padding",
                text: {
                    value: this.theme.getLabel()
                },
                padding: 0,
                background: {
                    color: null
                },
                on: {
                    active: () => {
                        if (!snapper.enable) {
                            wcardinalUi.DControllers.getCommandController().push(new ECommandDocumentSnapToggle(snapper));
                        }
                    },
                    inactive: () => {
                        if (snapper.enable) {
                            wcardinalUi.DControllers.getCommandController().push(new ECommandDocumentSnapToggle(snapper));
                        }
                    }
                }
            });
        }
        get buttonTarget() {
            let result = this._buttonTarget;
            if (result == null) {
                result = this.newButtonTarget();
                this._buttonTarget = result;
            }
            return result;
        }
        newButtonTarget() {
            return new wcardinalUi.DButtonCheckRight({
                x: "padding",
                width: "padding",
                text: {
                    value: this.theme.getButtonTargetLabel()
                },
                padding: 0,
                background: {
                    color: null
                },
                on: {
                    active: () => {
                        const snapper = this._snapper;
                        if (!snapper.target.enable) {
                            wcardinalUi.DControllers.getCommandController().push(new ECommandDocumentSnapTargetToggle(snapper));
                        }
                    },
                    inactive: () => {
                        const snapper = this._snapper;
                        if (snapper.target.enable) {
                            wcardinalUi.DControllers.getCommandController().push(new ECommandDocumentSnapTargetToggle(snapper));
                        }
                    }
                }
            });
        }
        get buttonTargetNew() {
            let result = this._buttonTargetNew;
            if (result == null) {
                result = this.newButtonTargetNew();
                this._buttonTargetNew = result;
            }
            return result;
        }
        newButtonTargetNew() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.new
                },
                title: this.theme.getButtonTargetNewTitle(),
                on: {
                    active: (emitter) => {
                        this.onButtonTargetNewActive(emitter);
                    }
                }
            });
        }
        onButtonTargetNewActive(opener) {
            this.dialogTarget
                .reset()
                .open(opener)
                .then((value) => {
                if (value != null) {
                    wcardinalUi.DControllers.getCommandController().push(new ECommandDocumentSnapCreate(this._snapper, value));
                }
            });
        }
        get buttonTargetDelete() {
            let result = this._buttonTargetDelete;
            if (result == null) {
                result = this.newButtonTargetDelete();
                this._buttonTargetDelete = result;
            }
            return result;
        }
        newButtonTargetDelete() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.delete
                },
                title: this.theme.getButtonTargetDeleteTitle(),
                state: wcardinalUi.DBaseState.DISABLED,
                on: {
                    active: () => {
                        const listTarget = this.listTarget;
                        const first = listTarget.data.selection.first;
                        if (first != null) {
                            const items = listTarget.data.items;
                            const index = items.indexOf(first);
                            if (0 <= index) {
                                wcardinalUi.DControllers.getCommandController().push(new ECommandDocumentSnapDelete(this._snapper, index, first));
                            }
                        }
                    }
                }
            });
        }
        get buttonTargetBringForward() {
            let result = this._buttonTargetBringForward;
            if (result == null) {
                result = this.newButtonTargetBringForward();
                this._buttonTargetBringForward = result;
            }
            return result;
        }
        newButtonTargetBringForward() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.arrow_up
                },
                title: this.theme.getButtonTargetBringForwardTitle(),
                state: wcardinalUi.DBaseState.DISABLED,
                on: {
                    active: () => {
                        const listTarget = this.listTarget;
                        const first = listTarget.data.selection.first;
                        const items = listTarget.data.items;
                        if (first != null && items[0] !== first) {
                            const index = items.indexOf(first);
                            if (0 <= index) {
                                wcardinalUi.DControllers.getCommandController().push(new ECommandDocumentSnapBringForward(this._snapper, index));
                            }
                        }
                    }
                }
            });
        }
        get buttonTargetSendBackward() {
            let result = this._buttonTargetSendBackward;
            if (result == null) {
                result = this.newButtonTargetSendBackward();
                this._buttonTargetSendBackward = result;
            }
            return result;
        }
        newButtonTargetSendBackward() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.arrow_down
                },
                title: this.theme.getButtonTargetSendBackwardTitle(),
                state: wcardinalUi.DBaseState.DISABLED,
                on: {
                    active: () => {
                        const snapper = this._snapper;
                        const listTarget = this.listTarget;
                        const first = listTarget.data.selection.first;
                        const items = listTarget.data.items;
                        if (first != null && items[items.length] !== first) {
                            const index = items.indexOf(first);
                            if (0 <= index) {
                                wcardinalUi.DControllers.getCommandController().push(new ECommandDocumentSnapSendBackward(snapper, index));
                            }
                        }
                    }
                }
            });
        }
        get buttonTargetEye() {
            let result = this._buttonTargetEye;
            if (result == null) {
                result = this.newButtonTargetEye();
                this._buttonTargetEye = result;
            }
            return result;
        }
        newButtonTargetEye() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.eye
                },
                title: this.theme.getButtonTargetEyeTitle(),
                on: {
                    active: () => {
                        wcardinalUi.DControllers.getCommandController().push(new ECommandDocumentSnapTargetToggleVisibility(this._snapper));
                    }
                }
            });
        }
        get dialogTarget() {
            let result = this._dialogTarget;
            if (result == null) {
                result = this.newDialogTarget();
                this._dialogTarget = result;
            }
            return result;
        }
        newDialogTarget() {
            return new EDialogSnap();
        }
        get listTarget() {
            let result = this._listTarget;
            if (result == null) {
                result = this.newListTarget();
                this._listTarget = result;
            }
            return result;
        }
        newListTarget() {
            const theme = this.theme;
            const result = new wcardinalUi.DList({
                x: "padding",
                width: "padding",
                weight: 1,
                data: {
                    toLabel: (value) => {
                        return theme.getListTargetItemLabel(value);
                    }
                },
                updater: {
                    newItem: (data) => {
                        return new wcardinalUi.DListItem(data, {
                            on: {
                                dblclick: (e, _, item) => {
                                    this.onListTargetDblClick(e, _, item, result);
                                }
                            }
                        });
                    }
                }
            });
            return result;
        }
        onListTargetDblClick(e, _, item, list) {
            const oldValue = item.value;
            if (oldValue != null) {
                const index = list.data.items.indexOf(oldValue);
                if (0 <= index) {
                    const dialog = this.dialogTarget;
                    dialog.value = oldValue;
                    dialog.open(item).then((newValue) => {
                        if (newValue != null) {
                            wcardinalUi.DControllers.getCommandController().push(new ECommandDocumentSnapReplace(this._snapper, oldValue, newValue, list));
                        }
                    });
                }
            }
        }
        get buttonGrid() {
            let result = this._buttonGrid;
            if (result == null) {
                result = this.newButtonGrid();
                this._buttonGrid = result;
            }
            return result;
        }
        newButtonGrid() {
            return new wcardinalUi.DButtonCheckRight({
                x: "padding",
                width: "padding",
                text: {
                    value: this.theme.getButtonGridLabel()
                },
                padding: 0,
                background: {
                    color: null
                },
                on: {
                    active: () => {
                        const snapper = this._snapper;
                        if (!snapper.grid.enable) {
                            wcardinalUi.DControllers.getCommandController().push(new ECommandDocumentSnapGridToggle(snapper));
                        }
                    },
                    inactive: () => {
                        const snapper = this._snapper;
                        if (snapper.grid.enable) {
                            wcardinalUi.DControllers.getCommandController().push(new ECommandDocumentSnapGridToggle(snapper));
                        }
                    }
                }
            });
        }
        get buttonGridEye() {
            let result = this._buttonGridEye;
            if (result == null) {
                result = this.newButtonGridEye();
                this._buttonGridEye = result;
            }
            return result;
        }
        newButtonGridEye() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.eye
                },
                title: this.theme.getButtonGridEyeTitle(),
                on: {
                    active: () => {
                        wcardinalUi.DControllers.getCommandController().push(new ECommandDocumentSnapGridToggleVisibility(this._snapper));
                    }
                }
            });
        }
        get inputGridSize() {
            let result = this._inputGridSize;
            if (result == null) {
                result = this.newInputGridSize();
                this._inputGridSize = result;
            }
            return result;
        }
        newInputGridSize() {
            return new wcardinalUi.DInputRealAndLabel({
                weight: 1,
                label: {
                    text: {
                        value: this.theme.getInputGridSizeLabel()
                    }
                },
                input: {
                    weight: 1,
                    text: {
                        value: 10
                    },
                    min: 2,
                    on: {
                        change: (value) => {
                            wcardinalUi.DControllers.getCommandController().push(new ECommandDocumentSnapGridSize(this._snapper, value));
                        }
                    }
                }
            });
        }
        onSnapperChange(snapper) {
            this.buttonLabel.state.isActive = snapper.enable;
        }
        onSnapperTargetChange(target) {
            this.buttonTarget.state.isActive = target.enable;
            const icons = this._icons;
            this.buttonTargetEye.image = target.visible ? icons.eye : icons.eye_slash;
            const listTarget = this.listTarget;
            listTarget.data.items = target.values;
            this.onSelectionChange(listTarget);
        }
        onSnapperGridChange(grid) {
            this.buttonGrid.state.isActive = grid.enable;
            const icons = this._icons;
            this.buttonGridEye.image = grid.visible ? icons.eye : icons.eye_slash;
            this.inputGridSize.input.value = grid.size;
        }
        onSelectionChange(listSnapTarget) {
            this.buttonTargetDelete.state.isDisabled = listSnapTarget.data.selection.isEmpty();
            const first = listSnapTarget.data.selection.first;
            const items = listSnapTarget.data.items;
            this.buttonTargetBringForward.state.isDisabled = first == null || items[0] === first;
            this.buttonTargetSendBackward.state.isDisabled =
                first == null || items[items.length - 1] === first;
        }
        getType() {
            return "EEditorSnap";
        }
    }

    class EEditorText extends wcardinalUi.DPane {
        constructor(options) {
            super(options);
            this._fromShapeTextRegEx = /\\+n|\n/g;
            this._toShapeTextRegEx = /\\+n/g;
            const selection = options.selection;
            this._selection = selection;
            const icons = options.icons;
            this._icons = icons;
            const theme = this.theme;
            new wcardinalUi.DLayoutVertical({
                parent: this.content,
                x: "padding",
                y: "padding",
                width: "padding",
                height: "auto",
                children: [
                    this.newLabel(theme.getLabel()),
                    this.inputText,
                    this.newLabel(theme.getTextFontLabel()),
                    this.dropdownFontFamily,
                    this.buttonFontColor,
                    new wcardinalUi.DLayoutHorizontal({
                        width: "100%",
                        height: "auto",
                        children: [
                            this.inputFontSize,
                            this.buttonFontSizeDecrease,
                            this.buttonFontSizeIncrease,
                            this.buttonFontItalic,
                            this.buttonFontBold
                        ]
                    }),
                    this.buttonOutline,
                    this.buttonOutlineColor,
                    this.inputOutlineWidth,
                    this.newLabel(theme.getTextAlignLabel()),
                    new wcardinalUi.DLayoutVertical({
                        width: "100%",
                        height: "auto",
                        column: EEDITOR_BUTTON_COUNT,
                        children: [
                            this.buttonAlignOutsideLeft,
                            this.buttonAlignLeft,
                            this.buttonAlignCenter,
                            this.buttonAlignRight,
                            this.buttonAlignOutsideRight,
                            this.buttonAlignOutsideTop,
                            this.buttonAlignTop,
                            this.buttonAlignMiddle,
                            this.buttonAlignBottom,
                            this.buttonAlignOutsideBottom,
                            this.buttonDirectionLeftToRight,
                            this.buttonDirectionTopToBottom,
                            this.buttonDirectionBottomToTop,
                            this.buttonDirectionRightToLeft
                        ]
                    }),
                    this.buttonClipping,
                    this.buttonFitting,
                    this.newLabel(theme.getTextSpacingLabel()),
                    new wcardinalUi.DLayoutHorizontal({
                        width: "100%",
                        children: [this.inputSpacingHorizontal, this.inputSpacingVertical]
                    }),
                    this.newLabel(theme.getTextPaddingLabel()),
                    new wcardinalUi.DLayoutHorizontal({
                        width: "100%",
                        children: [this.inputPaddingHorizontal, this.inputPaddingVertical]
                    }),
                    this.newLabel(theme.getTextOffsetLabel()),
                    new wcardinalUi.DLayoutHorizontal({
                        width: "100%",
                        children: [this.inputOffsetHorizontal, this.inputOffsetVertical]
                    })
                ]
            });
            selection.on("change", () => {
                this.onSelectionChange(selection);
            });
            this.onSelectionChange(selection);
        }
        newLabel(label) {
            return new wcardinalUi.DText({
                width: "100%",
                text: {
                    value: label
                }
            });
        }
        get inputText() {
            let result = this._inputText;
            if (result == null) {
                result = this.newInputText();
                this._inputText = result;
            }
            return result;
        }
        newInputText() {
            return new wcardinalUi.DInputTextArea({
                width: "100%",
                height: this.theme.getInputTextHeight(),
                text: {
                    value: ""
                },
                on: {
                    input: (value) => {
                        this._selection.setText(value);
                    }
                }
            });
        }
        get dropdownFontFamily() {
            let result = this._dropdownFontFamily;
            if (result == null) {
                result = this.newDropdownFontFamily();
                this._dropdownFontFamily = result;
            }
            return result;
        }
        newDropdownFontFamily() {
            return new wcardinalUi.DDropdown({
                width: "100%",
                text: {
                    value: this.fontFamilies.get("auto")
                },
                menu: {
                    width: "auto",
                    column: 3,
                    fit: false,
                    items: this.newDropdownFontFamilyMenuItems()
                },
                on: {
                    select: (value) => {
                        var _a;
                        this.dropdownFontFamily.text = (_a = this.fontFamilies.get(value)) !== null && _a !== void 0 ? _a : value;
                        this._selection.setTextFamily(value);
                    }
                }
            });
        }
        newDropdownFontFamilyMenuItems() {
            const result = [];
            this.fontFamilies.forEach((label, fontFamily) => {
                result.push({
                    width: 200,
                    value: fontFamily,
                    text: {
                        value: label
                    }
                });
            });
            return result;
        }
        get fontFamilies() {
            let result = this._fontFamilies;
            if (result == null) {
                result = this.theme.getFontFamilies();
                this._fontFamilies = result;
            }
            return result;
        }
        get buttonFontColor() {
            let result = this._buttonFontColor;
            if (result == null) {
                result = this.newButtonFontColor();
                this._buttonFontColor = result;
            }
            return result;
        }
        newButtonFontColor() {
            const result = new wcardinalUi.DButtonColor({
                width: "100%",
                on: {
                    change: (value) => {
                        this._selection.setTextColor(value.color, value.alpha);
                    }
                }
            });
            result.dialog.on("open", () => {
                const dialog = result.dialog;
                const dialogNew = dialog.new;
                const dialogCurrent = dialog.current;
                dialogNew.color = dialogCurrent.color;
                dialogNew.alpha = dialogCurrent.alpha;
            });
            return result;
        }
        get inputFontSize() {
            let result = this._inputFontSize;
            if (result == null) {
                result = this.newInputFontSize();
                this._inputFontSize = result;
            }
            return result;
        }
        newInputFontSize() {
            return new wcardinalUi.DInputReal({
                weight: 1,
                text: {
                    value: 0
                },
                min: 0,
                on: {
                    input: (size) => {
                        this._selection.setTextSize(size);
                    }
                }
            });
        }
        get buttonFontSizeDecrease() {
            let result = this._buttonFontSizeDecrease;
            if (result == null) {
                result = this.newButtonFontSizeDecrease();
                this._buttonFontSizeDecrease = result;
            }
            return result;
        }
        newButtonFontSizeDecrease() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.editor_font_size_decrease
                },
                title: this.theme.getButtonFontSizeDecreaseTitle(),
                on: {
                    active: () => {
                        this._selection.setTextSizeDelta(-1);
                    }
                }
            });
        }
        get buttonFontSizeIncrease() {
            let result = this._buttonFontSizeIncrease;
            if (result == null) {
                result = this.newButtonFontSizeIncrease();
                this._buttonFontSizeIncrease = result;
            }
            return result;
        }
        newButtonFontSizeIncrease() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.editor_font_size_increase
                },
                title: this.theme.getButtonFontSizeIncreaseTitle(),
                on: {
                    active: () => {
                        this._selection.setTextSizeDelta(+1);
                    }
                }
            });
        }
        get buttonFontItalic() {
            let result = this._buttonFontItalic;
            if (result == null) {
                result = this.newButtonFontItalic();
                this._buttonFontItalic = result;
            }
            return result;
        }
        newButtonFontItalic() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.italic
                },
                toggle: true,
                title: this.theme.getButtonFontItalicTitle(),
                on: {
                    active: () => {
                        this._selection.setTextStyle(wcardinalUi.EShapeTextStyle.ITALIC);
                    },
                    inactive: () => {
                        this._selection.setTextStyle(wcardinalUi.EShapeTextStyle.NORMAL);
                    }
                }
            });
        }
        get buttonFontBold() {
            let result = this._buttonFontBold;
            if (result == null) {
                result = this.newButtonFontBold();
                this._buttonFontBold = result;
            }
            return result;
        }
        newButtonFontBold() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.bold
                },
                toggle: true,
                title: this.theme.getButtonFontBoldTitle(),
                on: {
                    active: () => {
                        this._selection.setTextWeight(wcardinalUi.EShapeTextWeight.BOLD);
                    },
                    inactive: () => {
                        this._selection.setTextWeight(wcardinalUi.EShapeTextWeight.NORMAL);
                    }
                }
            });
        }
        get buttonOutline() {
            let result = this._buttonOutline;
            if (result == null) {
                result = this.newButtonOutline();
                this._buttonOutline = result;
            }
            return result;
        }
        newButtonOutline() {
            return new wcardinalUi.DButtonCheckRight({
                width: "100%",
                text: {
                    value: this.theme.getButtonOutlineLabel()
                },
                padding: 0,
                background: {
                    color: null
                },
                on: {
                    active: () => {
                        this._selection.setTextOutlineEnabled(true);
                    },
                    inactive: () => {
                        this._selection.setTextOutlineEnabled(false);
                    }
                }
            });
        }
        get buttonOutlineColor() {
            let result = this._buttonOutlineColor;
            if (result == null) {
                result = this.newButtonOutlineColor();
                this._buttonOutlineColor = result;
            }
            return result;
        }
        newButtonOutlineColor() {
            const result = new wcardinalUi.DButtonColor({
                width: "100%",
                on: {
                    change: (value) => {
                        this._selection.setTextOutlineColor(value.color, value.alpha);
                    }
                }
            });
            result.dialog.on("open", () => {
                const dialog = result.dialog;
                const dialogNew = dialog.new;
                const dialogCurrent = dialog.current;
                dialogNew.color = dialogCurrent.color;
                dialogNew.alpha = dialogCurrent.alpha;
            });
            return result;
        }
        get inputOutlineWidth() {
            var _a;
            return ((_a = this._inputOutlineWidth) !== null && _a !== void 0 ? _a : (this._inputOutlineWidth = this.newInputOutlineWidth()));
        }
        newInputOutlineWidth() {
            return new wcardinalUi.DInputRealAndLabel({
                width: "100%",
                label: {
                    text: {
                        value: this.theme.getInputOutlineWidthLabel()
                    }
                },
                input: {
                    weight: 1,
                    min: 0,
                    step: 1,
                    max: 100,
                    on: {
                        change: (value) => {
                            this._selection.setTextOutlineWidth(value * 0.01);
                        }
                    }
                }
            });
        }
        get buttonAlignOutsideLeft() {
            let result = this._buttonAlignOutsideLeft;
            if (result == null) {
                result = this.newButtonAlignOutsideLeft();
                this._buttonAlignOutsideLeft = result;
            }
            return result;
        }
        newButtonAlignOutsideLeft() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.text_align_outside_left
                },
                title: this.theme.getButtonAlignOutsideLeftTitle(),
                on: {
                    active: () => {
                        this._selection.setTextAlignHorizontal(wcardinalUi.EShapeTextAlignHorizontal.OUTSIDE_LEFT);
                    }
                }
            });
        }
        get buttonAlignLeft() {
            let result = this._buttonAlignLeft;
            if (result == null) {
                result = this.newButtonAlignLeft();
                this._buttonAlignLeft = result;
            }
            return result;
        }
        newButtonAlignLeft() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.text_align_left
                },
                title: this.theme.getButtonAlignLeftTitle(),
                on: {
                    active: () => {
                        this._selection.setTextAlignHorizontal(wcardinalUi.EShapeTextAlignHorizontal.LEFT);
                    }
                }
            });
        }
        get buttonAlignCenter() {
            let result = this._buttonAlignCenter;
            if (result == null) {
                result = this.newButtonAlignCenter();
                this._buttonAlignCenter = result;
            }
            return result;
        }
        newButtonAlignCenter() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.text_align_center
                },
                title: this.theme.getButtonAlignCenterTitle(),
                on: {
                    active: () => {
                        this._selection.setTextAlignHorizontal(wcardinalUi.EShapeTextAlignHorizontal.CENTER);
                    }
                }
            });
        }
        get buttonAlignRight() {
            let result = this._buttonAlignRight;
            if (result == null) {
                result = this.newButtonAlignRight();
                this._buttonAlignRight = result;
            }
            return result;
        }
        newButtonAlignRight() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.text_align_right
                },
                title: this.theme.getButtonAlignRightTitle(),
                on: {
                    active: () => {
                        this._selection.setTextAlignHorizontal(wcardinalUi.EShapeTextAlignHorizontal.RIGHT);
                    }
                }
            });
        }
        get buttonAlignOutsideRight() {
            let result = this._buttonAlignOutsideRight;
            if (result == null) {
                result = this.newButtonAlignOutsideRight();
                this._buttonAlignOutsideRight = result;
            }
            return result;
        }
        newButtonAlignOutsideRight() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.text_align_outside_right
                },
                title: this.theme.getButtonAlignOutsideRightTitle(),
                on: {
                    active: () => {
                        this._selection.setTextAlignHorizontal(wcardinalUi.EShapeTextAlignHorizontal.OUTSIDE_RIGHT);
                    }
                }
            });
        }
        get buttonAlignOutsideTop() {
            let result = this._buttonAlignOutsideTop;
            if (result == null) {
                result = this.newButtonAlignOutsideTop();
                this._buttonAlignOutsideTop = result;
            }
            return result;
        }
        newButtonAlignOutsideTop() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.text_align_outside_top
                },
                title: this.theme.getButtonAlignOutsideTopTitle(),
                on: {
                    active: () => {
                        this._selection.setTextAlignVertical(wcardinalUi.EShapeTextAlignVertical.OUTSIDE_TOP);
                    }
                }
            });
        }
        get buttonAlignTop() {
            let result = this._buttonAlignTop;
            if (result == null) {
                result = this.newButtonAlignTop();
                this._buttonAlignTop = result;
            }
            return result;
        }
        newButtonAlignTop() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.text_align_top
                },
                title: this.theme.getButtonAlignTopTitle(),
                on: {
                    active: () => {
                        this._selection.setTextAlignVertical(wcardinalUi.EShapeTextAlignVertical.TOP);
                    }
                }
            });
        }
        get buttonAlignMiddle() {
            let result = this._buttonAlignMiddle;
            if (result == null) {
                result = this.newButtonAlignMiddle();
                this._buttonAlignMiddle = result;
            }
            return result;
        }
        newButtonAlignMiddle() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.text_align_middle
                },
                title: this.theme.getButtonAlignMiddleTitle(),
                on: {
                    active: () => {
                        this._selection.setTextAlignVertical(wcardinalUi.EShapeTextAlignVertical.MIDDLE);
                    }
                }
            });
        }
        get buttonAlignBottom() {
            let result = this._buttonAlignBottom;
            if (result == null) {
                result = this.newButtonAlignBottom();
                this._buttonAlignBottom = result;
            }
            return result;
        }
        newButtonAlignBottom() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.text_align_bottom
                },
                title: this.theme.getButtonAlignBottomTitle(),
                on: {
                    active: () => {
                        this._selection.setTextAlignVertical(wcardinalUi.EShapeTextAlignVertical.BOTTOM);
                    }
                }
            });
        }
        get buttonAlignOutsideBottom() {
            let result = this._buttonAlignOutsideBottom;
            if (result == null) {
                result = this.newButtonAlignOutsideBottom();
                this._buttonAlignOutsideBottom = result;
            }
            return result;
        }
        newButtonAlignOutsideBottom() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.text_align_outside_bottom
                },
                title: this.theme.getButtonAlignOutsideBottomTitle(),
                on: {
                    active: () => {
                        this._selection.setTextAlignVertical(wcardinalUi.EShapeTextAlignVertical.OUTSIDE_BOTTOM);
                    }
                }
            });
        }
        get buttonDirectionLeftToRight() {
            let result = this._buttonDirectionLeftToRight;
            if (result == null) {
                result = this.newButtonDirectionLeftToRight();
                this._buttonDirectionLeftToRight = result;
            }
            return result;
        }
        newButtonDirectionLeftToRight() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.text_direction_left_to_right
                },
                title: this.theme.getButtonDirectionLeftToRightTitle(),
                on: {
                    active: () => {
                        this._selection.setTextDirection(wcardinalUi.EShapeTextDirection.LEFT_TO_RIGHT);
                    }
                }
            });
        }
        get buttonDirectionTopToBottom() {
            let result = this._buttonDirectionTopToBottom;
            if (result == null) {
                result = this.newButtonDirectionTopToBottom();
                this._buttonDirectionTopToBottom = result;
            }
            return result;
        }
        newButtonDirectionTopToBottom() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.text_direction_top_to_bottom
                },
                title: this.theme.getButtonDirectionTopToBottomTitle(),
                on: {
                    active: () => {
                        this._selection.setTextDirection(wcardinalUi.EShapeTextDirection.TOP_TO_BOTTOM);
                    }
                }
            });
        }
        get buttonDirectionBottomToTop() {
            let result = this._buttonDirectionBottomToTop;
            if (result == null) {
                result = this.newButtonDirectionBottomToTop();
                this._buttonDirectionBottomToTop = result;
            }
            return result;
        }
        newButtonDirectionBottomToTop() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.text_direction_bottom_to_top
                },
                title: this.theme.getButtonDirectionBottomToTopTitle(),
                on: {
                    active: () => {
                        this._selection.setTextDirection(wcardinalUi.EShapeTextDirection.BOTTOM_TO_TOP);
                    }
                }
            });
        }
        get buttonDirectionRightToLeft() {
            let result = this._buttonDirectionRightToLeft;
            if (result == null) {
                result = this.newButtonDirectionRightToLeft();
                this._buttonDirectionRightToLeft = result;
            }
            return result;
        }
        newButtonDirectionRightToLeft() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.text_direction_right_to_left
                },
                title: this.theme.getButtonDirectionRightToLeftTitle(),
                on: {
                    active: () => {
                        this._selection.setTextDirection(wcardinalUi.EShapeTextDirection.RIGHT_TO_LEFT);
                    }
                }
            });
        }
        get buttonClipping() {
            let result = this._buttonClipping;
            if (result == null) {
                result = this.newButtonClipping();
                this._buttonClipping = result;
            }
            return result;
        }
        newButtonClipping() {
            return new wcardinalUi.DButtonCheckRight({
                width: "100%",
                text: {
                    value: this.theme.getButtonClippingLabel()
                },
                padding: 0,
                background: {
                    color: null
                },
                on: {
                    active: () => {
                        this._selection.setTextClipping(true);
                    },
                    inactive: () => {
                        this._selection.setTextClipping(false);
                    }
                }
            });
        }
        get buttonFitting() {
            let result = this._buttonFitting;
            if (result == null) {
                result = this.newButtonFitting();
                this._buttonFitting = result;
            }
            return result;
        }
        newButtonFitting() {
            return new wcardinalUi.DButtonCheckRight({
                width: "100%",
                text: {
                    value: this.theme.getButtonFittingLabel()
                },
                padding: 0,
                background: {
                    color: null
                },
                on: {
                    active: () => {
                        this._selection.setTextFitting(true);
                    },
                    inactive: () => {
                        this._selection.setTextFitting(false);
                    }
                }
            });
        }
        get inputSpacingHorizontal() {
            let result = this._inputSpacingHorizontal;
            if (result == null) {
                result = this.newInputSpacingHorizontal();
                this._inputSpacingHorizontal = result;
            }
            return result;
        }
        newInputSpacingHorizontal() {
            return new wcardinalUi.DInputReal({
                weight: 1,
                step: 1,
                text: {
                    value: 0
                },
                on: {
                    change: (value) => {
                        this._selection.setTextSpacingHorizontal(value);
                    }
                }
            });
        }
        get inputSpacingVertical() {
            let result = this._inputSpacingVertical;
            if (result == null) {
                result = this.newInputSpacingVertical();
                this._inputSpacingVertical = result;
            }
            return result;
        }
        newInputSpacingVertical() {
            return new wcardinalUi.DInputReal({
                weight: 1,
                step: 1,
                text: {
                    value: 0
                },
                on: {
                    change: (value) => {
                        this._selection.setTextSpacingVertical(value);
                    }
                }
            });
        }
        get inputPaddingHorizontal() {
            let result = this._inputPaddingHorizontal;
            if (result == null) {
                result = this.newInputPaddingHorizontal();
                this._inputPaddingHorizontal = result;
            }
            return result;
        }
        newInputPaddingHorizontal() {
            return new wcardinalUi.DInputReal({
                weight: 1,
                step: 1,
                text: {
                    value: 0
                },
                on: {
                    change: (value) => {
                        this._selection.setTextPaddingHorizontal(value);
                    }
                }
            });
        }
        get inputPaddingVertical() {
            let result = this._inputTextPaddingVertical;
            if (result == null) {
                result = this.newInputPaddingVertical();
                this._inputTextPaddingVertical = result;
            }
            return result;
        }
        newInputPaddingVertical() {
            return new wcardinalUi.DInputReal({
                weight: 1,
                step: 1,
                text: {
                    value: 0
                },
                on: {
                    change: (value) => {
                        this._selection.setTextPaddingVertical(value);
                    }
                }
            });
        }
        get inputOffsetHorizontal() {
            let result = this._inputOffsetHorizontal;
            if (result == null) {
                result = this.newInputOffsetHorizontal();
                this._inputOffsetHorizontal = result;
            }
            return result;
        }
        newInputOffsetHorizontal() {
            return new wcardinalUi.DInputReal({
                weight: 1,
                step: 1,
                text: {
                    value: 0
                },
                on: {
                    change: (value) => {
                        this._selection.setTextOffsetHorizontal(value);
                    }
                }
            });
        }
        get inputOffsetVertical() {
            let result = this._inputOffsetVertical;
            if (result == null) {
                result = this.newInputOffsetVertical();
                this._inputOffsetVertical = result;
            }
            return result;
        }
        newInputOffsetVertical() {
            return new wcardinalUi.DInputReal({
                weight: 1,
                step: 1,
                text: {
                    value: 0
                },
                on: {
                    change: (value) => {
                        this._selection.setTextOffsetVertical(value);
                    }
                }
            });
        }
        onSelectionChange(selection) {
            var _a;
            this.state.isDisabled = selection.isEmpty();
            const last = selection.last();
            if (last != null) {
                const text = last.text;
                this.inputText.value = text.value;
                const textFamily = text.family;
                this.dropdownFontFamily.text = (_a = this.fontFamilies.get(textFamily)) !== null && _a !== void 0 ? _a : textFamily;
                const buttonFontColor = this.buttonFontColor.value;
                buttonFontColor.color = text.color;
                buttonFontColor.alpha = text.alpha;
                this.inputFontSize.value = text.size;
                this.buttonFontItalic.state.isActive = text.style === wcardinalUi.EShapeTextStyle.ITALIC;
                this.buttonFontBold.state.isActive = text.weight === wcardinalUi.EShapeTextWeight.BOLD;
                const outline = text.outline;
                this.buttonOutline.state.isActive = outline.enable;
                const buttonOutlineColor = this.buttonOutlineColor;
                const buttonOutlineColorValue = buttonOutlineColor.value;
                buttonOutlineColorValue.color = outline.color;
                buttonOutlineColorValue.alpha = outline.alpha;
                buttonOutlineColor.state.isDisabled = !outline.enable;
                const inputOutlineWidth = this.inputOutlineWidth;
                inputOutlineWidth.input.value = outline.width * 100;
                inputOutlineWidth.state.isDisabled = !outline.enable;
                this.buttonClipping.state.isActive = text.clipping;
                this.buttonFitting.state.isActive = text.fitting;
                const spacing = text.spacing;
                this.inputSpacingHorizontal.value = spacing.horizontal;
                this.inputSpacingVertical.value = spacing.vertical;
                const padding = text.padding;
                this.inputPaddingHorizontal.value = padding.horizontal;
                this.inputPaddingVertical.value = padding.vertical;
                const offset = text.offset;
                this.inputOffsetHorizontal.value = offset.horizontal;
                this.inputOffsetVertical.value = offset.vertical;
            }
        }
        getType() {
            return "EEditorText";
        }
    }

    const COMPARATOR = (a, b) => {
        return a[0] - b[0];
    };
    class EEditorTreeSelection extends pixi_js.utils.EventEmitter {
        constructor(parent, selection) {
            super();
            this._parent = parent;
            this._selection = selection;
        }
        get parent() {
            return this._parent;
        }
        get indices() {
            const selection = this._selection;
            const result = [];
            this._parent.each((row, index) => {
                if (selection.contains(row)) {
                    result.push(index);
                }
            });
            return result;
        }
        get rows() {
            const selection = this._selection;
            const result = [];
            this._parent.each((row, index) => {
                if (selection.contains(row)) {
                    result.push(row);
                }
            });
            return result;
        }
        get type() {
            return wcardinalUi.DTableDataSelectionType.MULTIPLE;
        }
        get first() {
            const row = this._selection.first();
            if (row) {
                return this.toIndex(row);
            }
            return null;
        }
        get last() {
            const row = this._selection.last();
            if (row) {
                return this.toIndex(row);
            }
            return null;
        }
        onNodeChange(nodes) {
            // DO NOTHING
        }
        toggle(rowIndex) {
            const row = this._parent.get(rowIndex);
            if (row) {
                const selection = this._selection;
                const before = selection.store();
                selection.toggle(row);
                selection.focus();
                const after = selection.store();
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapeSelect(before, after, selection));
            }
        }
        add(rowIndex) {
            const row = this._parent.get(rowIndex);
            if (row) {
                const selection = this._selection;
                if (!selection.contains(row)) {
                    const before = selection.store();
                    selection.toggle(row);
                    selection.focus();
                    const after = selection.store();
                    wcardinalUi.DControllers.getCommandController().push(new ECommandShapeSelect(before, after, selection));
                }
            }
        }
        toIndex(target) {
            let result = null;
            this._parent.each((row, index) => {
                if (target === row) {
                    result = index;
                    return false;
                }
                return true;
            });
            return result;
        }
        addTo(rowIndex) {
            const last = this._selection.last();
            if (last != null) {
                const index = this.toIndex(last);
                if (index != null) {
                    this.addRange(index, false, rowIndex, true);
                }
            }
        }
        addRange(from, includeFrom, to, includeTo) {
            const rows = [];
            const parent = this._parent;
            const selection = this._selection;
            if (from < to) {
                parent.each((row) => {
                    if (!selection.contains(row)) {
                        rows.push(row);
                    }
                }, from + (includeFrom ? 0 : 1), to + (includeTo ? 1 : 0));
            }
            else {
                parent.each((row) => {
                    if (!selection.contains(row)) {
                        rows.push(row);
                    }
                }, to + (includeTo ? 0 : 1), from + (includeFrom ? 1 : 0));
            }
            if (0 < rows.length) {
                const before = selection.store();
                selection.addAll(rows);
                selection.focus();
                const after = selection.store();
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapeSelect(before, after, selection));
            }
        }
        addAll(rowIndices) {
            if (0 < rowIndices.length) {
                const rows = [];
                const parent = this._parent;
                const selection = this._selection;
                for (let i = 0, imax = rowIndices.length; i < imax; ++i) {
                    const row = parent.get(rowIndices[i]);
                    if (row && !selection.contains(row)) {
                        rows.push(row);
                    }
                }
                if (0 < rows.length) {
                    const before = selection.store();
                    selection.addAll(rows);
                    selection.focus();
                    const after = selection.store();
                    wcardinalUi.DControllers.getCommandController().push(new ECommandShapeSelect(before, after, selection));
                }
            }
        }
        contains(rowIndex) {
            const row = this._parent.get(rowIndex);
            if (row) {
                return this._selection.contains(row);
            }
            return false;
        }
        remove(rowIndex) {
            const row = this._parent.get(rowIndex);
            if (row) {
                const selection = this._selection;
                if (selection.contains(row)) {
                    const before = selection.store();
                    selection.remove(row);
                    selection.focus();
                    const after = selection.store();
                    wcardinalUi.DControllers.getCommandController().push(new ECommandShapeSelect(before, after, selection));
                }
            }
        }
        clear() {
            const selection = this._selection;
            if (!selection.isEmpty()) {
                const before = selection.store();
                selection.clear();
                selection.focus();
                const after = selection.store();
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapeSelect(before, after, selection));
            }
        }
        clearAndAdd(rowIndex) {
            const row = this._parent.get(rowIndex);
            if (row) {
                const selection = this._selection;
                if (selection.contains(row)) {
                    if (1 < selection.size()) {
                        const before = selection.store();
                        selection.set(row);
                        selection.focus();
                        const after = selection.store();
                        wcardinalUi.DControllers.getCommandController().push(new ECommandShapeSelect(before, after, selection));
                    }
                    else {
                        selection.focus();
                    }
                }
                else {
                    const before = selection.store();
                    selection.set(row);
                    selection.focus();
                    const after = selection.store();
                    wcardinalUi.DControllers.getCommandController().push(new ECommandShapeSelect(before, after, selection));
                }
            }
        }
        clearAndAddAll(rowIndices) {
            const selection = this._selection;
            if (!selection.isEmpty() || 0 < rowIndices.length) {
                const rows = [];
                const parent = this._parent;
                for (let i = 0, imax = rowIndices.length; i < imax; ++i) {
                    const row = parent.get(rowIndices[i]);
                    if (row) {
                        rows.push(row);
                    }
                }
                const before = selection.store();
                selection.clearAndAddAll(rows);
                selection.focus();
                const after = selection.store();
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapeSelect(before, after, selection));
            }
        }
        shift(rowIndex, amount) {
            // DO NOTHING
        }
        size() {
            return this._selection.size();
        }
        isEmpty() {
            return this._selection.isEmpty();
        }
        each(iteratee) {
            const selection = this._selection;
            this._parent.each((row, index) => {
                if (selection.contains(row)) {
                    if (iteratee(index) === false) {
                        return false;
                    }
                }
                return true;
            });
        }
        toArray() {
            const selection = this._selection;
            const result = [];
            this._parent.each((row, index) => {
                if (selection.contains(row)) {
                    result.push([index, row]);
                }
            });
            return result;
        }
        toSortedArray() {
            return this.toArray().sort(COMPARATOR);
        }
        toObject() {
            const selection = this._selection;
            const result = {};
            this._parent.each((row, index) => {
                if (selection.contains(row)) {
                    result[index] = row;
                }
            });
            return result;
        }
        toMap() {
            const selection = this._selection;
            const result = new Map();
            this._parent.each((row, index) => {
                if (selection.contains(row)) {
                    result.set(index, row);
                }
            });
            return result;
        }
    }

    class EEditorTree extends wcardinalUi.DLayoutVertical {
        constructor(options) {
            super(options);
            this._icons = options.icons;
            const diagram = options.diagram;
            this._diagram = diagram;
            this._selection = options.selection;
            this._isInitialized = false;
            this._updatedParts = EToolSelectSelectionUpdatedPart.NONE;
        }
        show() {
            super.show();
            this.onShow();
            return this;
        }
        onShow() {
            if (!this._isInitialized) {
                this._isInitialized = true;
                this.initLayout();
            }
            this.onSelectionChange(EToolSelectSelectionUpdatedPart.NONE);
        }
        initLayout() {
            this.addChild(this.layoutOrder);
            this.addChild(this.table);
            // Selection change event handling
            this._selection.on("change", (parts) => {
                this.onSelectionChange(parts);
            });
            // Layer change even handling
            const onLayerChangeBound = () => {
                this.onLayerChange();
            };
            const diagram = this._diagram;
            const canvas = diagram.canvas;
            if (canvas) {
                this.state.isDisabled = false;
                canvas.layer.on("change", onLayerChangeBound);
            }
            else {
                this.state.isDisabled = true;
            }
            diagram.on("set", (newCanvas) => {
                this.state.isDisabled = false;
                newCanvas.layer.on("change", onLayerChangeBound);
            });
            diagram.on("ready", () => {
                this.onLayerChange();
            });
            diagram.on("unset", (oldCanvas) => {
                this.state.isDisabled = true;
                this.onLayerChange();
                oldCanvas.layer.off("change", onLayerChangeBound);
            });
            this.onLayerChange();
        }
        get layoutOrder() {
            var _a;
            return ((_a = this._layerOrder) !== null && _a !== void 0 ? _a : (this._layerOrder = this.newLayoutOrder()));
        }
        newLayoutOrder() {
            return new wcardinalUi.DLayoutHorizontal({
                width: "padding",
                height: "auto",
                children: [
                    this.newTextLabel(),
                    this.buttonBringToFront,
                    this.buttonBringForward,
                    this.buttonSendBackward,
                    this.buttonSendToBack
                ]
            });
        }
        newTextLabel() {
            return new wcardinalUi.DText({
                weight: 1,
                text: {
                    value: this.theme.getLabel()
                }
            });
        }
        get buttonBringToFront() {
            var _a;
            return ((_a = this._buttonBringToFront) !== null && _a !== void 0 ? _a : (this._buttonBringToFront = this.newButtonBringToFront()));
        }
        newButtonBringToFront() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.arrow_to_top
                },
                title: this.theme.getButtonBringToFrontTitle(),
                on: {
                    active: () => {
                        this._selection.bringToFront();
                    }
                }
            });
        }
        get buttonBringForward() {
            var _a;
            return ((_a = this._buttonBringForward) !== null && _a !== void 0 ? _a : (this._buttonBringForward = this.newButtonBringForward()));
        }
        newButtonBringForward() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.arrow_up
                },
                title: this.theme.getButtonBringForwardTitle(),
                on: {
                    active: () => {
                        this._selection.bringForward();
                    }
                }
            });
        }
        get buttonSendBackward() {
            var _a;
            return ((_a = this._buttonSendBackward) !== null && _a !== void 0 ? _a : (this._buttonSendBackward = this.newButtonSendBackward()));
        }
        newButtonSendBackward() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.arrow_down
                },
                title: this.theme.getButtonSendBackwardTitle(),
                on: {
                    active: () => {
                        this._selection.sendBackward();
                    }
                }
            });
        }
        get buttonSendToBack() {
            var _a;
            return ((_a = this._buttonSendToBack) !== null && _a !== void 0 ? _a : (this._buttonSendToBack = this.newButtonSendToBack()));
        }
        newButtonSendToBack() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.arrow_to_bottom
                },
                title: this.theme.getButtonSendToBackTitle(),
                on: {
                    active: () => {
                        this._selection.sendToBack();
                    }
                }
            });
        }
        onSelectionChange(parts) {
            var _a;
            if (this.isShown()) {
                parts |= this._updatedParts;
                this._updatedParts = EToolSelectSelectionUpdatedPart.NONE;
                if (parts & EToolSelectSelectionUpdatedPart.TREE) {
                    this.table.data.nodes = (_a = this._diagram.layer) === null || _a === void 0 ? void 0 : _a.children;
                }
                else if (parts & EToolSelectSelectionUpdatedPart.SELECTION) {
                    this.table.data.update();
                }
                else if (parts & EToolSelectSelectionUpdatedPart.PROPERTY_ID) {
                    this.table.data.update(true);
                }
                this.layoutOrder.state.isEnabled = wcardinalUi.EShapeCapabilities.contains(this._selection.last(), wcardinalUi.EShapeCapability.ORDER_IN_LAYER);
            }
            else {
                this._updatedParts |= parts;
            }
        }
        onLayerChange() {
            var _a;
            this.table.data.nodes = (_a = this._diagram.layer) === null || _a === void 0 ? void 0 : _a.children;
        }
        get table() {
            var _a;
            return ((_a = this._table) !== null && _a !== void 0 ? _a : (this._table = this.newTable()));
        }
        newTable() {
            return new wcardinalUi.DTable({
                x: "padding",
                width: "padding",
                weight: 1,
                columns: [
                    {
                        type: "TREE",
                        editable: true,
                        getter: (row) => {
                            return toShapeLabel(row);
                        },
                        setter: (row, columnIndex, cell) => {
                            if (row.id !== cell) {
                                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyId(this._selection, cell, [row]));
                            }
                        }
                    }
                ],
                data: new wcardinalUi.DTableDataTree({
                    reverse: true,
                    toChildren: (shape) => {
                        if (wcardinalUi.EShapeCapabilities.contains(shape, wcardinalUi.EShapeCapability.CHILDREN)) {
                            return shape.children;
                        }
                        return null;
                    },
                    selection: (parent) => {
                        return new EEditorTreeSelection(parent, this._selection);
                    }
                }),
                on: {
                    keydown: (e) => {
                        if (wcardinalUi.UtilKeyboardEvent.isDeleteKey(e)) {
                            this._selection.delete();
                            e.preventDefault();
                        }
                    }
                }
            });
        }
        getType() {
            return "EEditorTree";
        }
    }

    class EEditorValidation extends wcardinalUi.DLayoutVertical {
        constructor(options) {
            super(options);
            // Selection
            const selection = options.selection;
            this._selection = selection;
            // Icons
            this._icons = options.icons;
            // Verifier
            this._validator = options.validator;
            // Diagram
            const diagram = options.diagram;
            this._diagram = diagram;
            this.state.isDisabled = diagram.canvas == null;
            diagram.on("unset", () => {
                this.list.data.clear();
                this.state.isDisabled = true;
            });
            diagram.on("set", () => {
                this.state.isDisabled = false;
            });
            // Layout
            this.addChild(new wcardinalUi.DLayoutHorizontal({
                x: "padding",
                width: "padding",
                height: "auto",
                children: [this.newTextLabel(), this.buttonRevalidate]
            }));
            this.addChild(this.list);
        }
        newTextLabel() {
            return new wcardinalUi.DText({
                weight: 1,
                text: {
                    value: this.theme.getLabel()
                }
            });
        }
        get buttonRevalidate() {
            let result = this._buttonRevalidate;
            if (result == null) {
                result = this.newButtonRevalidate();
                this._buttonRevalidate = result;
            }
            return result;
        }
        newButtonRevalidate() {
            return new wcardinalUi.DButtonAmbient({
                width: 30,
                image: {
                    source: this._icons.refresh
                },
                title: this.theme.getButtonRevalidateTitle(),
                on: {
                    active: (emitter) => {
                        this.onButtonValidateActive(emitter);
                    }
                }
            });
        }
        onButtonValidateActive(opener) {
            const validator = this._validator;
            if (validator != null) {
                const canvas = this._diagram.canvas;
                if (canvas != null) {
                    const dialogProcessing = this.dialogProcessing;
                    dialogProcessing.open(opener);
                    const data = this.list.data;
                    try {
                        const result = validator(canvas);
                        if (wcardinalUi.isArray(result)) {
                            data.clearAndAddAll(result);
                            dialogProcessing.resolve();
                        }
                        else {
                            result.then((results) => {
                                data.clearAndAddAll(results);
                                dialogProcessing.resolve();
                            }, () => {
                                data.clear();
                                dialogProcessing.reject();
                            });
                        }
                    }
                    catch (_a) {
                        data.clear();
                        dialogProcessing.reject();
                    }
                }
            }
        }
        get list() {
            let result = this._list;
            if (result == null) {
                result = this.newList();
                this._list = result;
            }
            return result;
        }
        newList() {
            const result = new wcardinalUi.DList({
                width: "padding",
                weight: 1,
                data: {
                    toLabel: (value) => {
                        return value.message;
                    }
                },
                updater: {
                    newItem: (data) => {
                        return new wcardinalUi.DListItem(data, {
                            on: {
                                select: (value, item) => {
                                    this.onListItemDown(value, item);
                                }
                            }
                        });
                    }
                }
            });
            return result;
        }
        onListItemDown(value, item) {
            const shape = value.shape;
            if (shape != null) {
                const canvas = this._diagram.canvas;
                const layer = shape.root.parent;
                if (canvas != null && layer != null) {
                    // Selection
                    const selection = this._selection;
                    const before = selection.store();
                    if (selection.set(shape)) {
                        selection.focus();
                        const after = selection.store();
                        wcardinalUi.DControllers.getCommandController().push(new ECommandShapeSelect(before, after, selection));
                    }
                    else {
                        selection.focus();
                    }
                    // Change the active layer
                    const layerActive = canvas.layer.active;
                    if (layerActive !== layer) {
                        canvas.layer.active = layer;
                    }
                }
                else {
                    this.dialogError.open(item);
                }
            }
        }
        get dialogError() {
            let result = this._dialogError;
            if (result == null) {
                result = this.newDialogError();
                this._dialogError = result;
            }
            return result;
        }
        newDialogError() {
            return new wcardinalUi.DDialogMessage({
                message: "No shapes found."
            });
        }
        get dialogProcessing() {
            let result = this._dialogProcessing;
            if (result == null) {
                result = this.newDialogProcessing();
                this._dialogProcessing = result;
            }
            return result;
        }
        newDialogProcessing() {
            return new wcardinalUi.DDialogProcessing({
                footer: {
                    button: {
                        ok: "OK",
                        cancel: null
                    }
                }
            });
        }
        getType() {
            return "EEditorValidation";
        }
    }

    class EToolGroupImpl {
        constructor() {
            this._isSuspended = false;
            this._active = null;
            this._activeParameter = null;
        }
        activate(target, parameter) {
            const oldActive = this._active;
            const oldActiveParameter = this._activeParameter;
            if (oldActive !== target || oldActiveParameter !== parameter) {
                this._activeParameter = parameter;
                if (oldActive !== target) {
                    if (oldActive) {
                        oldActive.deactivate();
                    }
                    this._active = target;
                    if (!this._isSuspended) {
                        target.activate();
                    }
                }
            }
        }
        deactivate(target, parameter) {
            if (this._active === target && this._activeParameter === parameter) {
                this._active = null;
                this._activeParameter = null;
                target.deactivate();
            }
        }
        suspend() {
            if (!this._isSuspended) {
                this._isSuspended = true;
                const active = this._active;
                if (active) {
                    active.deactivate();
                }
            }
        }
        resume() {
            if (this._isSuspended) {
                this._isSuspended = false;
                const active = this._active;
                if (active) {
                    active.activate();
                }
            }
        }
        isSuspended() {
            return this._isSuspended;
        }
    }

    class EToolImpl extends pixi_js.utils.EventEmitter {
        constructor() {
            super();
            this._isActive = false;
        }
        activate() {
            if (!this._isActive) {
                this._isActive = true;
                this.onActivate();
            }
        }
        deactivate() {
            if (this._isActive) {
                this._isActive = false;
                this.onDeactivate();
            }
        }
        onActivate() {
            // DO NOTHING
        }
        onDeactivate() {
            // DO NOTHING
        }
        isActive() {
            return this._isActive;
        }
    }

    const FILL_COLOR = 0x1e87f0;
    const FILL_ALPHA = 0.5;
    class EToolSelectArea extends pixi_js.Graphics {
        constructor() {
            super();
            this._size = new pixi_js.Point();
        }
        get size() {
            return this._size;
        }
        update() {
            this.clear();
            const size = this._size;
            const x = Math.min(0, size.x);
            const y = Math.min(0, size.y);
            const width = Math.abs(size.x);
            const height = Math.abs(size.y);
            this.beginFill(FILL_COLOR, FILL_ALPHA);
            this.drawRect(x, y, width, height);
            this.endFill();
        }
    }

    var EToolSelectMode;
    (function (EToolSelectMode) {
        EToolSelectMode[EToolSelectMode["NONE"] = 0] = "NONE";
        EToolSelectMode[EToolSelectMode["SELECT"] = 1] = "SELECT";
        EToolSelectMode[EToolSelectMode["TRANSLATE"] = 2] = "TRANSLATE";
        EToolSelectMode[EToolSelectMode["SCALE"] = 3] = "SCALE";
        EToolSelectMode[EToolSelectMode["ROTATE"] = 4] = "ROTATE";
    })(EToolSelectMode || (EToolSelectMode = {}));

    class EToolSelectModifierContainer extends pixi_js.Container {
    }

    class EToolSelectModifierHitArea extends pixi_js.Rectangle {
        constructor(modifier) {
            super();
            this._modifier = modifier;
        }
        contains(x, y) {
            const modifier = this._modifier;
            const s = modifier.getAnchorSize() * 2;
            const t = s * 0.5;
            const w = modifier.width;
            const h = modifier.height;
            const p = w * 0.5;
            const q = h * 0.5;
            const d = modifier.getAnchorRotationDistance();
            const r = modifier.getAnchorRotationSize() * 2;
            // Top left
            if (0 - t <= x && 0 - t <= y && x <= 0 - t + s && y <= 0 - t + s) {
                modifier.setLastHitAnchor(wcardinalUi.ESnapperModifierAnchor.TOP_LEFT);
                return true;
            }
            // Top right
            if (w - t <= x && 0 - t <= y && x <= w - t + s && y <= 0 - t + s) {
                modifier.setLastHitAnchor(wcardinalUi.ESnapperModifierAnchor.TOP_RIGHT);
                return true;
            }
            // Bottom left
            if (0 - t <= x && h - t <= y && x <= 0 - t + s && y <= h - t + s) {
                modifier.setLastHitAnchor(wcardinalUi.ESnapperModifierAnchor.BOTTOM_LEFT);
                return true;
            }
            // Bottom right
            if (w - t <= x && h - t <= y && x <= w - t + s && y <= h - t + s) {
                modifier.setLastHitAnchor(wcardinalUi.ESnapperModifierAnchor.BOTTOM_RIGHT);
                return true;
            }
            // Top Center
            if (p - t <= x && 0 - t <= y && x <= p - t + s && y <= 0 - t + s) {
                modifier.setLastHitAnchor(wcardinalUi.ESnapperModifierAnchor.TOP_CENTER);
                return true;
            }
            // Middle Right
            if (w - t <= x && q - t <= y && x <= w - t + s && y <= q - t + s) {
                modifier.setLastHitAnchor(wcardinalUi.ESnapperModifierAnchor.MIDDLE_RIGHT);
                return true;
            }
            // Bottom Center
            if (p - t <= x && h - t <= y && x <= p - t + s && y <= h - t + s) {
                modifier.setLastHitAnchor(wcardinalUi.ESnapperModifierAnchor.BOTTOM_CENTER);
                return true;
            }
            // Middle Left
            if (0 - t <= x && q - t <= y && x <= 0 - t + s && y <= q - t + s) {
                modifier.setLastHitAnchor(wcardinalUi.ESnapperModifierAnchor.MIDDLE_LEFT);
                return true;
            }
            // Rotate
            if (p - r <= x && d - r <= y && x <= p + r && y <= d + r) {
                modifier.setLastHitAnchor(wcardinalUi.ESnapperModifierAnchor.ROTATION);
                return true;
            }
            return false;
        }
    }

    class EToolSelectModifier extends wcardinalUi.EShapeContainer {
        constructor(options) {
            super();
            this.selected = false;
            this.index = 0;
            this._width = 0;
            this._height = 0;
            this._scaleBound = 1;
            this._scaleBoundInverse = 1;
            this._isAllowed = true;
            this._lastHitAnchor = wcardinalUi.ESnapperModifierAnchor.NONE;
            if (options == null || options.editable !== false) {
                this.cursor = "grab";
                this.interactive = true;
                this.hitArea = new EToolSelectModifierHitArea(this);
            }
            else {
                this.interactive = false;
            }
            this.group = false;
            this._anchorBase = new wcardinalUi.EShapeRectangle().attach(this);
            this._anchorsScale = [
                new wcardinalUi.EShapeRectangle().attach(this),
                new wcardinalUi.EShapeRectangle().attach(this),
                new wcardinalUi.EShapeRectangle().attach(this),
                new wcardinalUi.EShapeRectangle().attach(this),
                new wcardinalUi.EShapeRectangle().attach(this),
                new wcardinalUi.EShapeRectangle().attach(this),
                new wcardinalUi.EShapeRectangle().attach(this),
                new wcardinalUi.EShapeRectangle().attach(this)
            ];
            this._anchorRotate = new wcardinalUi.EShapeCircle().attach(this);
        }
        onPrerender() {
            const scale0 = this.getParentScale();
            const scale1 = this._scaleBound;
            if (0.001 < Math.abs(scale0 - scale1)) {
                this._scaleBound = scale0;
                this._scaleBoundInverse = 1 / scale0;
                this.update();
            }
        }
        render(renderer) {
            if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
                return;
            }
            this.onPrerender();
            super.render(renderer);
        }
        getParentScale() {
            const parent = this.parent;
            if (parent != null) {
                const parentParent = parent.parent;
                if (parentParent != null) {
                    return parentParent.scale.y;
                }
            }
            return 1;
        }
        get factor() {
            return this._scaleBoundInverse;
        }
        get width() {
            return this._width;
        }
        set width(width) {
            this._width = width;
        }
        get height() {
            return this._height;
        }
        set height(height) {
            this._height = height;
        }
        getLastHitAnchor() {
            return this._lastHitAnchor;
        }
        setLastHitAnchor(anchor) {
            const result = this._lastHitAnchor;
            this._lastHitAnchor = anchor;
            return result;
        }
        getAnchorSize() {
            return 7 * this._scaleBoundInverse;
        }
        getAnchorRotationDistance() {
            return (0 <= this._height ? -18 : +18) * this._scaleBoundInverse;
        }
        getAnchorRotationSize() {
            return 5 * this._scaleBoundInverse;
        }
        update() {
            const color = this.group ? 0x1ef087 : 0x1e87f0;
            const width = this._width;
            const height = this._height;
            const scaleInverse = this._scaleBoundInverse;
            const s = this.getAnchorSize();
            const w = width;
            const h = height;
            const p = w * 0.5;
            const q = h * 0.5;
            const d = this.getAnchorRotationDistance();
            const r = 2 * this.getAnchorRotationSize();
            const l = 2 * scaleInverse;
            const o = 1.5 * l;
            // Anchor base
            const anchorBase = this._anchorBase;
            anchorBase.lock(wcardinalUi.EShapeLockPart.UPLOADED);
            anchorBase.fill.enable = false;
            anchorBase.stroke.set(true, color, 0.333, l, 2);
            anchorBase.transform.position.set(width * 0.5, height * 0.5);
            anchorBase.size.set(width, height);
            anchorBase.unlock(wcardinalUi.EShapeLockPart.UPLOADED, true);
            // Anchor for rotation
            const anchorRotate = this._anchorRotate;
            anchorRotate.lock(wcardinalUi.EShapeLockPart.UPLOADED);
            anchorRotate.stroke.enable = false;
            anchorRotate.fill.set(true, color, 1.0);
            anchorRotate.size.set(r, r);
            anchorRotate.transform.position.set(p, d);
            anchorRotate.unlock(wcardinalUi.EShapeLockPart.UPLOADED, true);
            // Anchor for scaling
            const anchorsScale = this._anchorsScale;
            for (let i = 0, imax = anchorsScale.length; i < imax; ++i) {
                const anchorScale = anchorsScale[i];
                anchorScale.lock(wcardinalUi.EShapeLockPart.UPLOADED);
                anchorScale.stroke.enable = false;
                anchorScale.fill.set(true, color, 1.0);
                anchorScale.size.set(s, s);
            }
            anchorsScale[0].transform.position.set(-o, -o);
            anchorsScale[1].transform.position.set(+o + w, -o);
            anchorsScale[2].transform.position.set(-o, +o + h);
            anchorsScale[3].transform.position.set(+o + w, +o + h);
            anchorsScale[4].transform.position.set(p, -o);
            anchorsScale[5].transform.position.set(+o + w, q);
            anchorsScale[6].transform.position.set(p, +o + h);
            anchorsScale[7].transform.position.set(-o, q);
            for (let i = 0, imax = anchorsScale.length; i < imax; ++i) {
                anchorsScale[i].unlock(wcardinalUi.EShapeLockPart.UPLOADED, true);
            }
        }
        allow() {
            this._isAllowed = true;
        }
        isAllowed() {
            return this._isAllowed;
        }
        disallow() {
            this._isAllowed = false;
        }
        destroy() {
            const parent = this.parent;
            if (parent) {
                parent.removeChild(this);
            }
        }
    }

    /*
     * Copyright (C) 2019 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    class UtilShapeConnectorTransformData extends wcardinalUi.EShapeEditor {
        constructor() {
            super();
            this.tailVector = new pixi_js.Point();
            this.headVector = new pixi_js.Point();
        }
    }
    class UtilShapeConnectorTransforms {
        static prepare(connector) {
            let editor = null;
            if (connector.editor instanceof UtilShapeConnectorTransformData) {
                editor = connector.editor;
            }
            else {
                editor = new UtilShapeConnectorTransformData();
                connector.editor = editor;
            }
            // Edges
            const tailVector = editor.tailVector;
            const headVector = editor.headVector;
            const edge = connector.edge;
            edge.tail.local.copyTo(tailVector);
            edge.head.local.copyTo(headVector);
            const localTransform = connector.transform.localTransform;
            localTransform.applyInverse(tailVector, tailVector);
            localTransform.applyInverse(headVector, headVector);
            // Other preparations
            UtilShapeTransforms.prepare(connector);
        }
        static finalize(connector) {
            UtilShapeTransforms.finalize(connector);
        }
        static apply(connector, transform) {
            const editor = connector.editor;
            if (editor instanceof UtilShapeConnectorTransformData) {
                const localTransform = editor.localTransform;
                editor.internalTransformParentInverse
                    .copyTo(localTransform)
                    .append(transform)
                    .append(editor.internalTransform);
                const a = localTransform.a;
                const b = localTransform.b;
                const c = localTransform.c;
                const d = localTransform.d;
                const tx = localTransform.tx;
                const ty = localTransform.ty;
                const edge = connector.edge;
                const tail = edge.tail;
                const head = edge.head;
                const editorTailVector = editor.tailVector;
                const editorTailVectorX = editorTailVector.x;
                const editorTailVectorY = editorTailVector.y;
                const newTailLocalX = a * editorTailVectorX + c * editorTailVectorY + tx;
                const newTailLocalY = b * editorTailVectorX + d * editorTailVectorY + ty;
                const editorHeadVector = editor.headVector;
                const editorHeadVectorX = editorHeadVector.x;
                const editorHeadVectorY = editorHeadVector.y;
                const newHeadLocalX = a * editorHeadVectorX + c * editorHeadVectorY + tx;
                const newHeadLocalY = b * editorHeadVectorX + d * editorHeadVectorY + ty;
                edge.lock();
                tail.local.set(newTailLocalX, newTailLocalY);
                head.local.set(newHeadLocalX, newHeadLocalY);
                edge.unlock();
            }
        }
    }

    class ECommandShapePropertyLineStyle extends ECommandShapePropertyStrokeStyle {
        toCapability(shape) {
            if (wcardinalUi.EShapeCapabilities.contains(shape, wcardinalUi.EShapeCapability.LINE)) {
                return wcardinalUi.EShapeCapability.LINE;
            }
            return wcardinalUi.EShapeCapability.NONE;
        }
    }

    const initLeft = (rect) => {
        return rect.x;
    };
    const initCenter = (rect) => {
        return rect.x + rect.width * 0.5;
    };
    const initRight = (rect) => {
        return rect.x + rect.width;
    };
    const initTop = (rect) => {
        return rect.y;
    };
    const initMiddle = (rect) => {
        return rect.y + rect.height * 0.5;
    };
    const initBottom = (rect) => {
        return rect.y + rect.height;
    };
    const initWidth = (rect) => {
        return rect.width;
    };
    const initHeight = (rect) => {
        return rect.height;
    };
    const initZero = (rect) => {
        return 0;
    };
    const updateMin = (valueA, valueB) => {
        return Math.min(valueA, valueB);
    };
    const updateMax = (valueA, valueB) => {
        return Math.max(valueA, valueB);
    };
    const updateSum = (valueA, valueB) => {
        return valueA + valueB;
    };
    const finishupIdentity = (value, size) => {
        return value;
    };
    const finishupAverage = (value, size) => {
        return value / size;
    };
    const assingX = (value, point) => {
        point.x = value;
    };
    const assingY = (value, point) => {
        point.y = value;
    };
    const applyLeft = (point, diff, scale, shape) => {
        shape.transform.position.x = point.x + diff / scale.x;
    };
    const applyCenter = (point, diff, scale, shape) => {
        shape.transform.position.x = point.x;
    };
    const applyRight = (point, diff, scale, shape) => {
        shape.transform.position.x = point.x - diff / scale.x;
    };
    const applyTop = (point, diff, scale, shape) => {
        shape.transform.position.y = point.y + diff / scale.y;
    };
    const applyMiddle = (point, diff, scale, shape) => {
        shape.transform.position.y = point.y;
    };
    const applyBottom = (point, diff, scale, shape) => {
        shape.transform.position.y = point.y - diff / scale.y;
    };
    class EToolSelectSelection extends pixi_js.utils.EventEmitter {
        constructor(options) {
            super();
            const diagram = options.diagram;
            this._diagram = diagram;
            const modifier = new EToolSelectModifier(options.modifier);
            this._modifier = modifier;
            const modifierContainer = new EToolSelectModifierContainer();
            modifierContainer.addChild(modifier);
            diagram.on("unset", (canvas) => {
                if (modifierContainer.parent === canvas) {
                    // Because after this event, a canvas is destroyed.
                    // At that time, all its children also be destroyed.
                    // The modifier container therefore should be removed.
                    canvas.removeChild(modifierContainer);
                }
            });
            this._modifierContainer = modifierContainer;
            this._originGlobal = new pixi_js.Point();
            this._originLocal = new pixi_js.Point();
            this._rotationAxisGlobal = new pixi_js.Point();
            this._scale = new pixi_js.Point();
            this._scaleAxis0 = new pixi_js.Point();
            this._scaleAxis1 = new pixi_js.Point();
            this._scaleDet = 1;
            this._scaleDetInverse = 1;
            this._scaleTransform = new pixi_js.Matrix();
            this._scaleTransformInverse = new pixi_js.Matrix();
            this._scaleAnchor = wcardinalUi.ESnapperModifierAnchor.NONE;
            this._shapes = [];
            this._shapeBound = new pixi_js.Rectangle();
            this._shapeBoundRect = new pixi_js.Rectangle();
            this._alignPoint = new pixi_js.Point();
            this._alignRectangle = new pixi_js.Rectangle();
            this._shiftPoint1 = new pixi_js.Point();
            this._shiftPoint2 = new pixi_js.Point();
            this._transform = new pixi_js.Matrix();
            this._translateDelta = new pixi_js.Point();
            this._isUpdated = false;
            this._updatedParts = EToolSelectSelectionUpdatedPart.NONE;
            this._lockCount = 0;
        }
        lock() {
            this._lockCount += 1;
            if (this._lockCount === 1) {
                this._isUpdated = false;
                this._updatedParts = EToolSelectSelectionUpdatedPart.NONE;
            }
        }
        unlock() {
            this._lockCount -= 1;
            if (this._lockCount === 0) {
                if (this._isUpdated) {
                    this.update(this._updatedParts);
                }
            }
        }
        update(parts) {
            let parsed = EToolSelectSelectionUpdatedPart.ALL;
            if (parts != null) {
                if (wcardinalUi.isNumber(parts)) {
                    parsed = parts;
                }
                else {
                    // eslint-disable-next-line prefer-rest-params
                    parsed = this.toParts(arguments);
                }
            }
            if (this._lockCount <= 0) {
                this.updateModifier();
                this.emit("change", parsed, this);
            }
            else {
                this._isUpdated = true;
                this._updatedParts |= parsed;
            }
        }
        toParts(parts) {
            if (wcardinalUi.isNumber(parts)) {
                return parts;
            }
            let result = EToolSelectSelectionUpdatedPart.NONE;
            for (let i = 0, imax = parts.length; i < imax; ++i) {
                result |= EToolSelectSelectionUpdatedPart[parts[i]];
            }
            return result;
        }
        updateModifier() {
            const diagram = this._diagram;
            const modifier = this._modifier;
            if (modifier.isAllowed()) {
                const shapes = this._shapes;
                const canvas = diagram.canvas;
                const modifierContainer = this._modifierContainer;
                if (canvas == null || shapes.length <= 0) {
                    modifier.visible = false;
                    wcardinalUi.DApplications.update(diagram);
                }
                else if (shapes.length <= 1) {
                    const shape = shapes[0];
                    if (shape.parent instanceof wcardinalUi.EShapeBase) {
                        shape.updateTransform();
                        const internalTransform = shape.transform.internalTransform;
                        const a = internalTransform.a;
                        const b = internalTransform.b;
                        const c = internalTransform.c;
                        const d = internalTransform.d;
                        const pivot = shape.transform.pivot;
                        const modifierPosition = modifier.position;
                        modifierPosition.set(a * pivot.x + c * pivot.y + internalTransform.tx, b * pivot.x + d * pivot.y + internalTransform.ty);
                        const layer = shape.root.parent;
                        if (layer) {
                            modifierContainer.transform.position.copyFrom(layer.transform.position);
                        }
                        else {
                            modifierContainer.transform.position.set(0, 0);
                        }
                        const width = shape.size.x * Math.sqrt(a * a + b * b);
                        const height = shape.size.y * Math.sqrt(c * c + d * d);
                        modifier.width = width;
                        modifier.height = height;
                        modifier.pivot.set(width * 0.5, height * 0.5);
                        const rx = Math.atan2(-c, d);
                        const ry = Math.atan2(+b, a);
                        const skew = (ry - rx) * 0.5;
                        const rotation = (rx + ry) * 0.5;
                        modifier.rotation = rotation;
                        modifier.skew.set(skew, skew);
                    }
                    else {
                        shape.updateTransform();
                        const internalTransform = shape.transform.internalTransform;
                        const a = internalTransform.a;
                        const b = internalTransform.b;
                        const c = internalTransform.c;
                        const d = internalTransform.d;
                        const pivot = shape.transform.pivot;
                        const modifierPosition = modifier.position;
                        modifierPosition.set(a * pivot.x + c * pivot.y + internalTransform.tx, b * pivot.x + d * pivot.y + internalTransform.ty);
                        const layer = shape.root.parent;
                        if (layer) {
                            modifierContainer.transform.position.copyFrom(layer.transform.position);
                        }
                        else {
                            modifierContainer.transform.position.set(0, 0);
                        }
                        modifier.width = shape.size.x;
                        modifier.height = shape.size.y;
                        modifier.pivot.set(shape.size.x * 0.5, shape.size.y * 0.5);
                        modifier.rotation = shape.transform.rotation;
                        modifier.skew.copyFrom(shape.transform.skew);
                    }
                    modifier.visible = true;
                    modifier.group =
                        wcardinalUi.EShapeCapabilities.contains(shape, wcardinalUi.EShapeCapability.CHILDREN) &&
                            0 < shape.children.length;
                    if (modifierContainer.parent !== canvas) {
                        canvas.addChild(modifierContainer);
                    }
                    modifier.update();
                    wcardinalUi.DApplications.update(diagram);
                }
                else {
                    const bound = this._shapeBound;
                    const tempRect = this._shapeBoundRect;
                    shapes[0].getBoundsInternal(false, bound);
                    for (let i = 1, imax = shapes.length; i < imax; ++i) {
                        const shape = shapes[i];
                        shape.getBoundsInternal(false, tempRect);
                        bound.enlarge(tempRect);
                    }
                    const layer = shapes[0].root.parent;
                    if (layer) {
                        modifierContainer.transform.position.copyFrom(layer.transform.position);
                    }
                    else {
                        modifierContainer.transform.position.set(0, 0);
                    }
                    modifier.position.set(bound.x, bound.y);
                    modifier.width = bound.width;
                    modifier.height = bound.height;
                    modifier.rotation = 0;
                    modifier.pivot.set(0, 0);
                    modifier.skew.set(0, 0);
                    modifier.visible = true;
                    modifier.group = false;
                    if (modifierContainer.parent !== canvas) {
                        canvas.addChild(modifierContainer);
                    }
                    modifier.update();
                    wcardinalUi.DApplications.update(diagram);
                }
            }
            else {
                modifier.visible = false;
                wcardinalUi.DApplications.update(diagram);
            }
        }
        toggle(shape) {
            const shapes = this._shapes;
            if (shapes.length <= 0) {
                const root = shape.root;
                root.selected = true;
                shapes.push(root);
            }
            else {
                const first = shapes[0];
                if (UtilShapeSearch.isParent(shape, first)) {
                    first.selected = false;
                    if (wcardinalUi.EShapeCapabilities.contains(first, wcardinalUi.EShapeCapability.CHILDREN)) {
                        const shapeOfParent = UtilShapeSearch.toOfParent(shape, first);
                        shapeOfParent.selected = true;
                        shapes[0] = shapeOfParent;
                    }
                    else {
                        shapes.splice(0, 1);
                    }
                }
                else if (first.parent === shape.parent) {
                    if (!shape.selected) {
                        shape.selected = true;
                        shapes.push(shape);
                    }
                    else {
                        shape.selected = false;
                        shapes.splice(shapes.indexOf(shape), 1);
                    }
                }
                else {
                    const sharedParent = UtilShapeSearch.toSharedParent(first, shape);
                    if (first.parent === sharedParent) {
                        const shapeOfParent = UtilShapeSearch.toOfParent(shape, sharedParent);
                        if (shapeOfParent.selected) {
                            shapeOfParent.selected = false;
                            shapes.splice(shapes.indexOf(shapeOfParent), 1);
                        }
                        else {
                            shapeOfParent.selected = true;
                            shapes.push(shapeOfParent);
                        }
                    }
                    else {
                        let newLength = 0;
                        for (let i = 0, imax = shapes.length; i < imax; ++i) {
                            const oldShape = shapes[i];
                            oldShape.selected = false;
                            const newShape = UtilShapeSearch.toOfParent(oldShape, sharedParent);
                            if (!newShape.selected) {
                                newShape.selected = true;
                                shapes[newLength] = newShape;
                                newLength += 1;
                            }
                        }
                        shapes.length = newLength;
                        const shapeOfParent = UtilShapeSearch.toOfParent(shape, sharedParent);
                        if (!shapeOfParent.selected) {
                            shapeOfParent.selected = true;
                            shapes.push(shapeOfParent);
                        }
                    }
                }
            }
            this.update(EToolSelectSelectionUpdatedPart.SELECTION);
        }
        /**
         * Please note that the specified targets must be root shapes.
         *
         * @param targets root shapes to be added
         */
        addAll(targets) {
            const shapes = this._shapes;
            let isChanged = false;
            // Convert to root shapes
            if (0 < shapes.length) {
                const first = shapes[0];
                if (first.root !== first) {
                    const oldShapes = shapes.slice(0);
                    shapes.length = 0;
                    for (let i = 0, imax = oldShapes.length; i < imax; ++i) {
                        const oldShape = oldShapes[i];
                        oldShape.selected = false;
                        const oldShapeRoot = oldShape.root;
                        if (!oldShapeRoot.selected) {
                            oldShapeRoot.selected = true;
                            shapes.push(oldShapeRoot);
                        }
                    }
                    isChanged = true;
                }
            }
            // Add targets
            for (let i = 0, imax = targets.length; i < imax; ++i) {
                const target = targets[i];
                if (!target.selected) {
                    target.selected = true;
                    shapes.push(target);
                    isChanged = true;
                }
            }
            if (isChanged) {
                this.update(EToolSelectSelectionUpdatedPart.SELECTION);
            }
            return isChanged;
        }
        clearAndAddAll(targets) {
            const shapes = this._shapes;
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                shapes[i].selected = false;
            }
            shapes.length = 0;
            for (let i = 0, imax = targets.length; i < imax; ++i) {
                const target = targets[i];
                target.selected = true;
                shapes.push(target);
            }
            this.update(EToolSelectSelectionUpdatedPart.SELECTION);
            return true;
        }
        set(target) {
            const shapes = this._shapes;
            if (1 < shapes.length) {
                for (let i = 0, imax = shapes.length; i < imax; ++i) {
                    shapes[i].selected = false;
                }
                shapes.length = 0;
                target.selected = true;
                shapes.push(target);
                this.update(EToolSelectSelectionUpdatedPart.SELECTION);
                return true;
            }
            else if (shapes.length === 1) {
                if (shapes[0] === target) {
                    return false;
                }
                else {
                    shapes[0].selected = false;
                    target.selected = true;
                    shapes[0] = target;
                    this.update(EToolSelectSelectionUpdatedPart.SELECTION);
                    return true;
                }
            }
            else {
                target.selected = true;
                shapes.push(target);
                this.update(EToolSelectSelectionUpdatedPart.SELECTION);
                return true;
            }
        }
        get() {
            return this._shapes;
        }
        first() {
            const shapes = this._shapes;
            return 0 < shapes.length ? shapes[0] : null;
        }
        last() {
            const shapes = this._shapes;
            return 0 < shapes.length ? shapes[shapes.length - 1] : null;
        }
        swapLast(expectedLast, newLast) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                const last = shapes[shapes.length - 1];
                if (last === expectedLast) {
                    last.selected = false;
                    shapes[shapes.length - 1] = newLast;
                    newLast.selected = true;
                    this.update(EToolSelectSelectionUpdatedPart.TREE | EToolSelectSelectionUpdatedPart.SELECTION);
                }
            }
        }
        remove(target) {
            const shapes = this._shapes;
            const index = shapes.indexOf(target);
            if (0 <= index) {
                target.selected = false;
                shapes.splice(index, 1);
                this.update(EToolSelectSelectionUpdatedPart.TREE | EToolSelectSelectionUpdatedPart.SELECTION);
            }
        }
        contains(shape) {
            return shape.selected;
        }
        size() {
            return this._shapes.length;
        }
        isEmpty() {
            return this._shapes.length <= 0;
        }
        clear() {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                for (let i = 0, imax = shapes.length; i < imax; ++i) {
                    shapes[i].selected = false;
                }
                this._shapes.length = 0;
                this.update(EToolSelectSelectionUpdatedPart.SELECTION);
                return true;
            }
            return false;
        }
        focus() {
            if (this.isEmpty()) {
                return false;
            }
            // Canvas
            const diagram = this._diagram;
            const canvas = diagram.canvas;
            if (canvas == null) {
                return false;
            }
            // Canvas parent
            const cparent = canvas.parent;
            if (!(cparent instanceof wcardinalUi.DBase)) {
                return false;
            }
            // Center
            const cw = canvas.width;
            const ch = canvas.height;
            const p = cparent.padding;
            const pl = p.getLeft();
            const pt = p.getTop();
            const pr = p.getRight();
            const pb = p.getBottom();
            const sw = Math.max(0, cparent.width - pl - pr);
            const sh = Math.max(0, cparent.height - pt - pb);
            const cx = pl + (sw - cw) * 0.5;
            const cy = pt + (sh - ch) * 0.5;
            // Offset
            const modifier = this._modifier;
            const point = this._alignPoint;
            point.set(modifier.width * 0.5, modifier.height * 0.5);
            modifier.toGlobal(point, point, false);
            cparent.toLocal(point, undefined, point, false);
            const cposition = canvas.position;
            const ox = cw * 0.5 - (point.x - cposition.x);
            const oy = ch * 0.5 - (point.y - cposition.y);
            // Move
            diagram.view.moveTo(cx + ox, cy + oy);
            return true;
        }
        prepare() {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                for (let i = 0, imax = shapes.length; i < imax; ++i) {
                    const shape = shapes[i];
                    if (shape instanceof wcardinalUi.EShapeConnectorLine) {
                        UtilShapeConnectorTransforms.prepare(shape);
                    }
                    else {
                        UtilShapeTransforms.prepare(shape);
                    }
                }
                return true;
            }
            return false;
        }
        prepareTranslateSnap() {
            const diagram = this._diagram;
            if (diagram instanceof wcardinalUi.DDiagramEditor) {
                diagram.snapper.prepareForTranslate(this._modifier);
            }
        }
        prepareRotateSnap() {
            const diagram = this._diagram;
            if (diagram instanceof wcardinalUi.DDiagramEditor) {
                diagram.snapper.prepareForRotate(this._modifier);
            }
        }
        prepareScaleSnap() {
            const diagram = this._diagram;
            if (diagram instanceof wcardinalUi.DDiagramEditor) {
                diagram.snapper.prepareForScale(this._modifier, this._scaleAnchor);
            }
        }
        prepareTranslate() {
            return this.prepare();
        }
        prepareRotate(global) {
            if (this.prepare()) {
                // Origin
                const originGlobal = this._originGlobal;
                const originLocal = this._originLocal;
                const modifier = this._modifier;
                originLocal.set(modifier.width * 0.5, modifier.height * 0.5);
                originGlobal.copyFrom(originLocal);
                modifier.updateTransform();
                modifier.transform.localTransform.apply(originLocal, originLocal);
                modifier.transform.worldTransform.apply(originGlobal, originGlobal);
                // Axis
                if (global == null) {
                    return true;
                }
                else {
                    const rotationAxisGlobal = this._rotationAxisGlobal;
                    const vx = global.x - originGlobal.x;
                    const vy = global.y - originGlobal.y;
                    const v = Math.sqrt(vx * vx + vy * vy);
                    if (0.001 < v) {
                        const vi = 1 / v;
                        rotationAxisGlobal.set(vx * vi, vy * vi);
                        return true;
                    }
                    else {
                        this.finalize();
                        return false;
                    }
                }
            }
            return false;
        }
        prepareScale(anchor) {
            if (this.prepare()) {
                if (this.prepareScaleOriginAndAxes(anchor)) {
                    const modifier = this._modifier;
                    const rotation = modifier.rotation;
                    const skew = modifier.skew;
                    const originLocal = this._originLocal;
                    const scaleTransform = this._scaleTransform;
                    scaleTransform.setTransform(0, 0, 0, 0, 1, 1, rotation, skew.x, skew.y).invert();
                    scaleTransform.apply(originLocal, originLocal);
                    scaleTransform.translate(-originLocal.x, -originLocal.y);
                    scaleTransform.copyTo(this._scaleTransformInverse).invert();
                    return true;
                }
                else {
                    this.finalize();
                    return false;
                }
            }
            return false;
        }
        prepareScaleOriginAndAxes(anchor) {
            const modifier = this._modifier;
            modifier.updateTransform();
            const localTransform = modifier.transform.localTransform;
            const worldTransform = modifier.transform.worldTransform;
            const width = modifier.width;
            const height = modifier.height;
            const originGlobal = this._originGlobal;
            const originLocal = this._originLocal;
            this._scaleAnchor = anchor;
            switch (anchor) {
                case wcardinalUi.ESnapperModifierAnchor.TOP_LEFT:
                    originLocal.set(width, height);
                    originGlobal.copyFrom(originLocal);
                    localTransform.apply(originLocal, originLocal);
                    worldTransform.apply(originGlobal, originGlobal);
                    return this.prepareScaleAxes(0, height, width, 0, originGlobal);
                case wcardinalUi.ESnapperModifierAnchor.TOP_CENTER:
                    originLocal.set(width * 0.5, height);
                    originGlobal.copyFrom(originLocal);
                    localTransform.apply(originLocal, originLocal);
                    worldTransform.apply(originGlobal, originGlobal);
                    return this.prepareScaleAxis(width * 0.5, 0, originGlobal);
                case wcardinalUi.ESnapperModifierAnchor.TOP_RIGHT:
                    originLocal.set(0, height);
                    originGlobal.copyFrom(originLocal);
                    localTransform.apply(originLocal, originLocal);
                    worldTransform.apply(originGlobal, originGlobal);
                    return this.prepareScaleAxes(width, height, 0, 0, originGlobal);
                case wcardinalUi.ESnapperModifierAnchor.MIDDLE_LEFT:
                    originLocal.set(width, height * 0.5);
                    originGlobal.copyFrom(originLocal);
                    localTransform.apply(originLocal, originLocal);
                    worldTransform.apply(originGlobal, originGlobal);
                    return this.prepareScaleAxis(0, height * 0.5, originGlobal);
                case wcardinalUi.ESnapperModifierAnchor.NONE:
                    originLocal.set(width * 0.5, height * 0.5);
                    originGlobal.copyFrom(originLocal);
                    localTransform.apply(originLocal, originLocal);
                    worldTransform.apply(originGlobal, originGlobal);
                    if (0.001 < Math.abs(width)) {
                        this._scaleAxis0.x = width;
                    }
                    else {
                        return false;
                    }
                    if (0.001 < Math.abs(height)) {
                        this._scaleAxis0.y = height;
                    }
                    else {
                        return false;
                    }
                    return true;
                case wcardinalUi.ESnapperModifierAnchor.MIDDLE_RIGHT:
                    originLocal.set(0, height * 0.5);
                    originGlobal.copyFrom(originLocal);
                    localTransform.apply(originLocal, originLocal);
                    worldTransform.apply(originGlobal, originGlobal);
                    return this.prepareScaleAxis(width, height * 0.5, originGlobal);
                case wcardinalUi.ESnapperModifierAnchor.BOTTOM_LEFT:
                    originLocal.set(width, 0);
                    originGlobal.copyFrom(originLocal);
                    localTransform.apply(originLocal, originLocal);
                    worldTransform.apply(originGlobal, originGlobal);
                    return this.prepareScaleAxes(0, 0, width, height, originGlobal);
                case wcardinalUi.ESnapperModifierAnchor.BOTTOM_CENTER:
                    originLocal.set(width * 0.5, 0);
                    originGlobal.copyFrom(originLocal);
                    localTransform.apply(originLocal, originLocal);
                    worldTransform.apply(originGlobal, originGlobal);
                    return this.prepareScaleAxis(width * 0.5, height, originGlobal);
                case wcardinalUi.ESnapperModifierAnchor.BOTTOM_RIGHT:
                    originLocal.set(0, 0);
                    originGlobal.copyFrom(originLocal);
                    localTransform.apply(originLocal, originLocal);
                    worldTransform.apply(originGlobal, originGlobal);
                    return this.prepareScaleAxes(width, 0, 0, height, originGlobal);
            }
            return false;
        }
        prepareScaleAxis(x, y, origin) {
            const axis = this._scaleAxis0;
            axis.set(x, y);
            this._modifier.toGlobal(axis, axis, true);
            axis.x -= origin.x;
            axis.y -= origin.y;
            const v = Math.sqrt(axis.x * axis.x + axis.y * axis.y);
            if (0.001 < v) {
                const vi = 1 / v;
                axis.x *= vi;
                axis.y *= vi;
                this._scaleDet = v;
                this._scaleDetInverse = vi;
                return true;
            }
            return false;
        }
        prepareScaleAxes(x0, y0, x1, y1, originGlobal) {
            const modifier = this._modifier;
            const worldTransform = modifier.transform.worldTransform;
            // v0
            const axis0 = this._scaleAxis0;
            axis0.set(x0, y0);
            worldTransform.apply(axis0, axis0);
            axis0.x -= originGlobal.x;
            axis0.y -= originGlobal.y;
            // v1
            const axis1 = this._scaleAxis1;
            axis1.set(x1, y1);
            worldTransform.apply(axis1, axis1);
            axis1.x -= originGlobal.x;
            axis1.y -= originGlobal.y;
            const det = axis0.x * axis1.y - axis0.y * axis1.x;
            if (0.001 < Math.abs(det)) {
                this._scaleDet = det;
                this._scaleDetInverse = 1 / det;
                return true;
            }
            return false;
        }
        finalize() {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                for (let i = 0, imax = shapes.length; i < imax; ++i) {
                    const shape = shapes[i];
                    if (shape instanceof wcardinalUi.EShapeConnectorLine) {
                        UtilShapeConnectorTransforms.finalize(shape);
                    }
                    else {
                        UtilShapeTransforms.finalize(shape);
                    }
                }
            }
        }
        saveForTranslate() {
            wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyPosition(this));
        }
        saveForRotate() {
            wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyPositionAndRotate(this));
        }
        saveForScale() {
            wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyAll(this));
        }
        alignLeft() {
            this.align(initLeft, initWidth, updateMin, finishupIdentity, assingX, applyLeft);
        }
        alignCenter() {
            this.align(initCenter, initZero, updateSum, finishupAverage, assingX, applyCenter);
        }
        alignRight() {
            this.align(initRight, initWidth, updateMax, finishupIdentity, assingX, applyRight);
        }
        alignTop() {
            this.align(initTop, initHeight, updateMin, finishupIdentity, assingY, applyTop);
        }
        alignMiddle() {
            this.align(initMiddle, initZero, updateSum, finishupAverage, assingY, applyMiddle);
        }
        alignBottom() {
            this.align(initBottom, initHeight, updateMax, finishupIdentity, assingY, applyBottom);
        }
        align(init, initSpace, update, finishup, assing, apply) {
            const diagram = this._diagram;
            const canvas = diagram.canvas;
            const shapes = this._shapes;
            const shapesLength = shapes.length;
            if (canvas && 1 <= shapesLength) {
                const parent = shapes[0].parent;
                if (parent) {
                    const point = this._alignPoint;
                    const rectangle = this._alignRectangle;
                    let isFirst = true;
                    let value = 0;
                    const data = [];
                    for (let i = 0; i < shapesLength; ++i) {
                        const shape = shapes[i];
                        if (wcardinalUi.EShapeCapabilities.contains(shape, wcardinalUi.EShapeCapability.POSITION)) {
                            shape.getBounds(false, rectangle);
                            if (isFirst) {
                                isFirst = false;
                                value = init(rectangle);
                            }
                            else {
                                value = update(value, init(rectangle));
                            }
                            data.push([initSpace(rectangle), shape]);
                        }
                    }
                    const dataLength = data.length;
                    if (1 <= dataLength) {
                        if (dataLength <= 1) {
                            value = init(canvas.getBounds(false, rectangle));
                        }
                        value = finishup(value, dataLength);
                        point.set(0, 0);
                        assing(value, point);
                        parent.toLocal(point, undefined, point);
                        const scale = canvas.scale;
                        for (let i = 0; i < dataLength; ++i) {
                            const datum = data[i];
                            apply(point, datum[0] * 0.5, scale, datum[1]);
                        }
                        this.update(EToolSelectSelectionUpdatedPart.PROPERTY);
                    }
                }
            }
        }
        distributeHorizontally() {
            this.distribute(initCenter, initWidth, assingX, applyLeft);
        }
        distributeVertically() {
            this.distribute(initMiddle, initHeight, assingY, applyTop);
        }
        distribute(init, initSpace, assing, apply) {
            const diagram = this._diagram;
            const canvas = diagram.canvas;
            const shapes = this._shapes;
            const shapesLength = shapes.length;
            if (canvas && 1 <= shapesLength) {
                const parent = shapes[0].parent;
                if (parent) {
                    const point = this._alignPoint;
                    const rectangle = this._alignRectangle;
                    let spaceTotal = 0;
                    const data = [];
                    for (let i = 0; i < shapesLength; ++i) {
                        const shape = shapes[i];
                        if (wcardinalUi.EShapeCapabilities.contains(shape, wcardinalUi.EShapeCapability.POSITION)) {
                            shape.getBounds(false, rectangle);
                            const space = initSpace(rectangle);
                            spaceTotal += space;
                            data.push([init(rectangle), space, shape]);
                        }
                    }
                    const dataLength = data.length;
                    if (2 < dataLength) {
                        data.sort((a, b) => {
                            return a[0] - b[0];
                        });
                        const first = data[0];
                        const last = data[dataLength - 1];
                        const spaceLeft = last[0] - first[0] - (spaceTotal - last[1] * 0.5 - first[1] * 0.5);
                        const margin = spaceLeft / (dataLength - 1);
                        point.set(0, 0);
                        assing(first[0], point);
                        parent.toLocal(point, undefined, point);
                        let diff = first[1] * 0.5 + margin;
                        const scale = canvas.scale;
                        for (let i = 1, imax = dataLength - 1; i < imax; ++i) {
                            const datum = data[i];
                            const shape = datum[2];
                            diff += datum[1] * 0.5;
                            apply(point, diff, scale, shape);
                            diff += datum[1] * 0.5 + margin;
                        }
                        this.update(EToolSelectSelectionUpdatedPart.PROPERTY);
                    }
                    else if (dataLength === 1) {
                        point.set(0, 0);
                        assing(init(canvas.getBounds(false, rectangle)), point);
                        parent.toLocal(point, undefined, point);
                        const datum = data[0];
                        apply(point, 0, canvas.scale, datum[2]);
                        this.update(EToolSelectSelectionUpdatedPart.PROPERTY);
                    }
                }
            }
        }
        replace(shapeFactory) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                const parent = shapes[0].parent;
                if (parent) {
                    wcardinalUi.DControllers.getCommandController().push(new ECommandShapeReplace(parent, shapeFactory, this));
                }
            }
        }
        group() {
            const shapes = this._shapes;
            if (2 <= shapes.length) {
                const parent = shapes[0].parent;
                if (parent) {
                    wcardinalUi.DControllers.getCommandController().push(new ECommandShapeGroup(parent, this));
                }
            }
        }
        hasUngroupable(shapes) {
            for (let i = shapes.length - 1; 0 <= i; --i) {
                if (this.isUngroupable(shapes[i])) {
                    return true;
                }
            }
            return false;
        }
        isUngroupable(shape) {
            return (shape instanceof wcardinalUi.EShapeGroup &&
                wcardinalUi.EShapeCapabilities.contains(shape, wcardinalUi.EShapeCapability.CHILDREN) &&
                wcardinalUi.EShapeCapabilities.contains(shape, wcardinalUi.EShapeCapability.UNGROUPING));
        }
        ungroup() {
            const shapes = this._shapes;
            if (this.hasUngroupable(shapes)) {
                const parent = shapes[0].parent;
                if (parent) {
                    wcardinalUi.DControllers.getCommandController().push(new ECommandShapeUngroup(parent, this));
                }
            }
        }
        setFill(color, alpha) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyFillColor(this, [color, alpha]));
            }
        }
        setFillEnabled(enable) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyFillEnable(this, enable));
            }
        }
        setStroke(color, alpha) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyStrokeColor(this, [color, alpha]));
            }
        }
        setStrokeWidth(width) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyStrokeWidth(this, width));
            }
        }
        setStrokeAlign(align) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyStrokeAlign(this, align));
            }
        }
        setStrokeSide(side, isOn) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                if (isOn) {
                    wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyStrokeSideOn(this, side));
                }
                else {
                    wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyStrokeSideOff(this, side));
                }
            }
        }
        setStrokeStyle(add, remove) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyStrokeStyle(this, add, remove));
            }
        }
        setStrokeEnabled(enable) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyStrokeEnable(this, enable));
            }
        }
        setLineStyle(add, remove) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyLineStyle(this, add, remove));
            }
        }
        setLineTailType(type) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyLineTailType(this, type));
            }
        }
        setLineTailSizeX(size) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyLineTailSizeX(this, size));
            }
        }
        setLineTailSizeY(size) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyLineTailSizeY(this, size));
            }
        }
        setLineTailColor(color, alpha) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyLineTailColor(this, [color, alpha]));
            }
        }
        setLineTailMargin(margin) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyLineTailMargin(this, margin));
            }
        }
        setLineHeadType(type) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyLineHeadType(this, type));
            }
        }
        setLineHeadSizeX(size) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyLineHeadSizeX(this, size));
            }
        }
        setLineHeadSizeY(size) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyLineHeadSizeY(this, size));
            }
        }
        setLineHeadColor(color, alpha) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyLineHeadColor(this, [color, alpha]));
            }
        }
        setLineHeadMargin(margin) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyLineHeadMargin(this, margin));
            }
        }
        setPointsStyle(add, remove) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyPointsStyle(this, add, remove));
            }
        }
        setText(text) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyTextValue(this, text));
            }
        }
        setTextColor(color, alpha) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyTextColor(this, [color, alpha]));
            }
        }
        setTextFamily(family) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyTextFamily(this, family));
            }
        }
        setTextSize(size) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyTextSize(this, size));
            }
        }
        setTextSizeDelta(delta) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyTextSizeDelta(this, delta));
            }
        }
        setTextWeight(weight) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyTextWeight(this, weight));
            }
        }
        setTextStyle(style) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyTextStyle(this, style));
            }
        }
        setTextAlignHorizontal(align) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyTextAlignHorizontal(this, align));
            }
        }
        setTextAlignVertical(align) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyTextAlignVertical(this, align));
            }
        }
        setTextPaddingHorizontal(padding) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyTextPaddingHorizontal(this, padding));
            }
        }
        setTextPaddingVertical(padding) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyTextPaddingVertical(this, padding));
            }
        }
        setTextOffsetHorizontal(offset) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyTextOffsetHorizontal(this, offset));
            }
        }
        setTextOffsetVertical(offset) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyTextOffsetVertical(this, offset));
            }
        }
        setTextOutlineColor(color, alpha) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyTextOutlineColor(this, [color, alpha]));
            }
        }
        setTextOutlineWidth(width) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyTextOutlineWidth(this, width));
            }
        }
        setTextOutlineEnabled(enable) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyTextOutlineEnable(this, enable));
            }
        }
        setTextClipping(clipping) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyTextClipping(this, clipping));
            }
        }
        setTextFitting(fitting) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyTextFitting(this, fitting));
            }
        }
        setTextSpacingHorizontal(spacing) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyTextSpacingHorizontal(this, spacing));
            }
        }
        setTextSpacingVertical(spacing) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyTextSpacingVertical(this, spacing));
            }
        }
        setTextDirection(direction) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyTextDirection(this, direction));
            }
        }
        setInteractive(interactive) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyInteractive(this, interactive));
            }
        }
        setFocusable(isFocusable) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyFocusable(this, isFocusable));
            }
        }
        setShortcut(shortcut) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyShortcut(this, shortcut));
            }
        }
        setTitle(title) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyTitle(this, title));
            }
        }
        setCursor(cursor) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyCursor(this, cursor));
            }
        }
        setRadius(radius) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyRadius(this, radius));
            }
        }
        setCorner(corner, isOn) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                if (isOn) {
                    wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyCornerOn(this, corner));
                }
                else {
                    wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyCornerOff(this, corner));
                }
            }
        }
        setImage(image) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyImage(this, image, undefined));
            }
        }
        setGradient(image, gradient) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyImage(this, image, gradient));
            }
        }
        fitToImage() {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyImageFitTo(this));
            }
        }
        clearImage() {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyImageClear(this));
            }
        }
        bringToFront() {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                const parent = shapes[0].parent;
                if (parent) {
                    const children = parent.children;
                    // Update indices
                    const offset = children.length;
                    const indices = [];
                    for (let i = offset - 1; 0 <= i; --i) {
                        const child = children[i];
                        if (child.selected) {
                            child.index = offset + i;
                            indices.push(i);
                        }
                        else {
                            child.index = i;
                        }
                    }
                    // Sort
                    children.sort(UtilShapeSearch.COMPARATOR_INDEX);
                    //
                    let isChanged = false;
                    for (let i = 0, imax = indices.length; i < imax; ++i) {
                        if (offset - 1 - i !== indices[i]) {
                            isChanged = true;
                        }
                    }
                    //
                    if (isChanged) {
                        parent.toDirty();
                        wcardinalUi.DControllers.getCommandController().push(new ECommandShapeTreeBringToFront(indices, parent, this));
                        this.update(EToolSelectSelectionUpdatedPart.TREE);
                    }
                    return true;
                }
            }
            return false;
        }
        bringForward() {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                const parent = shapes[0].parent;
                if (parent) {
                    let isChanged = false;
                    const children = parent.children;
                    const indices = [];
                    let previous = null;
                    for (let i = children.length - 1; 0 <= i; --i) {
                        const child = children[i];
                        if (child.selected) {
                            if (previous) {
                                children[i] = children[i + 1];
                                children[i + 1] = child;
                                indices.push(i);
                                isChanged = true;
                            }
                        }
                        else {
                            previous = child;
                        }
                    }
                    if (isChanged) {
                        parent.toDirty();
                        wcardinalUi.DControllers.getCommandController().push(new ECommandShapeTreeBringForward(indices, parent, this));
                        this.update(EToolSelectSelectionUpdatedPart.TREE);
                    }
                    return isChanged;
                }
            }
            return false;
        }
        sendBackward() {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                const parent = shapes[0].parent;
                if (parent) {
                    let isChanged = false;
                    const children = parent.children;
                    const indices = [];
                    let previous = null;
                    for (let i = 0, imax = children.length; i < imax; ++i) {
                        const child = children[i];
                        if (child.selected) {
                            if (previous) {
                                children[i] = children[i - 1];
                                children[i - 1] = child;
                                indices.push(i);
                                isChanged = true;
                            }
                        }
                        else {
                            previous = child;
                        }
                    }
                    if (isChanged) {
                        parent.toDirty();
                        wcardinalUi.DControllers.getCommandController().push(new ECommandShapeTreeSendBackward(indices, parent, this));
                        this.update(EToolSelectSelectionUpdatedPart.TREE);
                    }
                    return isChanged;
                }
            }
            return false;
        }
        sendToBack() {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                const parent = shapes[0].parent;
                if (parent) {
                    const children = parent.children;
                    // Update indices
                    const indices = [];
                    const offset = children.length;
                    for (let i = 0; i < offset; ++i) {
                        const child = children[i];
                        if (child.selected) {
                            child.index = i - offset;
                            indices.push(i);
                        }
                        else {
                            child.index = i;
                        }
                    }
                    // Sort
                    children.sort(UtilShapeSearch.COMPARATOR_INDEX);
                    //
                    let isChanged = false;
                    for (let i = 0; i < indices.length; ++i) {
                        if (i !== indices[i]) {
                            isChanged = true;
                        }
                    }
                    //
                    if (isChanged) {
                        parent.toDirty();
                        wcardinalUi.DControllers.getCommandController().push(new ECommandShapeTreeSendToBack(indices, parent, this));
                        this.update(EToolSelectSelectionUpdatedPart.TREE);
                    }
                    return true;
                }
            }
            return false;
        }
        serialize() {
            const diagram = this._diagram;
            const canvas = diagram.canvas;
            if (canvas == null) {
                return null;
            }
            // Update UUID
            const manager = new wcardinalUi.EShapeResourceManagerSerialization();
            const shapes = this._shapes;
            const shapesLength = shapes.length;
            if (0 < shapesLength) {
                const root = shapes[0].root;
                if (root != null) {
                    const layer = root.parent;
                    if (layer instanceof wcardinalUi.DDiagramLayer) {
                        layer.addUuid(manager);
                        layer.updateUuid(manager);
                    }
                }
            }
            // Shape set
            const shapeSet = new Set();
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                shapeSet.add(shapes[i]);
            }
            // Serialize selected shapes
            const items = [];
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                const item = shape.serialize(manager);
                item[16] = 0;
                if (shape instanceof wcardinalUi.EShapeConnectorLine) {
                    let item29 = item[29];
                    if (item29 & wcardinalUi.EShapeCapability.LINE_TAIL) {
                        if (!shapeSet.has(shape.edge.tail.acceptor.shape)) {
                            item29 &= ~wcardinalUi.EShapeCapability.LINE_TAIL;
                        }
                    }
                    if (item29 & wcardinalUi.EShapeCapability.LINE_HEAD) {
                        if (!shapeSet.has(shape.edge.head.acceptor.shape)) {
                            item29 &= ~wcardinalUi.EShapeCapability.LINE_HEAD;
                        }
                    }
                    item[29] = item29;
                }
                items.push(item);
            }
            // Done
            const serialized = {
                version: wcardinalUi.DDiagramSerializedVersion,
                name: canvas.name,
                label: canvas.label,
                width: canvas.width,
                height: canvas.height,
                summary: canvas.summary,
                description: canvas.description,
                resources: manager.resources,
                data: manager.data,
                pieces: manager.pieces,
                items,
                layers: [
                    [
                        diagram instanceof wcardinalUi.DDiagramEditor
                            ? diagram.theme.getBaseLayerLabel()
                            : "Base Layer"
                    ]
                ]
            };
            return JSON.stringify(serialized);
        }
        deserialize(data) {
            const diagram = this._diagram;
            const layer = diagram.layer;
            if (layer != null) {
                const parsed = wcardinalUi.DDiagrams.parse(data);
                if (parsed != null) {
                    wcardinalUi.DDiagrams.toPieceData(diagram.controller, parsed.pieces, wcardinalUi.EShapeResourceManagerDeserializationMode.EDITOR).then((pieceData) => {
                        this.deserialize_(layer, parsed, pieceData);
                    });
                }
            }
        }
        deserialize_(layer, parsed, pieceData) {
            const manager = new wcardinalUi.EShapeResourceManagerDeserialization(parsed, parsed.pieces, pieceData, wcardinalUi.EShapeResourceManagerDeserializationMode.EDITOR, 0);
            const shapePromise = wcardinalUi.deserializeAll(parsed.items, manager);
            if (shapePromise) {
                shapePromise.then((shapes) => {
                    const shift = this.calcShift(shapes, layer);
                    const shapesLength = shapes.length;
                    const layerChildren = layer.children;
                    for (let i = 0; i < shapesLength; ++i) {
                        const shape = shapes[i];
                        shape.parent = layer;
                        shape.uploaded = undefined;
                        layerChildren.push(shape);
                    }
                    layer.onChildTransformChange();
                    layer.toDirty();
                    for (let i = 0; i < shapesLength; ++i) {
                        shapes[i].onAttach();
                    }
                    this.shift(shapes, shift);
                    wcardinalUi.DControllers.getCommandController().push(new ECommandShapeCreate(shapes, layer, this, true));
                });
            }
        }
        calcShift(shapes, parent) {
            if (shapes.length <= 0) {
                return null;
            }
            const work1 = this._shiftPoint1;
            const work2 = this._shiftPoint2;
            const first = shapes[0];
            first.updateTransform();
            const firstTransform = first.transform;
            work1.copyFrom(firstTransform.pivot);
            firstTransform.worldTransform.apply(work1, work1);
            parent.transform.worldTransform.apply(work1, work1);
            const gx = work1.x;
            const gy = work1.y;
            let delta = 0;
            while (true) {
                work1.set(gx + delta, gy + delta);
                const found = parent.hitTestBBox(work1, (target) => {
                    if (target.type === first.type) {
                        target.updateTransform();
                        const targetTransform = target.transform;
                        work2.copyFrom(targetTransform.pivot);
                        targetTransform.worldTransform.apply(work2, work2);
                        const dx = work2.x - (gx + delta);
                        const dy = work2.y - (gy + delta);
                        return Math.abs(dx) <= 0.1 && Math.abs(dy) <= 0.1;
                    }
                    return false;
                });
                if (found == null) {
                    work1.set(gx + delta, gy + delta);
                    parent.toLocal(work1, undefined, work1);
                    work2.set(work1.x - firstTransform.position.x, work1.y - firstTransform.position.y);
                    return work2;
                }
                delta += 10;
            }
        }
        shift(shapes, amount) {
            if (shapes.length <= 0 || amount == null) {
                return;
            }
            const ax = amount.x;
            const ay = amount.y;
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                if (wcardinalUi.EShapeCapabilities.contains(shape, wcardinalUi.EShapeCapability.POSITION)) {
                    const position = shape.transform.position;
                    position.set(position.x + ax, position.y + ay);
                }
                else if (shape instanceof wcardinalUi.EShapeConnectorLine) {
                    const edge = shape.edge;
                    const head = edge.head;
                    const tail = edge.tail;
                    if (head.acceptor.shape == null && tail.acceptor.shape == null) {
                        edge.lock();
                        const headLocal = head.local;
                        headLocal.set(headLocal.x + ax, headLocal.y + ay);
                        const tailLocal = tail.local;
                        tailLocal.set(tailLocal.x + ax, tailLocal.y + ay);
                        edge.unlock();
                    }
                }
            }
        }
        setId(id) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyId(this, id));
            }
        }
        addActionValue(value) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapeActionValueAdd(value, this));
            }
        }
        replaceActionValue(target, value, list) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapeActionValueReplace(target, value, this, list));
            }
        }
        removeActionValue(value) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapeActionValueRemove(value, this));
            }
        }
        bringActionValueForward(value) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapeActionValueBringForward(value, this));
            }
        }
        sendActionValueBackward(value) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapeActionValueSendBackward(value, this));
            }
        }
        addDataValue(value) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapeDataValueAdd(value, this));
            }
        }
        replaceDataValue(oldValue, newValue, list) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapeDataValueReplace(oldValue, newValue, this, list));
            }
        }
        removeDataValue(value) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapeDataValueRemove(value, this));
            }
        }
        bringDataValueForward(value) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapeDataValueBringForward(value, this));
            }
        }
        sendDataValueBackward(value) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapeDataValueSendBackward(value, this));
            }
        }
        addDataMappingValue(value) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapeDataMappingValueAdd(value, this));
            }
        }
        replaceDataMappingValue(oldValue, newValue, list) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapeDataMappingValueReplace(oldValue, newValue, this, list));
            }
        }
        removeDataMappingValue(value) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapeDataMappingValueRemove(value, this));
            }
        }
        bringDataMappingValueForward(value) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapeDataMappingValueBringForward(value, this));
            }
        }
        sendDataMappingValueBackward(value) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapeDataMappingValueSendBackward(value, this));
            }
        }
        setPositionX(x) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyPositionX(this, x));
            }
        }
        setPositionY(y) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyPositionY(this, y));
            }
        }
        setPositionLeft(left) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyPositionLeft(this, left));
            }
        }
        setPositionTop(top) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyPositionTop(this, top));
            }
        }
        setSizeX(x) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertySizeX(this, x));
            }
        }
        setSizeY(y) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertySizeY(this, y));
            }
        }
        setRotation(rotation) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyRotation(this, rotation));
            }
        }
        setSkew(skew) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertySkew(this, skew));
            }
        }
        toInternalVector(vector, result) {
            // Convert to the internal coordinate vector
            // A = modifier.parent.worldTransform
            // (ndx, ndy)^T = A^-1 (0, 0)^T - A^-1 (dx, dy)^T
            const modifier = this._modifier;
            modifier.updateTransform();
            const worldTransform = modifier.parent.worldTransform;
            const a = worldTransform.a;
            const b = worldTransform.b;
            const c = worldTransform.c;
            const d = worldTransform.d;
            const detInverse = 1 / (a * d - c * b);
            result.set((d * vector.x - c * vector.y) * detInverse, (a * vector.y - b * vector.x) * detInverse);
            return result;
        }
        translate(dx, dy, snap) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                const work = this._translateDelta;
                work.set(dx, dy);
                this.toInternalVector(work, work);
                if (snap) {
                    const diagram = this._diagram;
                    if (diagram instanceof wcardinalUi.DDiagramEditor) {
                        diagram.snapper.toTranslationSnapped(work, work);
                    }
                }
                const transform = this._transform.set(1, 0, 0, 1, work.x, work.y);
                for (let i = 0, imax = shapes.length; i < imax; ++i) {
                    const shape = shapes[i];
                    if (shape instanceof wcardinalUi.EShapeConnectorLine) {
                        const edge = shape.edge;
                        if (edge.tail.acceptor.shape == null && edge.head.acceptor.shape == null) {
                            UtilShapeConnectorTransforms.apply(shape, transform);
                        }
                    }
                    else {
                        let capability = wcardinalUi.EShapeCapability.NONE;
                        if (wcardinalUi.EShapeCapabilities.contains(shape, wcardinalUi.EShapeCapability.POSITION)) {
                            capability |= wcardinalUi.EShapeCapability.POSITION;
                        }
                        if (capability !== wcardinalUi.EShapeCapability.NONE) {
                            UtilShapeTransforms.apply(shape, transform, capability);
                        }
                    }
                }
                this.update(EToolSelectSelectionUpdatedPart.PROPERTY);
            }
        }
        rotateTo(global, snap) {
            const rotationAxisGlobal = this._rotationAxisGlobal;
            const originGlobal = this._originGlobal;
            const vx = global.x - originGlobal.x;
            const vy = global.y - originGlobal.y;
            const v = Math.sqrt(vx * vx + vy * vy);
            if (0.001 < v) {
                const vi = 1 / v;
                const nx = vx * vi;
                const ny = vy * vi;
                const dot = Math.max(-1, Math.min(1, rotationAxisGlobal.x * nx + rotationAxisGlobal.y * ny));
                const cross = rotationAxisGlobal.x * ny - rotationAxisGlobal.y * nx;
                let rotation = 0 <= cross ? +Math.acos(dot) : -Math.acos(dot);
                if (snap) {
                    const diagram = this._diagram;
                    if (diagram instanceof wcardinalUi.DDiagramEditor) {
                        const baseRotation = this._modifier.rotation;
                        rotation = diagram.snapper.toRotationSnapped(baseRotation, rotation);
                    }
                }
                this.rotate(rotation);
            }
        }
        rotate(rotation) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                const originLocal = this._originLocal;
                const transform = this._transform
                    .identity()
                    .translate(-originLocal.x, -originLocal.y)
                    .rotate(rotation)
                    .translate(+originLocal.x, +originLocal.y);
                for (let i = 0, imax = shapes.length; i < imax; ++i) {
                    const shape = shapes[i];
                    if (shape instanceof wcardinalUi.EShapeConnectorLine) {
                        const edge = shape.edge;
                        if (edge.tail.acceptor.shape == null && edge.head.acceptor.shape == null) {
                            UtilShapeConnectorTransforms.apply(shape, transform);
                        }
                    }
                    else {
                        let capability = wcardinalUi.EShapeCapability.NONE;
                        if (wcardinalUi.EShapeCapabilities.contains(shape, wcardinalUi.EShapeCapability.POSITION)) {
                            capability |= wcardinalUi.EShapeCapability.POSITION;
                        }
                        if (wcardinalUi.EShapeCapabilities.contains(shape, wcardinalUi.EShapeCapability.ROTATION)) {
                            capability |= wcardinalUi.EShapeCapability.ROTATION;
                        }
                        if (capability !== wcardinalUi.EShapeCapability.NONE) {
                            UtilShapeTransforms.apply(shape, transform, capability);
                        }
                    }
                }
                this.update(EToolSelectSelectionUpdatedPart.PROPERTY);
            }
        }
        getScale(dx, dy, anchor, keepRatio, result) {
            switch (anchor) {
                case wcardinalUi.ESnapperModifierAnchor.TOP_LEFT:
                    this.getScaleXY(dx, dy, keepRatio, result);
                    break;
                case wcardinalUi.ESnapperModifierAnchor.TOP_CENTER:
                    this.getScaleY(dx, dy, keepRatio, result);
                    break;
                case wcardinalUi.ESnapperModifierAnchor.TOP_RIGHT:
                    this.getScaleXY(dx, dy, keepRatio, result);
                    break;
                case wcardinalUi.ESnapperModifierAnchor.MIDDLE_LEFT:
                    this.getScaleX(dx, dy, keepRatio, result);
                    break;
                case wcardinalUi.ESnapperModifierAnchor.NONE:
                    const axis = this._scaleAxis0;
                    const width = axis.x;
                    const height = axis.y;
                    const scaleX = (width + dx) / width;
                    const scaleY = (height + dy) / height;
                    if (keepRatio) {
                        result.x = result.y = Math.max(scaleX, scaleY);
                    }
                    else {
                        result.set(scaleX, scaleY);
                    }
                    break;
                case wcardinalUi.ESnapperModifierAnchor.MIDDLE_RIGHT:
                    this.getScaleX(dx, dy, keepRatio, result);
                    break;
                case wcardinalUi.ESnapperModifierAnchor.BOTTOM_LEFT:
                    this.getScaleXY(dx, dy, keepRatio, result);
                    break;
                case wcardinalUi.ESnapperModifierAnchor.BOTTOM_CENTER:
                    this.getScaleY(dx, dy, keepRatio, result);
                    break;
                case wcardinalUi.ESnapperModifierAnchor.BOTTOM_RIGHT:
                    this.getScaleXY(dx, dy, keepRatio, result);
                    break;
            }
        }
        getScaleX(dx, dy, keepRatio, result) {
            const scale = this.calcScale(dx, dy);
            if (keepRatio) {
                result.set(scale, scale);
            }
            else {
                result.set(scale, 1);
            }
        }
        getScaleY(dx, dy, keepRatio, result) {
            const scale = this.calcScale(dx, dy);
            if (keepRatio) {
                result.set(scale, scale);
            }
            else {
                result.set(1, scale);
            }
        }
        calcScale(dx, dy) {
            const axis = this._scaleAxis0;
            const dot = axis.x * dx + axis.y * dy;
            return (this._scaleDet + dot) * this._scaleDetInverse;
        }
        getScaleXY(dx, dy, keepRatio, result) {
            // v0
            const axis0 = this._scaleAxis0;
            const vx0 = axis0.x;
            const vy0 = axis0.y;
            // v1
            const axis1 = this._scaleAxis1;
            const vx1 = axis1.x;
            const vy1 = axis1.y;
            // v2
            const vx2 = vx0 + vx1 + dx;
            const vy2 = vy0 + vy1 + dy;
            // A = | vx0, vx1 |
            //     | vy0, vy1 |
            // D = (dx, dy)^T
            // V0 = (vx0, vy0)^T
            // V1 = (vx1, vy1)^T
            // V2 = V0 + V1 + D;
            // A x = V
            //
            // det A = vx0 * vy1 - vy0 * vx1
            // (det A) A^-1 = |  vy1 -vx1 |
            //                | -vy0  vx0 |
            const detInverse = this._scaleDetInverse;
            const scaleX = (+vy1 * vx2 - vx1 * vy2) * detInverse;
            const scaleY = (-vy0 * vx2 + vx0 * vy2) * detInverse;
            this.setScale(scaleX, scaleY, keepRatio, result);
        }
        setScale(scaleX, scaleY, keepRatio, result) {
            if (keepRatio) {
                if (0 <= scaleX) {
                    if (0 <= scaleY) {
                        const scale = Math.max(scaleX, scaleY);
                        result.set(scale, scale);
                    }
                    else {
                        const scale = Math.max(scaleX, -scaleY);
                        result.set(scale, -scale);
                    }
                }
                else {
                    if (0 <= scaleY) {
                        const scale = Math.max(-scaleX, scaleY);
                        result.set(-scale, scale);
                    }
                    else {
                        const scale = Math.min(scaleX, scaleY);
                        result.set(scale, scale);
                    }
                }
            }
            else {
                result.set(scaleX, scaleY);
            }
            return result;
        }
        makeScaleTransform(scale, result) {
            return this._scaleTransform
                .copyTo(result)
                .scale(scale.x, scale.y)
                .prepend(this._scaleTransformInverse);
        }
        scale(dx, dy, keepRatio, snap) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                const scale = this._scale;
                const scaleAnchor = this._scaleAnchor;
                this.getScale(dx, dy, scaleAnchor, keepRatio, scale);
                const transform = this._transform;
                this.makeScaleTransform(scale, transform);
                if (snap) {
                    const diagram = this._diagram;
                    if (diagram instanceof wcardinalUi.DDiagramEditor) {
                        if (diagram.snapper.toScaleSnapped(transform, scaleAnchor, keepRatio, scale)) {
                            this.makeScaleTransform(scale, transform);
                        }
                    }
                }
                for (let i = 0, imax = shapes.length; i < imax; ++i) {
                    const shape = shapes[i];
                    if (shape instanceof wcardinalUi.EShapeConnectorLine) {
                        const edge = shape.edge;
                        if (edge.tail.acceptor.shape == null && edge.head.acceptor.shape == null) {
                            UtilShapeConnectorTransforms.apply(shape, transform);
                        }
                    }
                    else {
                        let capability = wcardinalUi.EShapeCapability.NONE;
                        if (wcardinalUi.EShapeCapabilities.contains(shape, wcardinalUi.EShapeCapability.POSITION)) {
                            capability |= wcardinalUi.EShapeCapability.POSITION;
                        }
                        if (wcardinalUi.EShapeCapabilities.contains(shape, wcardinalUi.EShapeCapability.WIDTH)) {
                            capability |= wcardinalUi.EShapeCapability.WIDTH;
                        }
                        if (wcardinalUi.EShapeCapabilities.contains(shape, wcardinalUi.EShapeCapability.HEIGHT)) {
                            capability |= wcardinalUi.EShapeCapability.HEIGHT;
                        }
                        if (wcardinalUi.EShapeCapabilities.contains(shape, wcardinalUi.EShapeCapability.ROTATION)) {
                            capability |= wcardinalUi.EShapeCapability.ROTATION;
                        }
                        if (wcardinalUi.EShapeCapabilities.contains(shape, wcardinalUi.EShapeCapability.SKEW)) {
                            capability |= wcardinalUi.EShapeCapability.SKEW;
                        }
                        if (capability !== wcardinalUi.EShapeCapability.NONE) {
                            UtilShapeTransforms.apply(shape, transform, capability);
                        }
                    }
                }
                this.update(EToolSelectSelectionUpdatedPart.PROPERTY);
            }
        }
        delete(save) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                const parent = shapes[0].parent;
                if (parent) {
                    if (save !== false) {
                        const deleteds = UtilShapeDeleter.delete(parent, shapes, true);
                        if (deleteds) {
                            const indices = UtilShapeSearch.toIndices(deleteds);
                            wcardinalUi.DControllers.getCommandController().push(new ECommandShapeDelete(deleteds, indices, parent, this, true));
                        }
                    }
                    else {
                        UtilShapeDeleter.delete(parent, shapes, false);
                    }
                    this.update(EToolSelectSelectionUpdatedPart.TREE | EToolSelectSelectionUpdatedPart.SELECTION);
                }
            }
        }
        createChildren(creator) {
            this.lock();
            const commands = [];
            const shapes = this._shapes;
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                const created = creator(shape);
                if (created) {
                    commands.push(new ECommandShapeCreate(created, shape, this, false));
                }
            }
            if (0 < commands.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandComposition(commands, this));
                this.update(EToolSelectSelectionUpdatedPart.TREE);
            }
            this.unlock();
        }
        deleteChildren(deletor) {
            this.lock();
            const commands = [];
            const shapes = this._shapes;
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                const targets = deletor(shape);
                if (targets) {
                    for (let j = 0, jmax = targets.length; j < jmax; ++j) {
                        targets[j].selected = true;
                    }
                    const deleteds = UtilShapeDeleter.delete(shape, undefined, true);
                    if (deleteds) {
                        const indices = UtilShapeSearch.toIndices(deleteds);
                        commands.push(new ECommandShapeDelete(deleteds, indices, shape, this, false));
                    }
                }
            }
            if (0 < commands.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandComposition(commands, this));
                this.update(EToolSelectSelectionUpdatedPart.TREE);
            }
            this.unlock();
        }
        lockCapability(target) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyCapabilityLock(this, target));
            }
        }
        unlockCapability(target) {
            const shapes = this._shapes;
            if (0 < shapes.length) {
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapePropertyCapabilityUnlock(this, target));
            }
        }
        store() {
            return this._shapes.slice(0);
        }
        restore(stored) {
            const shapes = this._shapes;
            // Unselect
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                shapes[i].selected = false;
            }
            shapes.length = 0;
            // Select
            for (let i = 0, imax = stored.length; i < imax; ++i) {
                const newShape = stored[i];
                newShape.selected = true;
                shapes.push(newShape);
            }
            // Done
            this.update(EToolSelectSelectionUpdatedPart.SELECTION);
        }
        get modifier() {
            return this._modifier;
        }
    }

    class UtilShapeAreaSelect {
        static isShapeIn(shape, rect) {
            var _a;
            const bound = shape.getBounds(false, ((_a = this._work) !== null && _a !== void 0 ? _a : (this._work = new pixi_js.Rectangle())));
            const x = bound.x;
            const y = bound.y;
            const w = bound.width;
            const h = bound.height;
            return (rect.contains(x, y) &&
                rect.contains(x + w, y) &&
                rect.contains(x, y + h) &&
                rect.contains(x + w, y + h));
        }
        static findShapes(container, rect, result) {
            const children = container.children;
            for (let i = 0, imax = children.length; i < imax; ++i) {
                const child = children[i];
                if (this.isShapeIn(child, rect)) {
                    result.push(child);
                }
            }
        }
    }

    class UtilHitTest {
        static execute(global, target, interactionManager) {
            var _a, _b;
            const offsets = ((_a = UtilHitTest.OFFSETS) !== null && _a !== void 0 ? _a : (UtilHitTest.OFFSETS = this.newOffsets()));
            const work = ((_b = UtilHitTest.WORK) !== null && _b !== void 0 ? _b : (UtilHitTest.WORK = new pixi_js.Point()));
            const x = global.x;
            const y = global.y;
            if (interactionManager) {
                for (let i = 0, imax = offsets.length; i < imax; i += 1) {
                    work.set(x + offsets[i], y + offsets[i + 1]);
                    const result = interactionManager.hitTest(work, target);
                    if (result != null) {
                        return result;
                    }
                }
            }
            else {
                for (let i = 0, imax = offsets.length; i < imax; i += 1) {
                    work.set(x + offsets[i], y + offsets[i + 1]);
                    const result = target.hitTest(work);
                    if (result != null) {
                        return result;
                    }
                }
            }
            return null;
        }
        static newOffsets() {
            return [
                +0, +0, -1, -1, +1, -1, +1, +1, -1, +1, +0, -2, +2, +0, +0, -2, -2, +0, -2, -2, +2, -2,
                +2, +2, -2, +2, +0, -4, +4, +0, +0, -4, -4, +0
            ];
        }
    }

    const toSelectionOptions = (options) => {
        const selection = options.selection;
        return {
            diagram: options.diagram,
            modifier: selection && selection.modifier
        };
    };
    class EToolSelect extends EToolImpl {
        constructor(options) {
            super();
            this._selection = new EToolSelectSelection(toSelectionOptions(options));
            this._area = new EToolSelectArea();
            this._diagram = options.diagram;
            this._applicationLayer = null;
            this._onDownPoint = new pixi_js.Point();
            this._onMovePoint = new pixi_js.Point();
            this._onUpPoint = new pixi_js.Point();
            this._areaRect = new pixi_js.Rectangle();
            this._mode = 0 /* EToolSelectMode.NONE */;
            this._isFirstMove = false;
            this._childSelectTime = -1;
            this._childSelectChild = null;
            const allow = options.allow;
            if (allow) {
                this._isTransformationAllowed = allow.transformation !== false;
                this._isDeletionAllowed = allow.deletion !== false;
            }
            else {
                this._isTransformationAllowed = true;
                this._isDeletionAllowed = true;
            }
            this._onDownBound = (e) => {
                this.onDown(e);
            };
            this._onMoveBound = (e) => {
                this.onMove(e);
            };
            this._onUpBound = (e) => {
                this.onUp(e);
            };
            this._onKeydownBound = (e) => {
                this.onKeydown(e);
            };
            this._onKeyupBound = (e) => {
                this.onKeyup(e);
            };
            this._onDblClickBound = (e) => {
                this.onDblClick(e);
            };
        }
        get selection() {
            return this._selection;
        }
        onActivate() {
            const diagram = this._diagram;
            diagram.on(wcardinalUi.UtilPointerEvent.down, this._onDownBound);
            diagram.on("dblclick", this._onDblClickBound);
            diagram.on("keydown", this._onKeydownBound);
            diagram.on("keyup", this._onKeyupBound);
        }
        onDeactivate() {
            const diagram = this._diagram;
            diagram.off(wcardinalUi.UtilPointerEvent.down, this._onDownBound);
            diagram.off("dblclick", this._onDblClickBound);
            diagram.off("keydown", this._onKeydownBound);
            diagram.off("keyup", this._onKeyupBound);
        }
        onDown(e) {
            const originalEvent = e.data.originalEvent;
            if (originalEvent.altKey) {
                return;
            }
            const diagram = this._diagram;
            const diagramCanvas = diagram.canvas;
            const diagramLayer = diagram.layer;
            if (diagramCanvas && diagramLayer) {
                const isAddMode = originalEvent.ctrlKey || originalEvent.shiftKey;
                if (this._mode === 1 /* EToolSelectMode.SELECT */) {
                    this._mode = 0 /* EToolSelectMode.NONE */;
                    this.onSelectEnd(diagramCanvas, diagramLayer, isAddMode);
                    return;
                }
                const global = e.data.global;
                const onDownPoint = this._onDownPoint;
                onDownPoint.copyFrom(global);
                const selection = this._selection;
                const modifier = selection.modifier;
                const hitObject = this.hitTest(global, modifier, diagramLayer);
                const commandController = wcardinalUi.DControllers.getCommandController();
                if (hitObject instanceof wcardinalUi.EShapeBase) {
                    if (isAddMode) {
                        const before = selection.store();
                        selection.toggle(hitObject);
                        const after = selection.store();
                        commandController.push(new ECommandShapeSelect(before, after, selection));
                    }
                    else if (!selection.contains(hitObject)) {
                        const first = selection.first();
                        if (first == null) {
                            const before = selection.store();
                            if (selection.set(hitObject.root)) {
                                const after = selection.store();
                                commandController.push(new ECommandShapeSelect(before, after, selection));
                            }
                        }
                        else {
                            const selected = UtilShapeSearch.toSelected(hitObject);
                            if (selected != null) {
                                if (wcardinalUi.EShapeCapabilities.contains(selected, wcardinalUi.EShapeCapability.CHILDREN)) {
                                    this._childSelectTime = Date.now();
                                    this._childSelectChild = UtilShapeSearch.toOfParent(hitObject, selected);
                                }
                            }
                            else {
                                const sharedParent = UtilShapeSearch.toSharedParent(first, hitObject);
                                const before = selection.store();
                                if (selection.set(UtilShapeSearch.toOfParent(hitObject, sharedParent))) {
                                    const after = selection.store();
                                    commandController.push(new ECommandShapeSelect(before, after, selection));
                                }
                            }
                        }
                    }
                    if (this._isTransformationAllowed && selection.prepareTranslate()) {
                        selection.prepareTranslateSnap();
                        this._mode = 2 /* EToolSelectMode.TRANSLATE */;
                        this._isFirstMove = true;
                    }
                }
                else if (hitObject === modifier) {
                    switch (modifier.getLastHitAnchor()) {
                        case wcardinalUi.ESnapperModifierAnchor.ROTATION:
                            if (selection.prepareRotate(global)) {
                                selection.prepareRotateSnap();
                                this._mode = 4 /* EToolSelectMode.ROTATE */;
                                this._isFirstMove = true;
                            }
                            break;
                        default:
                            if (selection.prepareScale(modifier.getLastHitAnchor())) {
                                selection.prepareScaleSnap();
                                this._mode = 3 /* EToolSelectMode.SCALE */;
                                this._isFirstMove = true;
                            }
                    }
                }
                else {
                    // Select area
                    const area = this._area;
                    diagramCanvas.toLocal(global, undefined, onDownPoint);
                    area.x = onDownPoint.x;
                    area.y = onDownPoint.y;
                    area.size.set(0, 0);
                    area.update();
                    diagramCanvas.addChild(area);
                    wcardinalUi.DApplications.update(diagram);
                    // Select mode
                    this._mode = 1 /* EToolSelectMode.SELECT */;
                }
                if (this._mode !== 0 /* EToolSelectMode.NONE */) {
                    const oldApplicationLayer = this._applicationLayer;
                    if (oldApplicationLayer) {
                        this._applicationLayer = null;
                        const oldInteractionManager = oldApplicationLayer.renderer.plugins.interaction;
                        oldInteractionManager.off(wcardinalUi.UtilPointerEvent.move, this._onMoveBound);
                        const onUpBound = this._onUpBound;
                        oldInteractionManager.off(wcardinalUi.UtilPointerEvent.up, onUpBound);
                        oldInteractionManager.off(wcardinalUi.UtilPointerEvent.upoutside, onUpBound);
                        oldInteractionManager.off(wcardinalUi.UtilPointerEvent.cancel, onUpBound);
                    }
                    const newApplicationLayer = wcardinalUi.DApplications.getLayer(diagram);
                    if (newApplicationLayer) {
                        this._applicationLayer = newApplicationLayer;
                        const newInteractionManager = newApplicationLayer.renderer.plugins.interaction;
                        newInteractionManager.on(wcardinalUi.UtilPointerEvent.move, this._onMoveBound);
                        const onUpBound = this._onUpBound;
                        newInteractionManager.on(wcardinalUi.UtilPointerEvent.up, onUpBound);
                        newInteractionManager.on(wcardinalUi.UtilPointerEvent.upoutside, onUpBound);
                        newInteractionManager.on(wcardinalUi.UtilPointerEvent.cancel, onUpBound);
                    }
                }
            }
        }
        onMove(e) {
            const originalEvent = e.data.originalEvent;
            if (originalEvent.altKey) {
                return;
            }
            const diagram = this._diagram;
            const diagramCanvas = diagram.canvas;
            const diagramLayer = diagram.layer;
            const mode = this._mode;
            const applicationLayer = this._applicationLayer;
            if (diagramCanvas && diagramLayer && mode !== 0 /* EToolSelectMode.NONE */ && applicationLayer) {
                const global = e.data.global;
                applicationLayer.lock();
                const onDownPoint = this._onDownPoint;
                if (mode === 1 /* EToolSelectMode.SELECT */) {
                    const area = this._area;
                    const onMovePoint = diagramCanvas.toLocal(global, undefined, this._onMovePoint);
                    area.x = Math.min(onDownPoint.x, onMovePoint.x);
                    area.y = Math.min(onDownPoint.y, onMovePoint.y);
                    area.size.set(Math.max(onDownPoint.x, onMovePoint.x) - area.x, Math.max(onDownPoint.y, onMovePoint.y) - area.y);
                    area.update();
                }
                else {
                    const dx = global.x - onDownPoint.x;
                    const dy = global.y - onDownPoint.y;
                    if (1 <= Math.abs(dx) || 1 <= Math.abs(dy)) {
                        const isFirstMove = this._isFirstMove;
                        this._isFirstMove = false;
                        this._childSelectChild = null;
                        const selection = this._selection;
                        selection.modifier.disallow();
                        switch (mode) {
                            case 2 /* EToolSelectMode.TRANSLATE */:
                                if (isFirstMove) {
                                    selection.saveForTranslate();
                                }
                                selection.translate(dx, dy, true);
                                break;
                            case 4 /* EToolSelectMode.ROTATE */:
                                if (isFirstMove) {
                                    selection.saveForRotate();
                                }
                                selection.rotateTo(global, true);
                                break;
                            case 3 /* EToolSelectMode.SCALE */:
                                if (isFirstMove) {
                                    selection.saveForScale();
                                }
                                const keepRatio = originalEvent.shiftKey;
                                selection.scale(dx, dy, keepRatio, true);
                                break;
                        }
                    }
                }
                applicationLayer.unlock();
                applicationLayer.update();
            }
        }
        hitTest(global, modifier, diagramLayer) {
            // Modifier
            if (this._isTransformationAllowed && modifier.visible) {
                const applicationLayer = wcardinalUi.DApplications.getLayer(diagramLayer);
                if (applicationLayer) {
                    const interactionManager = applicationLayer.renderer.plugins.interaction;
                    const modifierHit = UtilHitTest.execute(global, modifier, interactionManager);
                    if (modifierHit != null) {
                        return modifierHit;
                    }
                }
            }
            // Layer
            if (diagramLayer.visible) {
                return UtilHitTest.execute(global, diagramLayer);
            }
            // Found nothing
            return null;
        }
        onSelectEnd(canvas, diagramLayer, isAddMode) {
            const area = this._area;
            const selection = this._selection;
            const commandController = wcardinalUi.DControllers.getCommandController();
            if (0 < area.size.x && 0 < area.size.y) {
                const areaRect = area.getBounds(false, this._areaRect);
                const foundShapes = [];
                UtilShapeAreaSelect.findShapes(diagramLayer, areaRect, foundShapes);
                if (isAddMode) {
                    if (0 < foundShapes.length) {
                        const before = selection.store();
                        if (selection.addAll(foundShapes)) {
                            const after = selection.store();
                            commandController.push(new ECommandShapeSelect(before, after, selection));
                        }
                    }
                }
                else {
                    if (0 < foundShapes.length || !selection.isEmpty()) {
                        const before = selection.store();
                        if (selection.clearAndAddAll(foundShapes)) {
                            const after = selection.store();
                            commandController.push(new ECommandShapeSelect(before, after, selection));
                        }
                    }
                }
            }
            else if (!isAddMode) {
                if (!selection.isEmpty()) {
                    const before = selection.store();
                    if (selection.clear()) {
                        const after = selection.store();
                        commandController.push(new ECommandShapeSelect(before, after, selection));
                    }
                }
            }
            canvas.removeChild(area);
            wcardinalUi.DApplications.update(diagramLayer);
        }
        onUp(e) {
            const diagram = this._diagram;
            const diagramCanvas = diagram.canvas;
            const diagramLayer = diagram.layer;
            const mode = this._mode;
            const applicationLayer = this._applicationLayer;
            if (applicationLayer) {
                this._applicationLayer = null;
                const interactionManager = applicationLayer.renderer.plugins.interaction;
                interactionManager.off(wcardinalUi.UtilPointerEvent.move, this._onMoveBound);
                const onUpBound = this._onUpBound;
                interactionManager.off(wcardinalUi.UtilPointerEvent.up, onUpBound);
                interactionManager.off(wcardinalUi.UtilPointerEvent.upoutside, onUpBound);
                interactionManager.off(wcardinalUi.UtilPointerEvent.cancel, onUpBound);
            }
            if (diagramCanvas && diagramLayer && mode !== 0 /* EToolSelectMode.NONE */) {
                this._mode = 0 /* EToolSelectMode.NONE */;
                if (mode === 1 /* EToolSelectMode.SELECT */) {
                    const originalEvent = e.data.originalEvent;
                    const isAddMode = originalEvent.ctrlKey || originalEvent.shiftKey;
                    this.onSelectEnd(diagramCanvas, diagramLayer, isAddMode);
                }
                else {
                    const selection = this._selection;
                    // Finalize
                    selection.finalize();
                    // Select the child
                    const childSelectChild = this._childSelectChild;
                    if (childSelectChild != null) {
                        this._childSelectChild = null;
                        const elapsedTime = Date.now() - this._childSelectTime;
                        if (elapsedTime < 333) {
                            const before = selection.store();
                            if (selection.set(childSelectChild)) {
                                const after = selection.store();
                                wcardinalUi.DControllers.getCommandController().push(new ECommandShapeSelect(before, after, selection));
                            }
                        }
                    }
                    //
                    selection.modifier.allow();
                    selection.updateModifier();
                    if (applicationLayer) {
                        applicationLayer.update();
                    }
                }
            }
        }
        getRotateAmount(e) {
            return (Math.PI * (e.ctrlKey ? 1 : 15)) / 180;
        }
        getScaleAmount(e) {
            return e.ctrlKey ? 1 : 10;
        }
        getTranslateAmount(e) {
            return e.ctrlKey ? 1 : 10;
        }
        onKeydown(e) {
            const selection = this._selection;
            if (!selection.isEmpty()) {
                if (this._isTransformationAllowed) {
                    if (wcardinalUi.UtilKeyboardEvent.isArrowUpKey(e)) {
                        if (e.shiftKey) {
                            if (selection.prepareScale(wcardinalUi.ESnapperModifierAnchor.NONE)) {
                                selection.saveForScale();
                                selection.scale(0, this.getScaleAmount(e), false, false);
                                selection.finalize();
                            }
                        }
                        else {
                            if (selection.prepareTranslate()) {
                                selection.saveForTranslate();
                                selection.translate(0, -this.getTranslateAmount(e), false);
                                selection.finalize();
                            }
                        }
                        e.preventDefault();
                    }
                    else if (wcardinalUi.UtilKeyboardEvent.isArrowRightKey(e)) {
                        if (e.altKey) {
                            if (selection.prepareRotate()) {
                                selection.saveForRotate();
                                selection.rotate(this.getRotateAmount(e));
                                selection.finalize();
                            }
                        }
                        else if (e.shiftKey) {
                            if (selection.prepareScale(wcardinalUi.ESnapperModifierAnchor.NONE)) {
                                selection.saveForScale();
                                selection.scale(this.getScaleAmount(e), 0, false, false);
                                selection.finalize();
                            }
                        }
                        else {
                            if (selection.prepareTranslate()) {
                                selection.saveForTranslate();
                                selection.translate(this.getTranslateAmount(e), 0, false);
                                selection.finalize();
                            }
                        }
                        e.preventDefault();
                    }
                    else if (wcardinalUi.UtilKeyboardEvent.isArrowDownKey(e)) {
                        if (e.shiftKey) {
                            if (selection.prepareScale(wcardinalUi.ESnapperModifierAnchor.NONE)) {
                                selection.saveForScale();
                                selection.scale(0, -this.getScaleAmount(e), false, false);
                                selection.finalize();
                            }
                        }
                        else {
                            if (selection.prepareTranslate()) {
                                selection.saveForTranslate();
                                selection.translate(0, this.getTranslateAmount(e), false);
                                selection.finalize();
                            }
                        }
                        e.preventDefault();
                    }
                    else if (wcardinalUi.UtilKeyboardEvent.isArrowLeftKey(e)) {
                        if (e.altKey) {
                            if (selection.prepareRotate()) {
                                selection.saveForRotate();
                                selection.rotate(-this.getRotateAmount(e));
                                selection.finalize();
                            }
                        }
                        else if (e.shiftKey) {
                            if (selection.prepareScale(wcardinalUi.ESnapperModifierAnchor.NONE)) {
                                selection.saveForScale();
                                selection.scale(-this.getScaleAmount(e), 0, false, false);
                                selection.finalize();
                            }
                        }
                        else {
                            if (selection.prepareTranslate()) {
                                selection.saveForTranslate();
                                selection.translate(-this.getTranslateAmount(e), 0, false);
                                selection.finalize();
                            }
                        }
                        e.preventDefault();
                    }
                }
                if (this._isDeletionAllowed) {
                    if (wcardinalUi.UtilKeyboardEvent.isDeleteKey(e)) {
                        selection.delete();
                        e.preventDefault();
                    }
                }
            }
            if (wcardinalUi.UtilKeyboardEvent.isSelectAllKey(e)) {
                const first = selection.first();
                const parent = first == null ? this._diagram.layer : first.parent;
                if (parent != null) {
                    const children = parent.children;
                    if (0 < children.length) {
                        const before = selection.store();
                        if (e.altKey) {
                            const types = new Set();
                            for (let i = 0, imax = before.length; i < imax; ++i) {
                                types.add(before[i].type);
                            }
                            const after = [];
                            for (let i = 0, imax = children.length; i < imax; ++i) {
                                const child = children[i];
                                if (child.selected) {
                                    after.push(child);
                                }
                                else if (types.has(child.type)) {
                                    after.push(child);
                                }
                            }
                            if (selection.clearAndAddAll(after)) {
                                wcardinalUi.DControllers.getCommandController().push(new ECommandShapeSelect(before, after, selection));
                            }
                        }
                        else {
                            if (selection.clearAndAddAll(children)) {
                                const after = selection.store();
                                wcardinalUi.DControllers.getCommandController().push(new ECommandShapeSelect(before, after, selection));
                            }
                        }
                    }
                }
            }
        }
        onKeyup(e) {
            // DO NOTHING
        }
        onDblClick(e) {
            const selection = this._selection;
            const last = selection.last();
            if (last != null) {
                this.emit("edit", last, this);
            }
        }
    }

    class EToolShapeAcceptorEdgeRenderer extends wcardinalUi.EShapeContainer {
        constructor(edge) {
            super();
            this._edge = edge;
            this._circles = this.newCircles();
            this._foundEdges = [];
            this._radius = wcardinalUi.EShapeDefaults.SIZE_X * 2;
            this._scaleBound = 1;
            this._scaleBoundInverse = 1;
            this._type = wcardinalUi.EShapeAcceptorEdgeType.TAIL;
            this._x = 0;
            this._y = 0;
            this._ox = 0;
            this._oy = 0;
            this._isDirty = false;
            this._isBegan = false;
            this._doUpdateBound = () => {
                this._timeout = null;
                if (this._isDirty) {
                    this._isDirty = false;
                    if (this._isBegan) {
                        this.visible = true;
                        this.doUpdate();
                    }
                }
            };
        }
        newCircles() {
            const result = [];
            const color = wcardinalUi.EShapeDefaults.STROKE_COLOR;
            const alpha = wcardinalUi.EShapeDefaults.STROKE_ALPHA;
            for (let i = 0, imax = 64; i < imax; ++i) {
                const shape = new wcardinalUi.EShapeCircle();
                shape.stroke.set(false);
                shape.fill.set(true, color, alpha);
                shape.visible = false;
                shape.attach(this);
                result.push(shape);
            }
            return result;
        }
        begin(canvas) {
            canvas.addChild(this);
            const layer = canvas.layer.active;
            if (layer != null) {
                const position = layer.transform.position;
                this._ox = position.x;
                this._oy = position.y;
            }
            else {
                this._ox = 0;
                this._oy = 0;
            }
            this.visible = false;
            this._isBegan = true;
        }
        end() {
            const parent = this.parent;
            if (parent != null) {
                parent.removeChild(this);
            }
            this.visible = false;
            this._isBegan = false;
        }
        onPrerender() {
            const scale0 = this.getParentScale();
            const scale1 = this._scaleBound;
            if (0.001 < Math.abs(scale0 - scale1)) {
                this._scaleBound = scale0;
                this._scaleBoundInverse = 1 / scale0;
                const size = this.getCircleSize();
                const circles = this._circles;
                for (let i = 0, imax = circles.length; i < imax; ++i) {
                    circles[i].size.set(size, size);
                }
            }
        }
        render(renderer) {
            if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
                return;
            }
            this.onPrerender();
            super.render(renderer);
        }
        getParentScale() {
            const parent = this.parent;
            if (parent != null) {
                return parent.scale.y;
            }
            return 1;
        }
        getCircleSize() {
            return 10 * Math.min(1, this._scaleBoundInverse);
        }
        update(type, x, y) {
            if (this._isBegan) {
                this._type = type;
                this._x = x;
                this._y = y;
                if (this._timeout == null) {
                    this.visible = true;
                    this.doUpdate();
                    this._timeout = window.setTimeout(this._doUpdateBound, 100);
                }
                else {
                    this._isDirty = true;
                }
            }
        }
        doUpdate() {
            const radius = this._radius;
            const circles = this._circles;
            const circlesLength = circles.length;
            const edges = this._foundEdges;
            this._edge.findAll(this._type, this._x, this._y, radius, circlesLength, edges);
            const edgesLength = edges.length;
            const ox = this._ox;
            const oy = this._oy;
            const size = this.getCircleSize();
            const isize = Math.min(circlesLength, edgesLength);
            const distance = radius * radius;
            for (let i = 0; i < isize; ++i) {
                const edge = edges[i];
                const edgeCenter = edge.center;
                const circle = circles[i];
                circle.lock(wcardinalUi.EShapeLockPart.UPLOADED);
                circle.transform.position.set(ox + edgeCenter.x, oy + edgeCenter.y);
                circle.size.set(size, size);
                circle.fill.alpha = 0.5 * Math.max(0, 1 - edge.distance / distance);
                circle.visible = true;
                circle.unlock(wcardinalUi.EShapeLockPart.UPLOADED, true);
            }
            for (let i = isize; i < circlesLength; ++i) {
                circles[i].visible = false;
            }
            wcardinalUi.DApplications.update(this);
        }
    }

    const SIZE = 10;
    class EToolShapeAcceptorEdge {
        constructor(diagram, canvasMode) {
            this._diagram = diagram;
            this._canvasMode = canvasMode;
            this._renderer = new EToolShapeAcceptorEdgeRenderer(this);
            this._work = new Set();
        }
        begin(canvas, shape) {
            this.clear();
            this._shape = shape;
            if (canvas != null) {
                this._renderer.begin(canvas);
            }
        }
        end() {
            this._renderer.end();
            this.clear();
        }
        update(type, x, y) {
            this._renderer.update(type, x, y);
        }
        show() {
            this._renderer.visible = true;
        }
        hide() {
            this._renderer.visible = false;
        }
        get edges() {
            let result = this._edges;
            if (result == null) {
                result = this.newEdges();
                this._edges = result;
            }
            return result;
        }
        newEdges() {
            const result = new Map();
            const layer = this._diagram.layer;
            if (layer) {
                let layerPositionX = 0;
                let layerPositionY = 0;
                if (this._canvasMode) {
                    const layerPosition = layer.transform.position;
                    layerPositionX = layerPosition.x;
                    layerPositionY = layerPosition.y;
                }
                const shape = this._shape;
                if (shape != null) {
                    const shapeParent = shape.parent;
                    if (shapeParent != null) {
                        this.addAll(shapeParent.children, layerPositionX, layerPositionY, result);
                    }
                }
                else {
                    this.addAll(layer.children, layerPositionX, layerPositionY, result);
                }
            }
            return result;
        }
        addAll(shapes, lx, ly, result) {
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                if (!(shape instanceof wcardinalUi.EShapeConnectorLine)) {
                    const size = shape.size;
                    const sx = size.x;
                    const sy = size.y;
                    const transform = shape.transform;
                    const internal = transform.internalTransform;
                    const a = internal.a;
                    const b = internal.b;
                    const c = internal.c;
                    const d = internal.d;
                    const pivot = transform.pivot;
                    const px = pivot.x;
                    const py = pivot.y;
                    const matrix = new pixi_js.Matrix(a * sx, b * sx, c * sy, d * sy, internal.tx + lx + (a * px + c * py), internal.ty + ly + (b * px + d * py));
                    wcardinalUi.EShapeAcceptors.get(shape.type).each(shape, (edge, id) => {
                        this.add(matrix, id, edge, shape, result);
                    });
                    if (wcardinalUi.EShapeCapabilities.contains(shape, wcardinalUi.EShapeCapability.CHILDREN)) {
                        const children = shape.children;
                        if (children) {
                            this.addAll(children, lx, ly, result);
                        }
                    }
                }
            }
        }
        add(matrix, id, acceptorEdge, shape, coordinateToEdges) {
            const aes = acceptorEdge.size;
            const aesx = aes.x;
            const aesy = aes.y;
            const aex = acceptorEdge.x;
            const aey = acceptorEdge.y;
            const a = matrix.a;
            const b = matrix.b;
            const c = matrix.c;
            const d = matrix.d;
            const tx = matrix.tx;
            const ty = matrix.ty;
            const x = a * aex + c * aey + tx;
            const y = b * aex + d * aey + ty;
            const edge = {
                shape,
                id,
                x: null,
                y: null,
                acceptor: acceptorEdge,
                matrix,
                local: new pixi_js.Point(x, y),
                center: new pixi_js.Point(x, y),
                distance: 0
            };
            if (aesx === 0 && aesy === 0) {
                const gx = this.toGridIndex(x);
                const gy = this.toGridIndex(y);
                const coordinate = this.toCoordinate(gx, gy);
                const edges = coordinateToEdges.get(coordinate);
                if (edges == null) {
                    coordinateToEdges.set(coordinate, [edge]);
                }
                else {
                    edges.push(edge);
                }
            }
            else {
                const aesxh = aesx * 0.5;
                const aesyh = aesy * 0.5;
                const aex0 = aex - aesxh;
                const aey0 = aey - aesyh;
                const aex1 = aex + aesxh;
                const aey1 = aey - aesyh;
                const aex2 = aex + aesxh;
                const aey2 = aey + aesyh;
                const aex3 = aex - aesxh;
                const aey3 = aey + aesyh;
                const x0 = a * aex0 + c * aey0;
                const y0 = b * aex0 + d * aey0;
                const x1 = a * aex1 + c * aey1;
                const y1 = b * aex1 + d * aey1;
                const x2 = a * aex2 + c * aey2;
                const y2 = b * aex2 + d * aey2;
                const x3 = a * aex3 + c * aey3;
                const y3 = b * aex3 + d * aey3;
                const x4 = Math.min(x0, x1, x2, x3) + tx;
                const y4 = Math.min(y0, y1, y2, y3) + ty;
                const x5 = Math.max(x0, x1, x2, x3) + tx;
                const y5 = Math.max(y0, y1, y2, y3) + ty;
                const ix0 = Math.floor(x4 / SIZE);
                const iy0 = Math.floor(y4 / SIZE);
                const ix1 = Math.ceil(x5 / SIZE);
                const iy1 = Math.ceil(y5 / SIZE);
                for (let ix = ix0; ix <= ix1; ++ix) {
                    for (let iy = iy0; iy <= iy1; ++iy) {
                        const coordinate = this.toCoordinate(ix, iy);
                        const edges = coordinateToEdges.get(coordinate);
                        if (edges == null) {
                            coordinateToEdges.set(coordinate, [edge]);
                        }
                        else {
                            edges.push(edge);
                        }
                    }
                }
            }
        }
        toCoordinate(ix, iy) {
            return (ix % 1024) + (iy % 1024 << 10);
        }
        toGridIndex(x) {
            return Math.round(x / SIZE);
        }
        find(type, x, y) {
            let result = null;
            let distance = 0;
            const edges = this.edges;
            const threshold = SIZE * SIZE;
            for (let ix = -SIZE; ix <= SIZE; ix += SIZE) {
                for (let iy = -SIZE; iy <= SIZE; iy += SIZE) {
                    const gix = this.toGridIndex(x + ix);
                    const giy = this.toGridIndex(y + iy);
                    const foundEdges = edges.get(this.toCoordinate(gix, giy));
                    if (foundEdges == null) {
                        continue;
                    }
                    for (let i = 0, imax = foundEdges.length; i < imax; ++i) {
                        const foundEdge = foundEdges[i];
                        const acceptorEdge = foundEdge.acceptor;
                        if ((acceptorEdge.type & type) === 0) {
                            continue;
                        }
                        const size = acceptorEdge.size;
                        const sx = size.x;
                        const sy = size.y;
                        if (sx === 0 && sy === 0) {
                            const center = foundEdge.center;
                            const dx = x - center.x;
                            const dy = y - center.y;
                            const dd = dx * dx + dy * dy;
                            if (dd <= threshold && (result == null || dd < distance)) {
                                result = foundEdge;
                                distance = dd;
                            }
                        }
                        else {
                            const matrix = foundEdge.matrix;
                            const a = matrix.a;
                            const b = matrix.b;
                            const c = matrix.c;
                            const d = matrix.d;
                            const tx = matrix.tx;
                            const ty = matrix.ty;
                            const det = a * d - c * b;
                            if (0.0000001 < Math.abs(det)) {
                                const di = 1 / det;
                                const xtx = x - tx;
                                const yty = y - ty;
                                const lx = (+d * xtx - c * yty) * di;
                                const ly = (-b * xtx + a * yty) * di;
                                const sxh = sx * 0.5;
                                const syh = sy * 0.5;
                                const aex = acceptorEdge.x;
                                const aey = acceptorEdge.y;
                                const lx0 = aex - sxh;
                                const ly0 = aey - syh;
                                const lx1 = aex + sxh;
                                const ly1 = aey + syh;
                                const lx2 = Math.min(lx1, Math.max(lx0, lx));
                                const ly2 = Math.min(ly1, Math.max(ly0, ly));
                                const x0 = a * lx2 + c * ly2 + tx;
                                const y0 = b * lx2 + d * ly2 + ty;
                                const dx = x - x0;
                                const dy = y - y0;
                                const dd = dx * dx + dy * dy;
                                if (dd <= threshold && (result == null || dd < distance)) {
                                    result = foundEdge;
                                    result.x = lx2;
                                    result.y = ly2;
                                    result.local.set(x0, y0);
                                    distance = dd;
                                }
                            }
                            else {
                                const center = foundEdge.center;
                                const dx = x - center.x;
                                const dy = y - center.y;
                                const dd = dx * dx + dy * dy;
                                if (dd <= threshold && (result == null || dd < distance)) {
                                    result = foundEdge;
                                    distance = dd;
                                }
                            }
                        }
                    }
                }
            }
            return result;
        }
        findAll(type, x, y, range, limit, result) {
            const edges = this.edges;
            range = Math.ceil(range / SIZE) * SIZE;
            const threshold = range * range;
            const work = this._work;
            work.clear();
            this.findAllS1(type, x, y, 0, 0, edges, threshold, work);
            for (let ir = SIZE; ir <= range && work.size < limit; ir += SIZE) {
                this.findAllS2(type, x, y, edges, threshold, ir, work);
            }
            let iresult = -1;
            work.forEach((found) => {
                result[++iresult] = found;
            });
            result.length = work.size;
            result.sort(this.compare);
            return result;
        }
        findAllS2(type, x, y, edges, threshold, radius, result) {
            for (let dx = -radius; dx <= radius; dx += SIZE) {
                this.findAllS1(type, x, y, dx, -radius, edges, threshold, result);
                this.findAllS1(type, x, y, dx, +radius, edges, threshold, result);
            }
            for (let dy = -radius + SIZE, iymax = radius - SIZE; dy <= iymax; dy += SIZE) {
                this.findAllS1(type, x, y, -radius, dy, edges, threshold, result);
                this.findAllS1(type, x, y, +radius, dy, edges, threshold, result);
            }
        }
        findAllS1(type, x, y, dx, dy, edges, threshold, result) {
            const gix = this.toGridIndex(x + dx);
            const giy = this.toGridIndex(y + dy);
            const foundEdges = edges.get(this.toCoordinate(gix, giy));
            if (foundEdges) {
                for (let i = 0, imax = foundEdges.length; i < imax; ++i) {
                    const foundEdge = foundEdges[i];
                    if (foundEdge.acceptor.type & type) {
                        const foundEdgeLocal = foundEdge.local;
                        const sx = x - foundEdgeLocal.x;
                        const sy = y - foundEdgeLocal.y;
                        const sd = sx * sx + sy * sy;
                        if (sd <= threshold) {
                            foundEdge.distance = sd;
                            result.add(foundEdge);
                        }
                    }
                }
            }
        }
        compare(a, b) {
            const ad = a.distance;
            const bd = b.distance;
            return ad < bd ? -1 : ad > bd ? +1 : 0;
        }
        clear() {
            this._edges = undefined;
        }
    }

    const EToolShapeCreateLineConnectorPhase = {
        OFF: -1,
        TAIL: 0,
        HEAD: 1,
        DONE: 2
    };
    class EToolShapeCreateLineConnector extends EToolImpl {
        constructor(options) {
            super();
            this._options = options;
            this._selection = options.selection;
            this._diagram = options.diagram;
            this._edge = new EToolShapeAcceptorEdge(options.diagram, false);
            this._newShape = options.newShape || (() => this.newShape());
            this._phase = EToolShapeCreateLineConnectorPhase.OFF;
            this._work = new pixi_js.Point();
            this._onDownBound = (e) => {
                this.onDown(e);
            };
            this._onMoveBound = (e) => {
                this.onMove(e);
            };
            this._onUpBound = (e) => {
                this.onUp(e);
            };
            this._onKeyDownBound = (e) => {
                this.onKeyDown(e);
            };
            this._onSetBound = (canvas) => {
                this.onSet(canvas);
            };
            this._onUnsetBound = (canvas) => {
                this.onUnset(canvas);
            };
        }
        onActivate() {
            this._phase = EToolShapeCreateLineConnectorPhase.TAIL;
            const diagram = this._diagram;
            const layer = wcardinalUi.DApplications.getLayer(diagram);
            if (layer) {
                const interactionManager = layer.renderer.plugins.interaction;
                diagram.on(wcardinalUi.UtilPointerEvent.down, this._onDownBound);
                diagram.on(wcardinalUi.UtilPointerEvent.move, this._onMoveBound);
                const onUpBound = this._onUpBound;
                interactionManager.on(wcardinalUi.UtilPointerEvent.up, onUpBound);
                interactionManager.on(wcardinalUi.UtilPointerEvent.upoutside, onUpBound);
                interactionManager.on(wcardinalUi.UtilPointerEvent.cancel, onUpBound);
                diagram.on("keydown", this._onKeyDownBound);
                diagram.on("set", this._onSetBound);
                diagram.on("unset", this._onUnsetBound);
            }
            this._edge.begin(diagram.canvas, null);
            const selection = this._selection;
            selection.modifier.disallow();
            selection.updateModifier();
        }
        onDeactivate() {
            const diagram = this._diagram;
            const layer = wcardinalUi.DApplications.getLayer(diagram);
            if (layer) {
                const interactionManager = layer.renderer.plugins.interaction;
                diagram.off(wcardinalUi.UtilPointerEvent.down, this._onDownBound);
                diagram.off(wcardinalUi.UtilPointerEvent.move, this._onMoveBound);
                const onUpBound = this._onUpBound;
                interactionManager.off(wcardinalUi.UtilPointerEvent.up, onUpBound);
                interactionManager.off(wcardinalUi.UtilPointerEvent.upoutside, onUpBound);
                interactionManager.off(wcardinalUi.UtilPointerEvent.cancel, onUpBound);
                diagram.off("keydown", this._onKeyDownBound);
                diagram.off("set", this._onSetBound);
                diagram.off("unset", this._onUnsetBound);
            }
            this._edge.end();
            const selection = this._selection;
            selection.modifier.allow();
            selection.updateModifier();
            const connector = this._connector;
            if (connector != null) {
                this._connector = undefined;
                connector.detach();
                connector.destroy();
            }
            this._phase = EToolShapeCreateLineConnectorPhase.OFF;
        }
        onSet(canvas) {
            this._edge.begin(canvas, null);
        }
        onUnset(canvas) {
            this._edge.end();
            const connector = this._connector;
            if (connector != null) {
                this._connector = undefined;
                connector.detach();
                connector.destroy();
            }
            this._phase = EToolShapeCreateLineConnectorPhase.TAIL;
        }
        onDown(e) {
            const originalEvent = e.data.originalEvent;
            if (originalEvent.altKey) {
                return;
            }
            switch (this._phase) {
                case EToolShapeCreateLineConnectorPhase.OFF:
                    break;
                case EToolShapeCreateLineConnectorPhase.TAIL:
                    if (this.onTail(e)) {
                        this._phase = EToolShapeCreateLineConnectorPhase.HEAD;
                    }
                    break;
                case EToolShapeCreateLineConnectorPhase.HEAD:
                    if (this.onHead(e)) {
                        this._phase = EToolShapeCreateLineConnectorPhase.DONE;
                    }
                    break;
                case EToolShapeCreateLineConnectorPhase.DONE:
                    break;
            }
        }
        onMove(e) {
            const originalEvent = e.data.originalEvent;
            if (originalEvent.altKey) {
                return;
            }
            switch (this._phase) {
                case EToolShapeCreateLineConnectorPhase.OFF:
                    break;
                case EToolShapeCreateLineConnectorPhase.TAIL:
                    this.onTail(e);
                    break;
                case EToolShapeCreateLineConnectorPhase.HEAD:
                    this.onHead(e);
                    break;
                case EToolShapeCreateLineConnectorPhase.DONE:
                    break;
            }
        }
        onUp(e) {
            this.onDone();
        }
        onTail(e) {
            const diagram = this._diagram;
            const layer = diagram.layer;
            if (layer) {
                let connector = this._connector;
                const global = e.data.global;
                const local = layer.toLocal(global, undefined, this._work);
                const edge = this._edge.find(wcardinalUi.EShapeAcceptorEdgeType.TAIL, local.x, local.y);
                this._edge.update(wcardinalUi.EShapeAcceptorEdgeType.TAIL, local.x, local.y);
                if (this.isTailAccepted(connector, local, edge)) {
                    if (connector == null) {
                        connector = this._newShape();
                        connector.fill.alpha = 1;
                        this._connector = connector;
                        connector.attach(layer);
                    }
                    this.onTailAccepted(connector, local, edge);
                    wcardinalUi.DApplications.update(diagram);
                    return true;
                }
                else {
                    if (connector != null) {
                        this.onTailUnaccepted(connector, local);
                        wcardinalUi.DApplications.update(diagram);
                        return false;
                    }
                }
            }
            return false;
        }
        isDanglingEdgeAllowed() {
            var _a;
            return (_a = this._options.dangling) !== null && _a !== void 0 ? _a : false;
        }
        isTailAccepted(connector, local, edge) {
            if (edge == null) {
                return this.isDanglingEdgeAllowed();
            }
            else {
                return true;
            }
        }
        getTailType() {
            return wcardinalUi.EShapePointsMarkerType.CIRCLE;
        }
        onTailAccepted(connector, local, edge) {
            connector.points.marker.tail.type = this.getTailType();
            if (edge != null) {
                connector.edge.tail.set(edge.shape, edge.id, edge.x, edge.y, 0, edge.local.x, edge.local.y, undefined, undefined, edge.acceptor.side);
                connector.edge.head.local.copyFrom(edge.local);
            }
            else {
                connector.edge.tail.set(null, null, null, null, 0, local.x, local.y, undefined, undefined, wcardinalUi.EShapeAcceptorEdgeSide.TOP);
                connector.edge.head.local.copyFrom(local);
            }
        }
        onTailUnaccepted(connector, local) {
            connector.points.marker.tail.type = wcardinalUi.EShapePointsMarkerType.NONE;
            connector.edge.tail.set(null, null, null, null, 0, local.x, local.y, undefined, undefined, wcardinalUi.EShapeAcceptorEdgeSide.TOP);
            connector.edge.head.local.copyFrom(local);
        }
        newShape() {
            const result = new wcardinalUi.EShapeConnectorLine();
            result.fill.alpha = 1;
            return result;
        }
        onHead(e) {
            const diagram = this._diagram;
            const layer = diagram.layer;
            if (layer) {
                const connector = this._connector;
                if (connector) {
                    const global = e.data.global;
                    const local = layer.toLocal(global, undefined, this._work);
                    const edge = this._edge.find(wcardinalUi.EShapeAcceptorEdgeType.HEAD, local.x, local.y);
                    this._edge.update(wcardinalUi.EShapeAcceptorEdgeType.HEAD, local.x, local.y);
                    if (this.isHeadAccepted(connector, local, edge)) {
                        this.onHeadAccepted(connector, local, edge);
                        wcardinalUi.DApplications.update(diagram);
                        return true;
                    }
                    else {
                        this.onHeadUnaccepted(connector, local);
                        wcardinalUi.DApplications.update(diagram);
                        return false;
                    }
                }
            }
            return false;
        }
        isHeadAccepted(connector, local, edge) {
            if (edge == null) {
                return this.isDanglingEdgeAllowed();
            }
            else {
                return !this.isSameAcceptor(connector.edge.tail.acceptor, edge);
            }
        }
        isSameAcceptor(a, b) {
            return a.shape === b.shape && a.edge === b.id && a.x === b.x && a.y === b.y;
        }
        getHeadType() {
            return wcardinalUi.EShapePointsMarkerType.TRIANGLE;
        }
        onHeadAccepted(connector, local, edge) {
            connector.points.marker.head.type = this.getHeadType();
            if (edge != null) {
                connector.edge.head.set(edge.shape, edge.id, edge.x, edge.y, 10, edge.local.x, edge.local.y, undefined, undefined, edge.acceptor.side);
            }
            else {
                connector.edge.head.set(null, null, null, null, 10, local.x, local.y, undefined, undefined, wcardinalUi.EShapeAcceptorEdgeSide.TOP);
            }
        }
        onHeadUnaccepted(connector, local) {
            connector.points.marker.head.type = wcardinalUi.EShapePointsMarkerType.NONE;
            connector.edge.head.set(null, null, null, null, 0, local.x, local.y, undefined, undefined, wcardinalUi.EShapeAcceptorEdgeSide.TOP);
        }
        onDone() {
            if (this._phase === EToolShapeCreateLineConnectorPhase.DONE) {
                this._phase = EToolShapeCreateLineConnectorPhase.OFF;
                const connector = this._connector;
                if (connector) {
                    this._connector = undefined;
                    const diagram = this._diagram;
                    const layer = diagram.layer;
                    if (layer) {
                        connector.edge.attach();
                        wcardinalUi.DControllers.getCommandController().push(new ECommandShapeCreate([connector], layer, this._selection, true));
                    }
                    else {
                        connector.detach();
                        connector.destroy();
                    }
                    this.emit("done", this);
                }
            }
        }
        onCancel() {
            const connector = this._connector;
            if (connector != null) {
                this._connector = undefined;
                connector.detach();
                connector.destroy();
            }
            if (this._phase !== EToolShapeCreateLineConnectorPhase.OFF) {
                this._phase = EToolShapeCreateLineConnectorPhase.OFF;
                this.emit("cancel", this);
            }
        }
        onKeyDown(e) {
            if (wcardinalUi.UtilKeyboardEvent.isCancelKey(e)) {
                this.onCancel();
            }
        }
    }

    class EToolShapeCreateElbowConnector extends EToolShapeCreateLineConnector {
        newShape() {
            const result = new wcardinalUi.EShapeConnectorElbow();
            result.fill.alpha = 1;
            return result;
        }
    }

    class EToolShapeCreateLine extends EToolImpl {
        constructor(options) {
            super();
            this._options = options;
            this._selection = options.selection;
            this._diagram = options.diagram;
            this._isNewPoint = false;
            this._onDownPoint = new pixi_js.Point();
            this._onMovePoint = new pixi_js.Point();
            this._onDownBound = (e) => {
                this.onDown(e);
            };
            this._onMoveBound = (e) => {
                this.onMove(e);
            };
            this._onDblClickBound = () => {
                this.onDblClick();
            };
            this._onKeydownBound = (e) => {
                this.onKeydown(e);
            };
        }
        onActivate() {
            const diagram = this._diagram;
            diagram.on(wcardinalUi.UtilPointerEvent.down, this._onDownBound);
            diagram.on(wcardinalUi.UtilPointerEvent.move, this._onMoveBound);
            diagram.on("dblclick", this._onDblClickBound);
            diagram.on("keydown", this._onKeydownBound);
            const selection = this._selection;
            selection.modifier.disallow();
            selection.updateModifier();
        }
        onDeactivate() {
            const diagram = this._diagram;
            diagram.off(wcardinalUi.UtilPointerEvent.down, this._onDownBound);
            diagram.off(wcardinalUi.UtilPointerEvent.move, this._onMoveBound);
            diagram.off("dblclick", this._onDblClickBound);
            diagram.off("keydown", this._onKeydownBound);
            this.onCancel();
            const selection = this._selection;
            selection.modifier.allow();
            selection.updateModifier();
        }
        onDown(e) {
            const originalEvent = e.data.originalEvent;
            if (originalEvent.altKey) {
                return;
            }
            const diagram = this._diagram;
            const canvas = diagram.canvas;
            const layer = diagram.layer;
            if (canvas && layer) {
                this._isNewPoint = true;
                const line = this._line;
                if (line == null) {
                    const onDownPoint = this._onDownPoint;
                    canvas.toLocal(e.data.global, undefined, onDownPoint);
                    diagram.snapper.toSnapped(onDownPoint, onDownPoint);
                    layer.transform.localTransform.applyInverse(onDownPoint, onDownPoint);
                    const newLine = wcardinalUi.createLine([onDownPoint.x, onDownPoint.y], [], wcardinalUi.EShapeDefaults.STROKE_WIDTH, wcardinalUi.EShapePointsStyle.NONE);
                    newLine.attach(layer);
                    this._line = newLine;
                }
            }
        }
        onMove(e) {
            const originalEvent = e.data.originalEvent;
            if (originalEvent.altKey) {
                return;
            }
            const line = this._line;
            if (line) {
                const diagram = this._diagram;
                const canvas = diagram.canvas;
                if (canvas) {
                    const values = line.points.values;
                    if (this._isNewPoint) {
                        this._isNewPoint = false;
                        values.push(0, 0);
                    }
                    const onMovePoint = this._onMovePoint;
                    canvas.toLocal(e.data.global, undefined, onMovePoint);
                    diagram.snapper.toSnapped(onMovePoint, onMovePoint);
                    const parent = line.parent;
                    if (parent) {
                        parent.transform.localTransform.applyInverse(onMovePoint, onMovePoint);
                    }
                    const position = line.transform.position;
                    const x = onMovePoint.x - position.x;
                    const y = onMovePoint.y - position.y;
                    const length = values.length;
                    if (originalEvent.shiftKey && 4 <= length) {
                        const px = values[length - 4];
                        const py = values[length - 3];
                        const dx = x - px;
                        const dy = y - py;
                        const dangle = Math.PI * 0.25;
                        const angle = Math.round(Math.atan2(dy, dx) / dangle) * dangle;
                        const d = Math.sqrt(dx * dx + dy * dy) | 0;
                        values[length - 2] = px + d * Math.cos(angle);
                        values[length - 1] = py + d * Math.sin(angle);
                    }
                    else {
                        values[length - 2] = x | 0;
                        values[length - 1] = y | 0;
                    }
                    line.points.values = values;
                    wcardinalUi.DApplications.update(diagram);
                }
            }
        }
        toValues(line) {
            const position = line.transform.position;
            const px = position.x;
            const py = position.y;
            const values = line.points.values;
            const result = [];
            let prevx = NaN;
            let prevy = NaN;
            for (let i = 0, imax = values.length; i < imax; i += 2) {
                const x = values[i + 0];
                const y = values[i + 1];
                if (prevx !== x || prevy !== y) {
                    result.push(px + x, py + y);
                    prevx = x;
                    prevy = y;
                }
            }
            return result;
        }
        add(values) {
            const diagram = this._diagram;
            const layer = diagram.layer;
            if (layer && 4 <= values.length) {
                const newLine = wcardinalUi.createLine(values, [], wcardinalUi.EShapeDefaults.STROKE_WIDTH, wcardinalUi.EShapePointsStyle.NONE);
                newLine.attach(layer);
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapeCreate([newLine], layer, this._selection, true));
            }
        }
        onDblClick() {
            const line = this._line;
            if (line) {
                this._line = undefined;
                line.detach();
                this.add(this.toValues(line));
                wcardinalUi.DApplications.update(this._diagram);
                this.emit("done", this);
            }
        }
        onCancel() {
            const line = this._line;
            if (line) {
                line.points.values.length -= 2;
                this.onDblClick();
            }
        }
        onKeydown(e) {
            if (wcardinalUi.UtilKeyboardEvent.isCancelKey(e)) {
                this.onCancel();
            }
        }
    }

    class EToolShapeCreate extends EToolImpl {
        constructor(selection, diagram) {
            super();
            this._selection = selection;
            this._diagram = diagram;
            this._applicationLayer = null;
            this._onDownPoint = new pixi_js.Point();
            this._onMovePoint = new pixi_js.Point();
            this._shape = null;
            this._creator = undefined;
            this._onDownBound = (e) => {
                this.onDown(e);
            };
            this._onMoveBound = (e) => {
                this.onMove(e);
            };
            this._onUpBound = (e) => {
                this.onUp(e);
            };
        }
        get shape() {
            return this._creator;
        }
        set shape(creator) {
            this._creator = creator;
        }
        onActivate() {
            this._diagram.on(wcardinalUi.UtilPointerEvent.down, this._onDownBound);
        }
        onDeactivate() {
            this._diagram.off(wcardinalUi.UtilPointerEvent.down, this._onDownBound);
            this.onDone();
        }
        onDown(e) {
            const originalEvent = e.data.originalEvent;
            if (originalEvent.altKey) {
                return;
            }
            const selection = this._selection;
            const diagram = this._diagram;
            const diagramLayer = diagram.layer;
            const creator = this._creator;
            if (diagramLayer != null && creator != null && this._shape == null) {
                const onDownPoint = diagramLayer.toLocal(e.data.global, undefined, this._onDownPoint);
                diagram.snapper.toSnapped(onDownPoint, onDownPoint);
                this._onMovePoint.copyFrom(onDownPoint);
                const shape = (this._shape = creator());
                wcardinalUi.toResized(shape, onDownPoint, onDownPoint, originalEvent.ctrlKey, originalEvent.shiftKey);
                shape.attach(diagramLayer);
                selection.modifier.disallow();
                wcardinalUi.DControllers.getCommandController().push(new ECommandShapeCreate([shape], diagramLayer, this._selection, true));
                const oldApplicationLayer = this._applicationLayer;
                if (oldApplicationLayer) {
                    this._applicationLayer = null;
                    const oldInteractionManager = oldApplicationLayer.renderer.plugins.interaction;
                    oldInteractionManager.off(wcardinalUi.UtilPointerEvent.move, this._onMoveBound);
                    const onUpBound = this._onUpBound;
                    oldInteractionManager.off(wcardinalUi.UtilPointerEvent.up, onUpBound);
                    oldInteractionManager.off(wcardinalUi.UtilPointerEvent.upoutside, onUpBound);
                    oldInteractionManager.off(wcardinalUi.UtilPointerEvent.cancel, onUpBound);
                }
                const newApplicationLayer = wcardinalUi.DApplications.getLayer(diagram);
                if (newApplicationLayer) {
                    this._applicationLayer = newApplicationLayer;
                    const newInteractionManager = newApplicationLayer.renderer.plugins.interaction;
                    newInteractionManager.on(wcardinalUi.UtilPointerEvent.move, this._onMoveBound);
                    const onUpBound = this._onUpBound;
                    newInteractionManager.on(wcardinalUi.UtilPointerEvent.up, onUpBound);
                    newInteractionManager.on(wcardinalUi.UtilPointerEvent.upoutside, onUpBound);
                    newInteractionManager.on(wcardinalUi.UtilPointerEvent.cancel, onUpBound);
                }
            }
        }
        onMove(e) {
            const originalEvent = e.data.originalEvent;
            if (originalEvent.altKey) {
                return;
            }
            const shape = this._shape;
            if (shape) {
                const diagram = this._diagram;
                const diagramLayer = diagram.layer;
                const selection = this._selection;
                const applicationLayer = this._applicationLayer;
                if (diagramLayer && applicationLayer) {
                    applicationLayer.lock();
                    const onDownPoint = this._onDownPoint;
                    const onMovePoint = diagramLayer.toLocal(e.data.global, undefined, this._onMovePoint);
                    diagram.snapper.toSnapped(onMovePoint, onMovePoint);
                    wcardinalUi.toResized(shape, onDownPoint, onMovePoint, originalEvent.ctrlKey, originalEvent.shiftKey);
                    selection.update("PROPERTY");
                    applicationLayer.unlock();
                    applicationLayer.update();
                }
            }
        }
        onUp(e) {
            this.onDone();
        }
        onDone() {
            const shape = this._shape;
            if (shape) {
                this._shape = null;
                const selection = this._selection;
                const onDownPoint = this._onDownPoint;
                const onMovePoint = this._onMovePoint;
                const applicationLayer = this._applicationLayer;
                if (applicationLayer) {
                    this._applicationLayer = null;
                    const interactionManager = applicationLayer.renderer.plugins.interaction;
                    interactionManager.off(wcardinalUi.UtilPointerEvent.move, this._onMoveBound);
                    const onUpBound = this._onUpBound;
                    interactionManager.off(wcardinalUi.UtilPointerEvent.up, onUpBound);
                    interactionManager.off(wcardinalUi.UtilPointerEvent.upoutside, onUpBound);
                    interactionManager.off(wcardinalUi.UtilPointerEvent.cancel, onUpBound);
                    applicationLayer.lock();
                    if (onDownPoint.x === onMovePoint.x && onDownPoint.y === onMovePoint.y) {
                        onMovePoint.set(onDownPoint.x + 100, onDownPoint.y + 100);
                        wcardinalUi.toResized(shape, onDownPoint, onMovePoint, false, false);
                    }
                    selection.modifier.allow();
                    selection.update("PROPERTY");
                    applicationLayer.unlock();
                    applicationLayer.update();
                }
                this.emit("done", this);
            }
        }
    }

    class EToolShapeEditLineHitArea extends pixi_js.Rectangle {
        constructor(parent) {
            super();
            this._parent = parent;
            this._capability = wcardinalUi.EShapeCapability.LINE_TAIL | wcardinalUi.EShapeCapability.LINE_HEAD;
        }
        get capability() {
            return this._capability;
        }
        set capability(capability) {
            this._capability = capability;
        }
        contains(x, y) {
            const parent = this._parent;
            if (parent.isEditing()) {
                return true;
            }
            const points = parent.points;
            const pointsClosed = parent.closed;
            const capability = this._capability;
            const hasTail = !!(capability & wcardinalUi.EShapeCapability.LINE_TAIL);
            const hasHead = !!(capability & wcardinalUi.EShapeCapability.LINE_HEAD);
            // Anchors
            const s = parent.getAnchorSize() * 2;
            const thresholdLine = s * s;
            const thresholdAnchor = thresholdLine * 2;
            for (let i = hasTail ? 0 : 1, imax = points.length - (hasHead ? 0 : 1); i < imax; ++i) {
                const point = points[i];
                const dx = point.x - x;
                const dy = point.y - y;
                const d = dx * dx + dy * dy;
                if (d < thresholdAnchor) {
                    parent.setLastHitAnchor(i);
                    return true;
                }
            }
            // Lines
            for (let i = 0, imax = points.length - 1; i < imax; ++i) {
                const p0 = points[i + 0];
                const p1 = points[i + 1];
                const hitPoint = this.calcHitPoint(x, y, p0.x, p0.y, p1.x, p1.y, thresholdLine);
                if (0 <= hitPoint) {
                    parent.setLastHitSegment(i, hitPoint);
                    return true;
                }
            }
            if (hasTail && hasHead && pointsClosed) {
                const p0 = points[points.length - 1];
                const p1 = points[0];
                const hitPoint = this.calcHitPoint(x, y, p0.x, p0.y, p1.x, p1.y, thresholdLine);
                if (0 <= hitPoint) {
                    parent.setLastHitSegment(points.length - 1, hitPoint);
                    return true;
                }
            }
            parent.setLastHitSegment(-1, -1);
            return false;
        }
        calcHitPoint(x, y, p0x, p0y, p1x, p1y, threshold) {
            const d0x = p1x - p0x;
            const d0y = p1y - p0y;
            const d1x = x - p0x;
            const d1y = y - p0y;
            const a = d0x * d0x + d0y * d0y;
            const b = d0x * d1x + d0y * d1y;
            const c = d1x * d1x + d1y * d1y;
            if (0.0001 < a) {
                const t = Math.max(0, Math.min(1, b / a));
                const d = a * t * t - 2 * b * t + c;
                if (d < threshold) {
                    return t;
                }
            }
            return -1;
        }
    }

    class EToolShapeEditLineBase extends pixi_js.Graphics {
        constructor(options) {
            super();
            this._options = options;
            this._selection = options.selection;
            this._diagram = options.diagram;
            this._onDownPoint = new pixi_js.Point();
            this._points = [];
            this._pointsStyle = wcardinalUi.EShapePointsStyle.NONE;
            this._onMovePoint = new pixi_js.Point();
            this._isEditing = false;
            this._isEdited = false;
            this._isActive = false;
            this._shape = null;
            this._capability = wcardinalUi.EShapeCapability.LINE_TAIL | wcardinalUi.EShapeCapability.LINE_HEAD;
            this._scaleBound = 1;
            this._scaleBoundInverse = 1;
            this._lastHitAnchor = -1;
            this._lastHitSegment = -1;
            this._lastHitSegmentPosition = -1;
            this._targetCopy = new pixi_js.Point();
            this._target = null;
            this._targetIndex = -1;
            this._onDownBound = (e) => {
                this.onDown(e);
            };
            this._onMoveBound = (e) => {
                this.onMove(e);
            };
            this._onUpBound = (e) => {
                this.onUp(e);
            };
            this._onKeydownBound = (e) => {
                this.onKeydown(e);
            };
            this._onSetBound = (canvas) => {
                this.onSet(canvas);
            };
            this._onUnsetBound = (canvas) => {
                this.onUnset(canvas);
            };
            this.cursor = "grab";
            this.interactive = true;
            this.hitArea = new EToolShapeEditLineHitArea(this);
            this._unformatted = {
                length: 0,
                plength: 0,
                values: [],
                segments: [],
                style: wcardinalUi.EShapePointsStyle.NONE
            };
            this._formatted = {
                length: 0,
                plength: 0,
                values: [],
                segments: [],
                style: wcardinalUi.EShapePointsStyle.NONE
            };
        }
        onPrerender() {
            const scale0 = this.getParentScale();
            const scale1 = this._scaleBound;
            if (0.001 < Math.abs(scale0 - scale1)) {
                this._scaleBound = scale0;
                this._scaleBoundInverse = 1 / scale0;
                this.reshape();
            }
        }
        getParentScale() {
            const parent = this.parent;
            return parent != null ? parent.scale.y : 1;
        }
        render(renderer) {
            this.onPrerender();
            super.render(renderer);
        }
        getAnchorSize() {
            return 6 * this._scaleBoundInverse;
        }
        activate() {
            if (!this._isActive) {
                this._isActive = true;
                this.onActivate();
            }
        }
        onActivate() {
            this._isEditing = false;
            this._isEdited = false;
            this._target = null;
            this._targetIndex = -1;
            const diagram = this._diagram;
            const layer = wcardinalUi.DApplications.getLayer(diagram);
            if (layer) {
                const interactionManager = layer.renderer.plugins.interaction;
                diagram.on(wcardinalUi.UtilPointerEvent.down, this._onDownBound);
                interactionManager.on(wcardinalUi.UtilPointerEvent.move, this._onMoveBound);
                const onUpBound = this._onUpBound;
                interactionManager.on(wcardinalUi.UtilPointerEvent.up, onUpBound);
                interactionManager.on(wcardinalUi.UtilPointerEvent.upoutside, onUpBound);
                interactionManager.on(wcardinalUi.UtilPointerEvent.cancel, onUpBound);
                diagram.on("keydown", this._onKeydownBound);
                diagram.on("set", this._onSetBound);
                diagram.on("unset", this._onUnsetBound);
            }
            const selection = this._selection;
            selection.modifier.disallow();
            selection.updateModifier();
        }
        deactivate() {
            if (this._isActive) {
                this._isActive = false;
                this.onDeactivate();
            }
        }
        onDeactivate() {
            this._isEditing = false;
            this._isEdited = false;
            this._target = null;
            this._targetIndex = -1;
            this.shape = null;
            const diagram = this._diagram;
            const layer = wcardinalUi.DApplications.getLayer(diagram);
            if (layer) {
                const interactionManager = layer.renderer.plugins.interaction;
                diagram.off(wcardinalUi.UtilPointerEvent.down, this._onDownBound);
                interactionManager.off(wcardinalUi.UtilPointerEvent.move, this._onMoveBound);
                const onUpBound = this._onUpBound;
                interactionManager.off(wcardinalUi.UtilPointerEvent.up, onUpBound);
                interactionManager.off(wcardinalUi.UtilPointerEvent.upoutside, onUpBound);
                interactionManager.off(wcardinalUi.UtilPointerEvent.cancel, onUpBound);
                diagram.off("keydown", this._onKeydownBound);
                diagram.off("set", this._onSetBound);
                diagram.off("unset", this._onUnsetBound);
            }
            const selection = this._selection;
            selection.modifier.allow();
            selection.updateModifier();
        }
        onSet(canvas) {
            // DO NOTHING
        }
        onUnset(canvas) {
            this.onCancel();
        }
        isActive() {
            return this._isActive;
        }
        isEditing() {
            return this._isEditing;
        }
        get points() {
            return this._points;
        }
        get closed() {
            return (this._pointsStyle & wcardinalUi.EShapePointsStyle.CLOSED) !== 0;
        }
        get shape() {
            return this._shape;
        }
        set shape(shape) {
            var _a, _b;
            if (this._shape !== shape) {
                this._shape = shape;
                const capability = this.toCapability(shape);
                this.hitArea.capability = capability;
                this._capability = capability;
                this._isEdited = false;
                if (shape == null) {
                    this._points = [];
                    this._pointsStyle = wcardinalUi.EShapePointsStyle.NONE;
                    this._formatter = undefined;
                    const parent = this.parent;
                    if (parent) {
                        parent.removeChild(this);
                        wcardinalUi.DApplications.update(this);
                    }
                }
                else {
                    const points = shape.points;
                    if (points) {
                        shape.updateTransform();
                        this._points = this.toPoints(shape, points, this.toTransform(shape));
                        const pointsStyle = points.style;
                        this._pointsStyle = pointsStyle;
                        this._formatter =
                            (_a = points.formatter) !== null && _a !== void 0 ? _a : (_b = wcardinalUi.EShapePointsFormatters.find(pointsStyle)) === null || _b === void 0 ? void 0 : _b.formatter;
                    }
                    else {
                        this._points = [];
                        this._pointsStyle = wcardinalUi.EShapePointsStyle.NONE;
                        this._formatter = undefined;
                    }
                    this.reshape();
                    const canvas = this._diagram.canvas;
                    if (canvas) {
                        canvas.addChild(this);
                    }
                }
            }
        }
        toTransform(shape) {
            var _a;
            const result = ((_a = this._workTransform) !== null && _a !== void 0 ? _a : (this._workTransform = new pixi_js.Matrix()));
            result.copyFrom(shape.transform.internalTransform);
            // If the layer this shape belongs to has a non-zero position,
            // we have to take that into consideration.
            const parent = shape.root.parent;
            if (parent) {
                result.prepend(parent.transform.localTransform);
            }
            return result;
        }
        toPoints(shape, points, transform) {
            const result = [];
            const values = points.values;
            for (let i = 0, imax = values.length; i < imax; i += 2) {
                const point = new pixi_js.Point(values[i + 0], values[i + 1]);
                result.push(transform.apply(point, point));
            }
            return result;
        }
        setLastHitAnchor(index) {
            if (this._lastHitAnchor !== index || this._lastHitSegment !== -1) {
                this._lastHitAnchor = index;
                this._lastHitSegment = -1;
                this._lastHitSegmentPosition = -1;
                this.reshape();
                wcardinalUi.DApplications.update(this);
            }
        }
        setLastHitSegment(index, position) {
            this._lastHitSegmentPosition = position;
            if (this._lastHitAnchor !== -1 || this._lastHitSegment !== index) {
                this._lastHitAnchor = -1;
                this._lastHitSegment = index;
                this.reshape();
                wcardinalUi.DApplications.update(this);
            }
        }
        reshape() {
            const graphics = this;
            const points = this._points;
            const pointsLength = points.length;
            const pointsStyle = this._pointsStyle;
            const formatter = this._formatter;
            const pointsClosed = !!(pointsStyle & wcardinalUi.EShapePointsStyle.CLOSED);
            const capability = this._capability;
            const hasTail = !!(capability & wcardinalUi.EShapeCapability.LINE_TAIL);
            const hasHead = !!(capability & wcardinalUi.EShapeCapability.LINE_HEAD);
            graphics.clear();
            if (0 < pointsLength) {
                const s = this.getAnchorSize();
                const hs = s * 0.5;
                const color = 0x1e87f0;
                const colorHit = 0xf36f27;
                const colorFormatted = 0xaaaaaa;
                const alpha = 1;
                const alphaFormatted = 0.5;
                const anchor = this._lastHitAnchor;
                const segment = this._lastHitSegment;
                // Formatted
                if (formatter != null) {
                    const unformatted = this._unformatted;
                    const uvalues = unformatted.values;
                    const usegments = unformatted.segments;
                    for (let i = 0, j = 0; i < pointsLength; i += 1, j += 2) {
                        const point = points[i];
                        uvalues[j] = point.x;
                        uvalues[j + 1] = point.y;
                    }
                    const formatted = this._formatted;
                    formatter(pointsLength, uvalues, usegments, pointsStyle, formatted);
                    const fvalues = formatted.values;
                    graphics.lineStyle(hs, colorFormatted, alphaFormatted);
                    if (0 < fvalues.length) {
                        graphics.moveTo(fvalues[0], fvalues[1]);
                        for (let i = 2, imax = fvalues.length; i < imax; i += 2) {
                            graphics.lineTo(fvalues[i], fvalues[i + 1]);
                        }
                    }
                }
                // Line
                for (let i = 0, imax = pointsLength - 1; i < imax; ++i) {
                    const p0 = points[i];
                    const p1 = points[i + 1];
                    const c = segment === i ? colorHit : color;
                    graphics.lineStyle(hs, c, alpha);
                    graphics.moveTo(p0.x, p0.y);
                    graphics.lineTo(p1.x, p1.y);
                }
                if (hasTail && hasHead && pointsClosed) {
                    const i = points.length - 1;
                    const p0 = points[i];
                    const p1 = points[0];
                    const c = segment === i ? colorHit : color;
                    graphics.lineStyle(hs, c, alpha);
                    graphics.moveTo(p0.x, p0.y);
                    graphics.lineTo(p1.x, p1.y);
                }
                // Anchors
                const targetIndex = this._targetIndex;
                for (let i = hasTail ? 0 : 1, imax = pointsLength - (hasHead ? 0 : 1); i < imax; ++i) {
                    const point = points[i];
                    const c = anchor === i || targetIndex === i ? colorHit : color;
                    graphics.lineStyle(hs, c, alpha);
                    graphics.beginFill(c, alpha);
                    graphics.drawRect(point.x - hs, point.y - hs, s, s);
                    graphics.endFill();
                }
            }
        }
        replace() {
            const oldShape = this._shape;
            const points = this._points;
            if (oldShape && oldShape.parent && 2 <= points.length) {
                const values = this.toValues(points, oldShape);
                if (2 < values.length) {
                    const newShape = this.newShape(values, [], this._pointsStyle, oldShape);
                    wcardinalUi.DControllers.getCommandController().push(new ECommandShapeReplaceOne(newShape, oldShape, oldShape.parent, this._selection));
                }
            }
        }
        toValues(points, shape) {
            shape.updateTransform();
            const transform = this.toTransform(shape).invert();
            const result = [];
            const a = transform.a;
            const b = transform.b;
            const c = transform.c;
            const d = transform.d;
            const tx = transform.tx;
            const ty = transform.ty;
            let pprevx = NaN;
            let pprevy = NaN;
            for (let i = 0, imax = points.length; i < imax; ++i) {
                const point = points[i];
                const px = point.x;
                const py = point.y;
                if (pprevx !== px || pprevy !== py) {
                    const x = a * px + c * py + tx;
                    const y = b * px + d * py + ty;
                    result.push(x, y);
                    pprevx = x;
                    pprevy = y;
                }
            }
            return result;
        }
        onDown(e) {
            if (e.target === this) {
                const originalEvent = e.data.originalEvent;
                if (originalEvent.altKey) {
                    return;
                }
                const diagram = this._diagram;
                const canvas = diagram.canvas;
                if (canvas != null && !this._isEditing) {
                    const lastHitAnchor = this._lastHitAnchor;
                    const points = this._points;
                    const onDownPoint = this._onDownPoint;
                    if (0 <= lastHitAnchor && lastHitAnchor < points.length) {
                        this._isEditing = true;
                        canvas.toLocal(e.data.global, undefined, onDownPoint);
                        this._target = points[lastHitAnchor];
                        this._targetCopy.copyFrom(this._target);
                        this._targetIndex = lastHitAnchor;
                        this.onTargetChange(lastHitAnchor, onDownPoint);
                        this.reshape();
                        wcardinalUi.DApplications.update(this);
                    }
                    else {
                        const lastHitSegment = this._lastHitSegment;
                        if (0 <= lastHitSegment) {
                            this._lastHitSegment = -1;
                            this._isEditing = true;
                            canvas.toLocal(e.data.global, undefined, onDownPoint);
                            const p0 = points[lastHitSegment + 0];
                            const p1 = points[lastHitSegment < points.length - 1 ? lastHitSegment + 1 : 0];
                            const t = this._lastHitSegmentPosition;
                            const ti = 1 - t;
                            const x = ti * p0.x + t * p1.x;
                            const y = ti * p0.y + t * p1.y;
                            const point = new pixi_js.Point(x, y);
                            points.splice(lastHitSegment + 1, 0, point);
                            this._target = point;
                            this._targetCopy.copyFrom(point);
                            this._targetIndex = lastHitSegment + 1;
                            this.onTargetChange(this._targetIndex, onDownPoint);
                            this.reshape();
                            wcardinalUi.DApplications.update(this);
                        }
                    }
                }
            }
            else {
                this.onDone();
            }
        }
        onTargetChange(targetIndex, point) {
            // DO NOTHING
        }
        onMove(e) {
            if (this._isEditing) {
                const originalEvent = e.data.originalEvent;
                if (originalEvent.altKey) {
                    return;
                }
                const diagram = this._diagram;
                const canvas = diagram.canvas;
                const target = this._target;
                const targetCopy = this._targetCopy;
                if (canvas && target) {
                    this._isEdited = true;
                    const onDownPoint = this._onDownPoint;
                    const onMovePoint = canvas.toLocal(e.data.global, undefined, this._onMovePoint);
                    target.set(targetCopy.x + onMovePoint.x - onDownPoint.x, targetCopy.y + onMovePoint.y - onDownPoint.y);
                    this.toSnapped(target, diagram, target);
                    if (originalEvent.shiftKey) {
                        const points = this._points;
                        const targetIndex = this._targetIndex;
                        const previousIndex = 0 < targetIndex ? targetIndex - 1 : targetIndex + 1;
                        if (0 <= previousIndex && previousIndex < points.length) {
                            const previous = points[previousIndex];
                            const dx = target.x - previous.x;
                            const dy = target.y - previous.y;
                            const dangle = Math.PI * 0.25;
                            const angle = Math.round(Math.atan2(dy, dx) / dangle) * dangle;
                            const d = Math.sqrt(dx * dx + dy * dy);
                            target.set(previous.x + d * Math.cos(angle), previous.y + d * Math.sin(angle));
                        }
                    }
                    this.onTargetMove(onMovePoint);
                    this.reshape();
                    wcardinalUi.DApplications.update(this);
                }
            }
            else {
                this.onTargetNotMove(e);
            }
        }
        onTargetMove(point) {
            // DO NOTHING
        }
        onTargetNotMove(e) {
            // DO NOTHING
        }
        toSnapped(target, diagram, result) {
            diagram.snapper.toSnapped(target, result);
        }
        onUp(e) {
            if (this._isEditing) {
                this._isEditing = false;
                this._target = null;
            }
        }
        onDone() {
            this._isEditing = false;
            if (this._isEdited) {
                this._isEdited = false;
                this.replace();
            }
            this.emit("done", this);
        }
        onCancel() {
            this._isEditing = false;
            this._isEdited = false;
            const parent = this.parent;
            if (parent) {
                parent.removeChild(this);
                wcardinalUi.DApplications.update(this);
            }
            this.emit("cancel", this);
        }
        onKeydown(e) {
            if (wcardinalUi.UtilKeyboardEvent.isCancelKey(e)) {
                this.onDone();
            }
            else if (wcardinalUi.UtilKeyboardEvent.isDeleteKey(e)) {
                const targetIndex = this._targetIndex;
                const points = this._points;
                if (0 <= targetIndex && targetIndex < points.length && 2 < points.length) {
                    this._isEdited = true;
                    points.splice(targetIndex, 1);
                    if (targetIndex === points.length) {
                        this._targetIndex -= 1;
                        this.onTargetChange(this._targetIndex, null);
                    }
                    this.reshape();
                    wcardinalUi.DApplications.update(this);
                }
            }
        }
    }

    class EToolShapeEditLineConnector extends EToolShapeEditLineBase {
        constructor(options) {
            super(options);
            this._edge = new EToolShapeAcceptorEdge(this._diagram, true);
            this._work = new pixi_js.Point();
        }
        toCapability(shape) {
            let result = wcardinalUi.EShapeCapability.NONE;
            if (wcardinalUi.EShapeCapabilities.contains(shape, wcardinalUi.EShapeCapability.LINE_TAIL)) {
                result |= wcardinalUi.EShapeCapability.LINE_TAIL;
            }
            if (wcardinalUi.EShapeCapabilities.contains(shape, wcardinalUi.EShapeCapability.LINE_HEAD)) {
                result |= wcardinalUi.EShapeCapability.LINE_HEAD;
            }
            return result;
        }
        onActivate() {
            this._edge.begin(this._diagram.canvas, this._shape);
            this._edgeTail = undefined;
            this._edgeHead = undefined;
            super.onActivate();
        }
        onDeactivate() {
            this._edge.end();
            this._edgeTail = undefined;
            this._edgeHead = undefined;
            super.onDeactivate();
        }
        onTargetChange(targetIndex, point) {
            if (targetIndex === 0) {
                const edge = this._edge;
                edge.show();
                if (point != null) {
                    edge.update(wcardinalUi.EShapeAcceptorEdgeType.TAIL, point.x, point.y);
                }
            }
            else if (targetIndex === this._points.length - 1) {
                const edge = this._edge;
                edge.show();
                if (point != null) {
                    edge.update(wcardinalUi.EShapeAcceptorEdgeType.HEAD, point.x, point.y);
                }
            }
            else {
                this._edge.hide();
            }
        }
        onTargetMove(point) {
            const targetIndex = this._targetIndex;
            if (targetIndex === 0) {
                this._edge.update(wcardinalUi.EShapeAcceptorEdgeType.TAIL, point.x, point.y);
            }
            else if (targetIndex === this._points.length - 1) {
                this._edge.update(wcardinalUi.EShapeAcceptorEdgeType.HEAD, point.x, point.y);
            }
        }
        onTargetNotMove(e) {
            const targetIndex = this._targetIndex;
            if (targetIndex === 0) {
                const canvas = this._diagram.canvas;
                if (canvas) {
                    const onMovePoint = canvas.toLocal(e.data.global, undefined, this._onMovePoint);
                    this._edge.update(wcardinalUi.EShapeAcceptorEdgeType.TAIL, onMovePoint.x, onMovePoint.y);
                }
            }
            else if (targetIndex === this._points.length - 1) {
                const canvas = this._diagram.canvas;
                if (canvas) {
                    const onMovePoint = canvas.toLocal(e.data.global, undefined, this._onMovePoint);
                    this._edge.update(wcardinalUi.EShapeAcceptorEdgeType.HEAD, onMovePoint.x, onMovePoint.y);
                }
            }
        }
        toSnapped(target, diagram, result) {
            const targetIndex = this._targetIndex;
            if (targetIndex === 0) {
                const edge = this._edge.find(wcardinalUi.EShapeAcceptorEdgeType.TAIL, target.x, target.y);
                if (edge != null) {
                    result.copyFrom(edge.local);
                }
                this._edgeTail = edge;
            }
            else {
                const points = this._points;
                const pointsLength = points.length;
                if (targetIndex === pointsLength - 1) {
                    const edge = this._edge.find(wcardinalUi.EShapeAcceptorEdgeType.HEAD, target.x, target.y);
                    if (edge != null) {
                        result.copyFrom(edge.local);
                    }
                    this._edgeHead = edge;
                }
                else {
                    diagram.snapper.toSnapped(target, result);
                }
            }
        }
        toPoints(shape, points, transform) {
            const result = [];
            if (shape instanceof wcardinalUi.EShapeConnectorLine) {
                const edge = shape.edge;
                const tailLocal = edge.tail.local;
                const headLocal = edge.head.local;
                const transformPosition = shape.transform.position;
                const px = transformPosition.x;
                const py = transformPosition.y;
                const x0 = tailLocal.x - px;
                const y0 = tailLocal.y - py;
                const x1 = headLocal.x - px;
                const y1 = headLocal.y - py;
                const tailPoint = new pixi_js.Point(x0, y0);
                result.push(transform.apply(tailPoint, tailPoint));
                const bodyValues = shape.body.values;
                const bodyValuesLength = bodyValues.length;
                if (0 < bodyValuesLength) {
                    const cx = (x1 + x0) * 0.5;
                    const cy = (y1 + y0) * 0.5;
                    const dx = x1 - x0;
                    const dy = y1 - y0;
                    const a = Math.atan2(dy, dx);
                    const l = Math.sqrt(dx * dx + dy * dy);
                    const c = Math.cos(a) * l;
                    const s = Math.sin(a) * l;
                    for (let i = 0; i < bodyValuesLength; i += 2) {
                        const x = bodyValues[i + 0];
                        const y = bodyValues[i + 1];
                        const x2 = cx + c * x - s * y;
                        const y2 = cy + c * y + s * x;
                        const middlePoint = new pixi_js.Point(x2, y2);
                        result.push(transform.apply(middlePoint, middlePoint));
                    }
                }
                const headPoint = new pixi_js.Point(x1, y1);
                result.push(transform.apply(headPoint, headPoint));
            }
            return result;
        }
        newShape(values, segments, style, oldShape) {
            const boundary = wcardinalUi.toPointsBoundary(values, [0, 0, 0, 0]);
            const cx = (boundary[2] + boundary[0]) * 0.5;
            const cy = (boundary[3] + boundary[1]) * 0.5;
            const sx = boundary[2] - boundary[0];
            const sy = boundary[3] - boundary[1];
            const result = oldShape.clone();
            const transform = result.transform;
            const transformPosition = transform.position;
            const px = transformPosition.x;
            const py = transformPosition.y;
            result.lock(wcardinalUi.EShapeLockPart.UPLOADED);
            transformPosition.set(px + cx, py + cy);
            transform.scale.set(1, 1);
            transform.rotation = 0;
            transform.skew.set(0, 0);
            result.points.toFitted(sx, sy);
            result.size.set(sx, sy);
            result.edge.lock();
            result.body.set(wcardinalUi.EShapeConnectorBodies.from(values, 0, 0));
            const local = this._work;
            if (2 <= values.length) {
                local.set(px + values[0], py + values[1]);
            }
            else {
                local.set(px, py);
            }
            const edgeTail = this._edgeTail;
            if (edgeTail !== undefined) {
                if (this.isTailAccepted(result, local, edgeTail)) {
                    this.onTailAccepted(result, local, edgeTail);
                }
            }
            if (2 <= values.length) {
                const valuesLength = values.length;
                local.set(px + values[valuesLength - 2], py + values[valuesLength - 1]);
            }
            else {
                local.set(px, py);
            }
            const edgeHead = this._edgeHead;
            if (edgeHead !== undefined) {
                if (this.isHeadAccepted(result, local, edgeHead)) {
                    this.onHeadAccepted(result, local, edgeHead);
                }
            }
            result.edge.unlock();
            result.unlock(wcardinalUi.EShapeLockPart.UPLOADED, true);
            return result;
        }
        isDanglingEdgeAllowed() {
            var _a;
            return (_a = this._options.dangling) !== null && _a !== void 0 ? _a : false;
        }
        isTailAccepted(connector, local, edge) {
            if (edge == null) {
                return this.isDanglingEdgeAllowed();
            }
            else {
                return true;
            }
        }
        onTailAccepted(connector, local, edge) {
            if (edge != null) {
                connector.edge.tail.set(edge.shape, edge.id, edge.x, edge.y, undefined, undefined, undefined, undefined, undefined, edge.acceptor.side);
            }
            else {
                connector.edge.tail.set(null, null, null, null, undefined, local.x, local.y, undefined, undefined, wcardinalUi.EShapeAcceptorEdgeSide.TOP);
            }
        }
        isHeadAccepted(connector, local, edge) {
            if (edge == null) {
                return this.isDanglingEdgeAllowed();
            }
            else {
                return true;
            }
        }
        onHeadAccepted(connector, local, edge) {
            if (edge != null) {
                connector.edge.head.set(edge.shape, edge.id, edge.x, edge.y, undefined, undefined, undefined, undefined, undefined, edge.acceptor.side);
            }
            else {
                connector.edge.head.set(null, null, null, null, undefined, local.x, local.y, undefined, undefined, wcardinalUi.EShapeAcceptorEdgeSide.TOP);
            }
        }
    }

    class EToolShapeEditLine extends EToolShapeEditLineBase {
        constructor(options) {
            super(options);
        }
        toCapability(shape) {
            return wcardinalUi.EShapeCapability.LINE_TAIL | wcardinalUi.EShapeCapability.LINE_HEAD;
        }
        newShape(values, segments, style, oldShape) {
            const boundary = wcardinalUi.toPointsBoundary(values, [0, 0, 0, 0]);
            const cx = (boundary[2] + boundary[0]) * 0.5;
            const cy = (boundary[3] + boundary[1]) * 0.5;
            const sx = boundary[2] - boundary[0];
            const sy = boundary[3] - boundary[1];
            const result = oldShape.clone();
            const transform = result.transform;
            const transformPosition = transform.position;
            const px = transformPosition.x;
            const py = transformPosition.y;
            const localTransform = oldShape.transform.localTransform;
            const dx = localTransform.a * cx + localTransform.c * cy;
            const dy = localTransform.b * cx + localTransform.d * cy;
            const newValues = [];
            for (let i = 0, imax = values.length; i < imax; i += 2) {
                newValues.push(values[i + 0] - cx, values[i + 1] - cy);
            }
            result.lock(wcardinalUi.EShapeLockPart.UPLOADED);
            result.transform.position.set(px + dx, py + dy);
            result.size.set(sx, sy);
            const points = result.points;
            if (points) {
                points.set(newValues, segments, style);
            }
            result.unlock(wcardinalUi.EShapeLockPart.UPLOADED, true);
            return result;
        }
    }

    /*
     * Copyright (C) 2021 Toshiba Corporation
     * SPDX-License-Identifier: Apache-2.0
     */
    const UtilAjax = {
        send(method, settings) {
            let isCompleted = false;
            const makeOnError = (reason) => {
                return () => {
                    if (!isCompleted) {
                        isCompleted = true;
                        settings.error(reason, xhr);
                    }
                };
            };
            const xhr = new XMLHttpRequest();
            xhr.open(method, settings.url, true);
            xhr.onload = () => {
                if (!isCompleted) {
                    isCompleted = true;
                    const status = xhr.status;
                    if ((200 <= status && status < 300) ||
                        status === 0 ||
                        status === 304 ||
                        status === 1223) {
                        settings.success(xhr.responseText, xhr);
                    }
                    else {
                        settings.error(xhr.statusText, xhr);
                    }
                }
            };
            const onError = makeOnError("error");
            xhr.onerror = onError;
            xhr.onabort = makeOnError("abort");
            // Headers
            const headers = settings.headers;
            if (headers != null) {
                for (const name in headers) {
                    const header = headers[name];
                    if (header != null) {
                        xhr.setRequestHeader(name, header);
                    }
                }
            }
            xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
            // Timeout
            const timeout = settings.timeout;
            if (timeout != null) {
                xhr.timeout = timeout;
                xhr.ontimeout = makeOnError("timeout");
                if (0 < timeout) {
                    // For browsers which do not support the `timeout`
                    setTimeout(() => {
                        xhr.abort();
                    }, timeout);
                }
            }
            // Send
            try {
                const data = settings.data;
                if (data != null) {
                    xhr.send(data);
                }
                else {
                    xhr.send();
                }
            }
            catch (_a) {
                onError();
            }
        }
    };

    class UtilCanvasCategory {
        constructor(options) {
            this._options = options;
        }
        get() {
            var _a;
            return ((_a = this._promise) !== null && _a !== void 0 ? _a : (this._promise = this.fetch()));
        }
        fetch() {
            return Promise.all([this.doFetch()]).then((resolveds) => {
                const resolved = resolveds[0];
                return this.toFetched(resolved);
            });
        }
        doFetch() {
            const options = this._options;
            if (wcardinalUi.isFunction(options)) {
                return options();
            }
            else {
                return options;
            }
        }
        toFetched(options) {
            const theme = wcardinalUi.DThemes.get("EEditorCanvas");
            if (options != null) {
                const items = this.toItems(theme, options);
                return {
                    default: this.toDefault(items, theme, options),
                    items,
                    writable: this.toWritable(theme, options)
                };
            }
            return {
                default: theme.getDefaultCategory(),
                items: [],
                writable: theme.isCategoryWritable()
            };
        }
        toItems(theme, options) {
            const result = [];
            const items = options.items;
            if (items != null) {
                for (let i = 0, imax = items.length; i < imax; ++i) {
                    const category = items[i];
                    const id = theme.toCategoryId(category);
                    const label = theme.toCategoryLabel(category);
                    result.push({
                        id,
                        label
                    });
                }
            }
            return result;
        }
        toDefault(items, theme, options) {
            if (options.default != null) {
                return options.default;
            }
            else if (0 < items.length) {
                return items[0].id;
            }
            else {
                return theme.getDefaultCategory();
            }
        }
        toWritable(theme, options) {
            var _a;
            return (_a = options.writable) !== null && _a !== void 0 ? _a : theme.isCategoryWritable();
        }
    }

    class UtilCanvas {
        constructor(options) {
            this._category = new UtilCanvasCategory(options === null || options === void 0 ? void 0 : options.category);
            this._options = options;
        }
        get() {
            var _a;
            return ((_a = this._promise) !== null && _a !== void 0 ? _a : (this._promise = this.fetch()));
        }
        fetch() {
            return this._category.get().then((category) => {
                return this.toDefault(category);
            });
        }
        toDefault(category) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            const theme = wcardinalUi.DThemes.get("EEditorCanvas");
            const options = this._options;
            if (options != null) {
                return {
                    name: (_a = options.name) !== null && _a !== void 0 ? _a : theme.getDefaultName(),
                    label: (_b = options.label) !== null && _b !== void 0 ? _b : theme.getDefaultLabel(),
                    width: (_c = options.width) !== null && _c !== void 0 ? _c : theme.getDefaultWidth(),
                    height: (_d = options.height) !== null && _d !== void 0 ? _d : theme.getDefaultHeight(),
                    category,
                    summary: (_e = options.summary) !== null && _e !== void 0 ? _e : theme.getDefaultSummary(),
                    description: (_f = options.description) !== null && _f !== void 0 ? _f : theme.getDefaultDescription(),
                    background: {
                        color: (_h = (_g = options.background) === null || _g === void 0 ? void 0 : _g.color) !== null && _h !== void 0 ? _h : theme.getDefaultBackgroundColor(),
                        alpha: (_k = (_j = options.background) === null || _j === void 0 ? void 0 : _j.alpha) !== null && _k !== void 0 ? _k : theme.getDefaultBackgroundAlpha()
                    }
                };
            }
            return {
                name: theme.getDefaultName(),
                label: theme.getDefaultLabel(),
                width: theme.getDefaultWidth(),
                height: theme.getDefaultHeight(),
                category,
                summary: theme.getDefaultSummary(),
                description: theme.getDefaultDescription(),
                background: {
                    color: theme.getDefaultBackgroundColor(),
                    alpha: theme.getDefaultBackgroundAlpha()
                }
            };
        }
    }

    class UtilDataValues {
        constructor(parent) {
            this.parent = parent;
            this.mappings = {};
        }
        set(mappings) {
            this.mappings = mappings;
            const parent = this.parent;
            const parentData = parent.data;
            for (const id in mappings) {
                const value = mappings[id];
                if (value) {
                    parentData.set(id, value.value, value.time, value.state);
                }
            }
            parent.update();
        }
        retain(ids) {
            const retained = {};
            const mapping = this.mappings;
            for (let i = 0, imax = ids.length; i < imax; ++i) {
                const id = ids[i];
                if (id in mapping) {
                    retained[id] = mapping[id];
                }
            }
            this.set(retained);
        }
    }

    class UtilDate {
        static getFormatter() {
            if (UtilDate.DATE_FORMATTER == null) {
                UtilDate.DATE_FORMATTER = wcardinalUi.NumberFormatters.create("%Y%M%D%H%m%s");
            }
            return UtilDate.DATE_FORMATTER;
        }
        static format(target) {
            return this.getFormatter().format(target, 1);
        }
    }
    UtilDate.DATE_FORMATTER = null;

    class EEditorCanvasLegacy extends wcardinalUi.DPane {
        constructor(options) {
            super(options);
            const diagram = options.diagram;
            this._diagram = diagram;
            this.state.isDisabled = diagram.canvas == null;
            diagram.on("unset", () => {
                this.state.isDisabled = true;
            });
            diagram.on("set", () => {
                this.state.isDisabled = false;
            });
            this._canvas = options.canvas;
            this.content.addChild(this.newLayout());
        }
        newLayout() {
            return new wcardinalUi.DLayoutVertical({
                x: "padding",
                y: "padding",
                width: "padding",
                height: "auto",
                children: this.newLayoutItems()
            });
        }
        newLayoutItems() {
            return [
                this.newTextLabel(),
                this.newLayoutName(),
                this.newLayoutLabel(),
                this.newLayoutWidth(),
                this.newLayoutHeight(),
                this.newLayoutCategory(),
                this.newLayoutSummary(),
                this.newLayoutDescription(),
                this.newLayoutBackground()
            ];
        }
        newTextLabel() {
            return new wcardinalUi.DText({
                width: "100%",
                text: {
                    value: this.theme.getLabel()
                }
            });
        }
        newLayoutName() {
            const diagram = this._diagram;
            const result = new wcardinalUi.DInputTextAndLabel({
                width: "100%",
                label: {
                    text: {
                        value: this.theme.getInputNameLabel()
                    }
                },
                input: {
                    weight: 1,
                    on: {
                        change: (value) => {
                            const canvas = diagram.canvas;
                            if (canvas != null && canvas.name !== value) {
                                wcardinalUi.DControllers.getCommandController().push(new ECommandDocumentName(diagram, canvas, value));
                            }
                        }
                    }
                }
            });
            const update = () => {
                const canvas = diagram.canvas;
                if (canvas != null) {
                    result.input.value = canvas.name;
                }
            };
            update();
            diagram.on("change", update);
            diagram.on("set", (canvas) => {
                result.input.value = canvas.name;
            });
            return result;
        }
        newLayoutLabel() {
            const diagram = this._diagram;
            const result = new wcardinalUi.DInputTextAndLabel({
                width: "100%",
                label: {
                    text: {
                        value: this.theme.getInputLabelLabel()
                    }
                },
                input: {
                    weight: 1,
                    on: {
                        change: (value) => {
                            const canvas = diagram.canvas;
                            if (canvas != null && canvas.label !== value) {
                                wcardinalUi.DControllers.getCommandController().push(new ECommandDocumentLabel(diagram, canvas, value));
                            }
                        }
                    }
                }
            });
            const update = () => {
                const canvas = diagram.canvas;
                if (canvas != null) {
                    result.input.value = canvas.label;
                }
            };
            update();
            diagram.on("change", update);
            diagram.on("set", (canvas) => {
                result.input.value = canvas.label;
            });
            return result;
        }
        newLayoutWidth() {
            const diagram = this._diagram;
            const result = new wcardinalUi.DInputIntegerAndLabel({
                width: "100%",
                label: {
                    text: {
                        value: this.theme.getInputWidthLabel()
                    }
                },
                input: {
                    weight: 1,
                    min: 1,
                    on: {
                        change: (value) => {
                            const canvas = diagram.canvas;
                            if (canvas != null && canvas.width !== value) {
                                wcardinalUi.DControllers.getCommandController().push(new ECommandDocumentWidth(diagram, canvas, value));
                            }
                        }
                    }
                }
            });
            const update = () => {
                const canvas = diagram.canvas;
                if (canvas != null) {
                    result.input.value = canvas.width;
                }
            };
            update();
            diagram.on("change", update);
            diagram.on("set", (canvas) => {
                result.input.value = canvas.width;
            });
            return result;
        }
        newLayoutHeight() {
            const diagram = this._diagram;
            const result = new wcardinalUi.DInputIntegerAndLabel({
                width: "100%",
                label: {
                    text: {
                        value: this.theme.getInputHeightLabel()
                    }
                },
                input: {
                    weight: 1,
                    min: 1,
                    on: {
                        change: (value) => {
                            const canvas = diagram.canvas;
                            if (canvas != null && canvas.height !== value) {
                                wcardinalUi.DControllers.getCommandController().push(new ECommandDocumentHeight(diagram, canvas, value));
                            }
                        }
                    }
                }
            });
            const update = () => {
                const canvas = diagram.canvas;
                if (canvas != null) {
                    result.input.value = canvas.height;
                }
            };
            update();
            diagram.on("change", update);
            diagram.on("set", (canvas) => {
                result.input.value = canvas.height;
            });
            return result;
        }
        newLayoutBackground() {
            return new wcardinalUi.DLayoutHorizontal({
                width: "padding",
                height: "auto",
                children: [this.newLabelBackground(), this.newInputBackground()]
            });
        }
        newLabelBackground() {
            return new wcardinalUi.DInputLabel({
                width: 60,
                text: {
                    value: this.theme.getInputBackgroundLabel()
                }
            });
        }
        newInputBackground() {
            const diagram = this._diagram;
            const result = new wcardinalUi.DButtonColor({
                weight: 1,
                on: {
                    change: (value) => {
                        wcardinalUi.DControllers.getCommandController().push(new ECommandDocumentBackground(diagram, value.color, value.alpha));
                    }
                }
            });
            result.dialog.on("open", () => {
                const dialog = result.dialog;
                const dialogNew = dialog.new;
                const dialogCurrent = dialog.current;
                dialogNew.color = dialogCurrent.color;
                dialogNew.alpha = dialogCurrent.alpha;
            });
            const update = () => {
                const value = result.value;
                const canvas = diagram.canvas;
                if (canvas != null) {
                    const background = canvas.background;
                    const backgroundColor = background.color;
                    const backgroundAlpha = background.alpha;
                    value.color = wcardinalUi.isNumber(backgroundColor) ? backgroundColor : 0xffffff;
                    value.alpha = wcardinalUi.isNumber(backgroundAlpha) ? backgroundAlpha : 1;
                }
            };
            update();
            diagram.on("change", update);
            diagram.on("set", update);
            return result;
        }
        newLayoutCategory() {
            const label = this.newLabelCategory();
            const select = this.newSelectCategory();
            const result = new wcardinalUi.DLayoutHorizontal({
                width: "padding",
                height: "auto",
                visible: false,
                children: [label, select]
            });
            this._canvas.get().then((canvas) => {
                this.onCanvasValueFetched(canvas, result, select);
            });
            return result;
        }
        onCanvasValueFetched(canvas, layout, select) {
            const category = canvas.category;
            const categoryDefault = category.default;
            const categoryItems = category.items;
            if (categoryDefault != null && 0 < categoryItems.length) {
                const items = [];
                for (let i = 0, imax = categoryItems.length; i < imax; ++i) {
                    const categoryItem = categoryItems[i];
                    items.push({
                        value: categoryItem.id,
                        text: {
                            value: categoryItem.label
                        }
                    });
                }
                select.menu = new wcardinalUi.DMenu({
                    fit: true,
                    items
                });
                select.value = categoryDefault;
                const diagram = this._diagram;
                const update = () => {
                    var _a;
                    const diagramCanvas = diagram.canvas;
                    if (diagramCanvas != null) {
                        select.value = (_a = diagramCanvas.category) !== null && _a !== void 0 ? _a : canvas.category.default;
                    }
                };
                update();
                diagram.on("change", update);
                diagram.on("set", (diagramCanvas) => {
                    var _a;
                    select.value = (_a = diagramCanvas.category) !== null && _a !== void 0 ? _a : canvas.category.default;
                });
                layout.state.isEnabled = category.writable;
                layout.show();
            }
            else {
                select.value = null;
                layout.hide();
            }
        }
        newLabelCategory() {
            return new wcardinalUi.DInputLabel({
                width: 60,
                text: {
                    value: this.theme.getSelectCategoryLabel()
                }
            });
        }
        newSelectCategory() {
            return new wcardinalUi.DSelect({
                weight: 1,
                on: {
                    change: (value) => {
                        const diagram = this._diagram;
                        const canvas = diagram.canvas;
                        if (canvas != null && canvas.category !== value) {
                            wcardinalUi.DControllers.getCommandController().push(new ECommandDocumentCategory(diagram, canvas, value));
                        }
                    }
                }
            });
        }
        newLayoutSummary() {
            return new wcardinalUi.DLayoutHorizontal({
                width: "padding",
                height: "auto",
                children: [this.newLabelSummary(), this.newInputSummary()]
            });
        }
        newLabelSummary() {
            return new wcardinalUi.DInputLabel({
                width: 60,
                text: {
                    value: this.theme.getInputSummaryLabel()
                }
            });
        }
        newInputSummary() {
            const diagram = this._diagram;
            const result = new wcardinalUi.DInputTextArea({
                weight: 1,
                height: 60,
                on: {
                    change: (value) => {
                        const canvas = diagram.canvas;
                        if (canvas != null && canvas.summary !== value) {
                            wcardinalUi.DControllers.getCommandController().push(new ECommandDocumentSummary(diagram, canvas, value));
                        }
                    }
                }
            });
            const update = () => {
                const canvas = diagram.canvas;
                if (canvas != null) {
                    result.value = canvas.summary;
                }
            };
            update();
            diagram.on("change", update);
            diagram.on("set", (canvas) => {
                result.value = canvas.summary;
            });
            return result;
        }
        newLayoutDescription() {
            return new wcardinalUi.DLayoutHorizontal({
                width: "padding",
                height: "auto",
                children: [this.newLabelDescription(), this.newInputDescription()]
            });
        }
        newLabelDescription() {
            return new wcardinalUi.DInputLabel({
                width: 60,
                text: {
                    value: this.theme.getInputDescriptionLabel()
                }
            });
        }
        newInputDescription() {
            const diagram = this._diagram;
            const result = new wcardinalUi.DInputTextArea({
                weight: 1,
                height: 100,
                on: {
                    change: (value) => {
                        const canvas = diagram.canvas;
                        if (canvas != null && canvas.description !== value) {
                            wcardinalUi.DControllers.getCommandController().push(new ECommandDocumentDescription(diagram, canvas, value));
                        }
                    }
                }
            });
            const update = () => {
                const canvas = diagram.canvas;
                if (canvas != null) {
                    result.value = canvas.description;
                }
            };
            update();
            diagram.on("change", update);
            diagram.on("set", (canvas) => {
                result.value = canvas.description;
            });
            return result;
        }
        getType() {
            return "EEditorCanvasLegacy";
        }
    }

    class FGraphicEditor {
        constructor(options) {
            var _a, _b, _c;
            // Options
            this._options = options;
            const theme = this.toTheme(options);
            this._theme = theme;
            this._margin = (_a = options.margin) !== null && _a !== void 0 ? _a : theme.getMargin();
            const piece = options.piece;
            this._isPieceEnabled = (_b = piece === null || piece === void 0 ? void 0 : piece.enable) !== null && _b !== void 0 ? _b : true;
            this._toPieceId = (_c = piece === null || piece === void 0 ? void 0 : piece.toId) !== null && _c !== void 0 ? _c : (() => null);
            this._isEditable = options.editable !== false;
            this._icons = this.toIcons(theme);
            this._validation = this.toValidation(options);
            this._search = this.toSearch(options);
            this._controller = options.controller;
            this._canvas = new UtilCanvas(options.canvas);
            // Application
            this._application = new wcardinalUi.DApplication(options.application);
            // Others
            this._editorButtonGroup = null;
            this.init();
        }
        get application() {
            return this._application;
        }
        get controller() {
            return this._controller;
        }
        toIcons(theme) {
            const iconBuilder = theme.getIconBuilder();
            EShapeExtensions.merge(iconBuilder);
            EShapeExtensionFactories.merge(iconBuilder);
            const result = iconBuilder.build();
            EShapeExtensions.build(result);
            EShapeExtensionFactories.build(result);
            return result;
        }
        toValidation(options) {
            const validation = options.validation;
            if (validation != null) {
                return {
                    validator: validation.validator,
                    force: validation.force === true
                };
            }
            return {
                validator: undefined,
                force: false
            };
        }
        toSearch(options) {
            const search = options.search;
            if (search != null) {
                return {
                    finder: search.finder
                };
            }
            return {
                finder: undefined
            };
        }
        init() {
            this.initDiagram();
            this.initHeader();
            this.initTools();
            this.initEditors();
            this.initCopyAndPaste();
            this.initShortcut();
        }
        initDiagram() {
            const diagram = this.diagram;
            this.getDiagramContainer().addChild(diagram);
            wcardinalUi.DControllers.setDocumentController(diagram);
        }
        initHeader() {
            const header = this.newHeader(this._options);
            if (header) {
                this.getHeaderContainer().addChild(header);
                this._header = header;
            }
        }
        initTools() {
            this.getToolButtonLayoutContainer().addChild(this.newToolButtonLayout());
            // Activates the select tool and then disables all the tools.
            // Otherwise, toolShapeButtonSelect.activate() won't work
            // because toolShapeButtonSelect.state.isActionable is not true.
            this.toolShapeButtonSelect.activate();
            this.toolShapeButtonGroup.disable();
        }
        initEditors() {
            this.getEditorLayoutContainer().addChild(this.newEditorLayout());
            if (!this.isEditorCanvasCompatible()) {
                this.diagram.addChild(this.editorCanvas);
            }
            // Activate the coordinate editor
            this.editorButtonCoordinate.activate();
        }
        initCopyAndPaste() {
            new wcardinalUi.UtilClipboard()
                .on("copy", (clipboardData) => {
                const serialized = this.toolShapeSelect.selection.serialize();
                if (serialized != null) {
                    clipboardData.setData("text", serialized);
                }
            })
                .on("cut", (clipboardData) => {
                const serialized = this.toolShapeSelect.selection.serialize();
                if (serialized != null) {
                    clipboardData.setData("text", serialized);
                    this.toolShapeSelect.selection.delete();
                }
            })
                .on("paste", (clipboardData) => {
                const serialized = clipboardData.getData("text");
                this.toolShapeSelect.selection.deserialize(serialized);
            });
        }
        initShortcut() {
            this.initShortcutShape();
            this.initShortcutTree();
        }
        initShortcutShape() {
            const theme = wcardinalUi.DThemes.get("EEditorShape");
            const groupShortcut = theme.getButtonGroupShortcut();
            if (groupShortcut != null) {
                wcardinalUi.UtilKeyboardEvent.on(this.diagram, groupShortcut, (e) => {
                    this.toolShapeSelect.selection.group();
                });
            }
            const ungroupShortcut = theme.getButtonUngroupShortcut();
            if (ungroupShortcut != null) {
                wcardinalUi.UtilKeyboardEvent.on(this.diagram, ungroupShortcut, (e) => {
                    this.toolShapeSelect.selection.ungroup();
                });
            }
        }
        initShortcutTree() {
            const theme = wcardinalUi.DThemes.get("EEditorTree");
            const bringToFrontShortcut = theme.getButtonBringToFrontShortcut();
            if (bringToFrontShortcut != null) {
                wcardinalUi.UtilKeyboardEvent.on(this.diagram, bringToFrontShortcut, (e) => {
                    this.toolShapeSelect.selection.bringToFront();
                });
            }
            const bringToForwardShortcut = theme.getButtonBringForwardShortcut();
            if (bringToForwardShortcut != null) {
                wcardinalUi.UtilKeyboardEvent.on(this.diagram, bringToForwardShortcut, (e) => {
                    this.toolShapeSelect.selection.bringForward();
                });
            }
            const sendBackwardShortcut = theme.getButtonSendBackwardShortcut();
            if (sendBackwardShortcut != null) {
                wcardinalUi.UtilKeyboardEvent.on(this.diagram, sendBackwardShortcut, (e) => {
                    this.toolShapeSelect.selection.sendBackward();
                });
            }
            const sendToBackShortcut = theme.getButtonSendToBackShortcut();
            if (sendToBackShortcut != null) {
                wcardinalUi.UtilKeyboardEvent.on(this.diagram, sendToBackShortcut, (e) => {
                    this.toolShapeSelect.selection.sendToBack();
                });
            }
        }
        newHeader(options) {
            const header = options.header;
            if (header != null) {
                const result = header(this.newToolFileButtons());
                if (result) {
                    const margin = this._margin;
                    result.x = margin;
                    result.y = margin;
                    result.setWidth((p) => p - 2 * margin);
                    return result;
                }
            }
            return null;
        }
        getHeaderContainer() {
            return this._application.stage;
        }
        get toolFileButtonCreate() {
            var _a;
            return ((_a = this._toolFileButtonCreate) !== null && _a !== void 0 ? _a : (this._toolFileButtonCreate = this.newToolFileButtonCreate()));
        }
        newToolFileButtonCreate() {
            const theme = this._theme;
            return new wcardinalUi.DButton({
                image: {
                    source: this._icons.new
                },
                title: theme.getToolFileButtonCreateTitle(),
                shortcut: theme.getToolFileButtonCreateShortcut(),
                theme: theme.getToolFileButtonTheme(),
                state: this._isEditable ? undefined : wcardinalUi.DBaseState.DISABLED,
                on: {
                    active: (emitter) => {
                        this.onToolFileButtonCreateActive(emitter);
                    }
                }
            });
        }
        onToolFileButtonCreateActive(opener) {
            if (this.diagram.isChanged()) {
                this.dialogDiscard.open(opener).then(() => {
                    this.dialogCreate.then((dialogCreate) => {
                        dialogCreate.reset().open(opener);
                    });
                });
            }
            else {
                this.dialogCreate.then((dialogCreate) => {
                    dialogCreate.reset().open(opener);
                });
            }
        }
        get toolFileButtonOpen() {
            var _a;
            return ((_a = this._toolFileButtonOpen) !== null && _a !== void 0 ? _a : (this._toolFileButtonOpen = this.newToolFileButtonOpen()));
        }
        newToolFileButtonOpen() {
            const theme = this._theme;
            return new wcardinalUi.DButton({
                image: {
                    source: this._icons.open
                },
                title: theme.getToolFileButtonOpenTitle(),
                shortcut: theme.getToolFileButtonOpenShortcut(),
                theme: theme.getToolFileButtonTheme(),
                on: {
                    active: (emitter) => {
                        this.onToolFileButtonOpenActive(emitter);
                    }
                }
            });
        }
        onToolFileButtonOpenActive(opener) {
            if (this.diagram.isChanged()) {
                this.dialogDiscard.open(opener).then(() => {
                    this.dialogSelect.then((dialogSelect) => {
                        dialogSelect.open(opener);
                    });
                });
            }
            else {
                this.dialogSelect.then((dialogSelect) => {
                    dialogSelect.open(opener);
                });
            }
        }
        get toolFileButtonSave() {
            var _a;
            return ((_a = this._toolFileButtonSave) !== null && _a !== void 0 ? _a : (this._toolFileButtonSave = this.newToolFileButtonSave()));
        }
        newToolFileButtonSave() {
            const theme = this._theme;
            const result = new wcardinalUi.DButton({
                image: {
                    source: this._icons.save
                },
                title: theme.getToolFileButtonSaveTitle(),
                shortcut: theme.getToolFileButtonSaveShortcut(),
                theme: theme.getToolFileButtonTheme(),
                state: wcardinalUi.DBaseState.DISABLED,
                on: {
                    active: () => {
                        this.onToolFileButtonSaveActive();
                    }
                }
            });
            if (this._isEditable) {
                const diagram = this.diagram;
                diagram.on("change", () => {
                    result.state.isDisabled = !diagram.isChanged();
                });
            }
            return result;
        }
        onToolFileButtonSaveActive() {
            this.validate().then(() => {
                wcardinalUi.DControllers.getCommandController().push(new wcardinalUi.DCommandSave());
            });
        }
        validate() {
            const validation = this._validation;
            const validator = validation.validator;
            if (validator != null && validation.force) {
                const canvas = this.diagram.canvas;
                if (canvas) {
                    try {
                        const result = validator(canvas);
                        if (result != null) {
                            const dialogSaveProcessing = this.dialogSaveProcessing;
                            dialogSaveProcessing.open(this.toolFileButtonSave);
                            if (wcardinalUi.isArray(result)) {
                                if (0 < result.length) {
                                    const editorValidation = this.editorValidation;
                                    editorValidation.list.data.clearAndAddAll(result);
                                    const editorButtonValidation = this.editorButtonValidation;
                                    if (!editorButtonValidation.state.isActive) {
                                        editorButtonValidation.activate();
                                    }
                                    dialogSaveProcessing.reject("validation");
                                    return Promise.reject();
                                }
                                else {
                                    return Promise.resolve();
                                }
                            }
                            else {
                                return result.then((results) => {
                                    if (0 < results.length) {
                                        const editorValidation = this.editorValidation;
                                        editorValidation.list.data.clearAndAddAll(results);
                                        const editorButtonValidation = this.editorButtonValidation;
                                        if (!editorButtonValidation.state.isActive) {
                                            editorButtonValidation.activate();
                                        }
                                        dialogSaveProcessing.reject("validation");
                                        return Promise.reject();
                                    }
                                    else {
                                        return Promise.resolve();
                                    }
                                }, () => {
                                    dialogSaveProcessing.reject("validation-fail");
                                    return Promise.reject();
                                });
                            }
                        }
                    }
                    catch (_a) {
                        const dialogSaveProcessing = this.dialogSaveProcessing;
                        dialogSaveProcessing.open(this.toolFileButtonSave);
                        dialogSaveProcessing.reject("validation-fail");
                        return Promise.reject();
                    }
                }
            }
            return Promise.resolve();
        }
        get toolFileButtonSaveAs() {
            var _a;
            return ((_a = this._toolFileButtonSaveAs) !== null && _a !== void 0 ? _a : (this._toolFileButtonSaveAs = this.newToolFileButtonSaveAs()));
        }
        newToolFileButtonSaveAs() {
            const theme = this._theme;
            const result = new wcardinalUi.DButton({
                image: {
                    source: this._icons.save_as
                },
                title: theme.getToolFileButtonSaveAsTitle(),
                shortcut: theme.getToolFileButtonSaveAsShortcut(),
                theme: theme.getToolFileButtonTheme(),
                state: wcardinalUi.DBaseState.DISABLED,
                on: {
                    active: () => {
                        this.onToolFileButtonSaveAsActive();
                    }
                }
            });
            if (this._isEditable) {
                const diagram = this.diagram;
                diagram.on("set", () => {
                    result.state.isDisabled = false;
                });
                diagram.on("unset", () => {
                    result.state.isDisabled = true;
                });
            }
            return result;
        }
        onToolFileButtonSaveAsActive() {
            this.validate().then(() => {
                this.dialogSaveAs.open(this.toolFileButtonSaveAs);
            });
        }
        get toolFileButtonUpload() {
            var _a;
            return ((_a = this._toolFileButtonUpload) !== null && _a !== void 0 ? _a : (this._toolFileButtonUpload = this.newToolFileButtonUpload()));
        }
        newToolFileButtonUpload() {
            const theme = this._theme;
            const result = new wcardinalUi.DButtonFile({
                image: {
                    source: this._icons.upload
                },
                title: theme.getToolFileButtonUploadTitle(),
                shortcut: theme.getToolFileButtonUploadShortcut(),
                theme: theme.getToolFileButtonTheme(),
                as: wcardinalUi.DButtonFileAs.TEXT,
                checker: () => {
                    if (this.diagram.isChanged()) {
                        return this.dialogDiscard.open(result);
                    }
                    else {
                        return true;
                    }
                },
                on: {
                    open: (data) => {
                        this.onToolFileButtonUploadOpen(data);
                    }
                }
            });
            return result;
        }
        onToolFileButtonUploadOpen(data) {
            const parsed = wcardinalUi.DDiagrams.parse(data);
            if (parsed != null) {
                parsed.id = undefined;
                this.diagram.set(parsed);
            }
        }
        get toolFileButtonDownload() {
            var _a;
            return ((_a = this._toolFileButtonDownload) !== null && _a !== void 0 ? _a : (this._toolFileButtonDownload = this.newToolFileButtonDownload()));
        }
        newToolFileButtonDownload() {
            const theme = this._theme;
            const result = new wcardinalUi.DButton({
                image: {
                    source: this._icons.download
                },
                title: theme.getToolFileButtonDownloadTitle(),
                shortcut: theme.getToolFileButtonDownloadShortcut(),
                theme: theme.getToolFileButtonTheme(),
                state: wcardinalUi.DBaseState.DISABLED,
                on: {
                    active: () => {
                        this.onToolFileButtonDownloadActive();
                    }
                }
            });
            const diagram = this.diagram;
            diagram.on("set", () => {
                result.state.isDisabled = false;
            });
            diagram.on("unset", () => {
                result.state.isDisabled = true;
            });
            return result;
        }
        onToolFileButtonDownloadActive() {
            const serialized = this.diagram.serialize();
            if (serialized != null) {
                wcardinalUi.UtilFileDownloader.download(`${serialized.name}.json`, JSON.stringify(serialized));
            }
        }
        get toolFileButtonUndo() {
            var _a;
            return ((_a = this._toolFileButtonUndo) !== null && _a !== void 0 ? _a : (this._toolFileButtonUndo = this.newToolFileButtonUndo()));
        }
        newToolFileButtonUndo() {
            const theme = this._theme;
            return new wcardinalUi.DButtonUndo({
                title: theme.getToolFileButtonUndoTitle(),
                shortcut: theme.getToolFileButtonUndoShortcut(),
                theme: theme.getToolFileButtonTheme(),
                image: {
                    source: this._icons.undo
                }
            });
        }
        get toolFileButtonRedo() {
            var _a;
            return ((_a = this._toolFileButtonRedo) !== null && _a !== void 0 ? _a : (this._toolFileButtonRedo = this.newToolFileButtonRedo()));
        }
        newToolFileButtonRedo() {
            const theme = this._theme;
            return new wcardinalUi.DButtonRedo({
                title: theme.getToolFileButtonRedoTitle(),
                shortcut: theme.getToolFileButtonRedoShortcut(),
                theme: theme.getToolFileButtonTheme(),
                image: {
                    source: this._icons.redo
                }
            });
        }
        get toolFileButtonDelete() {
            var _a;
            return ((_a = this._toolFileButtonDelete) !== null && _a !== void 0 ? _a : (this._toolFileButtonDelete = this.newToolFileButtonDelete()));
        }
        newToolFileButtonDelete() {
            const theme = this._theme;
            const result = new wcardinalUi.DButton({
                image: {
                    source: this._icons.delete
                },
                title: theme.getToolFileButtonDeleteTitle(),
                shortcut: theme.getToolFileButtonDeleteShortcut(),
                theme: theme.getToolFileButtonTheme(),
                state: wcardinalUi.DBaseState.DISABLED,
                on: {
                    active: (emitter) => {
                        this.onToolFileButtonDelete(emitter);
                    }
                }
            });
            if (this._isEditable) {
                const diagram = this.diagram;
                diagram.on("set", () => {
                    result.state.isDisabled = false;
                });
                diagram.on("unset", () => {
                    result.state.isDisabled = true;
                });
            }
            return result;
        }
        onToolFileButtonDelete(opener) {
            this.dialogDelete.open(opener);
        }
        get toolShapeButtonGroup() {
            var _a;
            return ((_a = this._toolShapeButtonGroup) !== null && _a !== void 0 ? _a : (this._toolShapeButtonGroup = this.newToolShapeButtonGroup()));
        }
        newToolShapeButtonGroup() {
            const result = new wcardinalUi.DButtonGroup();
            const diagram = this.diagram;
            diagram.on("set", () => {
                result.enable();
            });
            diagram.on("unset", () => {
                result.disable();
            });
            return result;
        }
        get toolShapeButtonSelect() {
            var _a;
            return ((_a = this._toolShapeButtonSelect) !== null && _a !== void 0 ? _a : (this._toolShapeButtonSelect = this.newToolShapeButtonSelect()));
        }
        newToolShapeButtonSelect() {
            const theme = this._theme;
            const result = new wcardinalUi.DButton({
                group: this.toolShapeButtonGroup,
                toggle: true,
                title: theme.getToolShapeButtonSelectTitle(),
                theme: theme.getToolShapeButtonTheme(),
                image: {
                    source: this._icons.select
                },
                on: {
                    active: () => {
                        this.onToolShapeButtonSelectActive();
                    },
                    inactive: () => {
                        this.onToolShapeButtonSelectInactive();
                    }
                }
            });
            return result;
        }
        onToolShapeButtonSelectActive() {
            this.toolGroup.activate(this.toolShapeSelect);
        }
        onToolShapeButtonSelectInactive() {
            this.toolGroup.deactivate(this.toolShapeSelect);
        }
        newToolShapeButtonCreate(title, icon, constructor) {
            return new wcardinalUi.DButton({
                group: this.toolShapeButtonGroup,
                toggle: true,
                title,
                theme: this._theme.getToolShapeButtonTheme(),
                image: {
                    source: this._icons[icon]
                },
                on: {
                    active: () => {
                        this.onToolShapeButtonCreateActive(constructor);
                    },
                    inactive: () => {
                        this.onToolShapeButtonCreateInactive();
                    }
                }
            });
        }
        onToolShapeButtonCreateActive(constructor) {
            const toolShapeCreate = this.toolShapeCreate;
            toolShapeCreate.shape = () => new constructor();
            this.toolGroup.activate(toolShapeCreate, constructor);
        }
        onToolShapeButtonCreateInactive() {
            this.toolGroup.deactivate(this.toolShapeCreate);
        }
        get toolShapeButtonCircle() {
            var _a;
            return ((_a = this._toolShapeButtonCircle) !== null && _a !== void 0 ? _a : (this._toolShapeButtonCircle = this.newToolShapeButtonCircle()));
        }
        newToolShapeButtonCircle() {
            const theme = this._theme;
            return this.newToolShapeButtonCreate(theme.getToolShapeButtonCircleTitle(), "shape_circle", wcardinalUi.EShapeCircle);
        }
        get toolShapeButtonSemicircle() {
            var _a;
            return ((_a = this._toolShapeButtonSemicircle) !== null && _a !== void 0 ? _a : (this._toolShapeButtonSemicircle = this.newToolShapeButtonSemicircle()));
        }
        newToolShapeButtonSemicircle() {
            const theme = this._theme;
            return this.newToolShapeButtonCreate(theme.getToolShapeButtonSemicircleTitle(), "shape_semicircle", wcardinalUi.EShapeSemicircle);
        }
        get toolShapeButtonRectangle() {
            var _a;
            return ((_a = this._toolShapeButtonRectangle) !== null && _a !== void 0 ? _a : (this._toolShapeButtonRectangle = this.newToolShapeButtonRectangle()));
        }
        newToolShapeButtonRectangle() {
            const theme = this._theme;
            return this.newToolShapeButtonCreate(theme.getToolShapeButtonRectangleTitle(), "shape_rectangle", wcardinalUi.EShapeRectangle);
        }
        get toolShapeButtonRectangleRounded() {
            var _a;
            return ((_a = this._toolShapeButtonRectangleRounded) !== null && _a !== void 0 ? _a : (this._toolShapeButtonRectangleRounded = this.newToolShapeButtonRectangleRounded()));
        }
        newToolShapeButtonRectangleRounded() {
            const theme = this._theme;
            return this.newToolShapeButtonCreate(theme.getToolShapeButtonRectangleRoundedTitle(), "shape_rectangle_rounded", wcardinalUi.EShapeRectangleRounded);
        }
        get toolShapeButtonTriangle() {
            var _a;
            return ((_a = this._toolShapeButtonTriangle) !== null && _a !== void 0 ? _a : (this._toolShapeButtonTriangle = this.newToolShapeButtonTriangle()));
        }
        newToolShapeButtonTriangle() {
            const theme = this._theme;
            return this.newToolShapeButtonCreate(theme.getToolShapeButtonTriangleTitle(), "shape_triangle", wcardinalUi.EShapeTriangle);
        }
        get toolShapeButtonTriangleRounded() {
            var _a;
            return ((_a = this._toolShapeButtonTriangleRounded) !== null && _a !== void 0 ? _a : (this._toolShapeButtonTriangleRounded = this.newToolShapeButtonTriangleRounded()));
        }
        newToolShapeButtonTriangleRounded() {
            const theme = this._theme;
            return this.newToolShapeButtonCreate(theme.getToolShapeButtonTriangleRoundedTitle(), "shape_triangle_rounded", wcardinalUi.EShapeTriangleRounded);
        }
        get toolShapeButtonLine() {
            var _a;
            return ((_a = this._toolShapeButtonLine) !== null && _a !== void 0 ? _a : (this._toolShapeButtonLine = this.newToolShapeButtonLine()));
        }
        newToolShapeButtonLine() {
            const theme = this._theme;
            const result = new wcardinalUi.DButton({
                group: this.toolShapeButtonGroup,
                toggle: true,
                title: theme.getToolShapeButtonLineTitle(),
                theme: theme.getToolShapeButtonTheme(),
                image: {
                    source: this._icons.shape_line
                },
                on: {
                    active: () => {
                        this.onToolShapeButtonLineActive();
                    },
                    inactive: () => {
                        this.onToolShapeButtonLineInactive();
                    }
                }
            });
            this.toolShapeSelect.on("edit", (shape) => {
                if (shape instanceof wcardinalUi.EShapeLine) {
                    const toolShapeEditLine = this.toolShapeEditLine;
                    toolShapeEditLine.shape = shape;
                    this.toolGroup.activate(toolShapeEditLine);
                }
            });
            return result;
        }
        onToolShapeButtonLineActive() {
            this.toolGroup.activate(this.toolShapeCreateLine);
        }
        onToolShapeButtonLineInactive() {
            this.toolGroup.deactivate(this.toolShapeCreateLine);
        }
        get toolShapeButtonLineConnector() {
            var _a;
            return ((_a = this._toolShapeButtonLineConnector) !== null && _a !== void 0 ? _a : (this._toolShapeButtonLineConnector = this.newToolShapeButtonLineConnector()));
        }
        newToolShapeButtonLineConnector() {
            const theme = this._theme;
            const result = new wcardinalUi.DButton({
                group: this.toolShapeButtonGroup,
                toggle: true,
                title: theme.getToolShapeButtonLineConnectorTitle(),
                theme: theme.getToolShapeButtonTheme(),
                image: {
                    source: this._icons.shape_line_connector
                },
                on: {
                    active: () => {
                        this.onToolShapeButtonLineConnectorActive();
                    },
                    inactive: () => {
                        this.onToolShapeButtonLineConnectorInactive();
                    }
                }
            });
            this.toolShapeSelect.on("edit", (shape) => {
                if (shape instanceof wcardinalUi.EShapeConnectorLine) {
                    const toolShapeEditLineConnector = this.toolShapeEditLineConnector;
                    toolShapeEditLineConnector.shape = shape;
                    this.toolGroup.activate(toolShapeEditLineConnector);
                }
            });
            return result;
        }
        onToolShapeButtonLineConnectorActive() {
            this.toolGroup.activate(this.toolShapeCreateLineConnector);
        }
        onToolShapeButtonLineConnectorInactive() {
            this.toolGroup.deactivate(this.toolShapeCreateLineConnector);
        }
        get toolShapeButtonElbowConnector() {
            var _a;
            return ((_a = this._toolShapeButtonElbowConnector) !== null && _a !== void 0 ? _a : (this._toolShapeButtonElbowConnector = this.newToolShapeButtonElbowConnector()));
        }
        newToolShapeButtonElbowConnector() {
            const theme = this._theme;
            const result = new wcardinalUi.DButton({
                group: this.toolShapeButtonGroup,
                toggle: true,
                title: theme.getToolShapeButtonElbowConnectorTitle(),
                theme: theme.getToolShapeButtonTheme(),
                image: {
                    source: this._icons.shape_elbow_connector
                },
                on: {
                    active: () => {
                        this.onToolShapeButtonElbowConnectorActive();
                    },
                    inactive: () => {
                        this.onToolShapeButtonElbowConnectorInactive();
                    }
                }
            });
            this.toolShapeSelect.on("edit", (shape) => {
                if (shape instanceof wcardinalUi.EShapeConnectorLine) {
                    const toolShapeEditLineConnector = this.toolShapeEditLineConnector;
                    toolShapeEditLineConnector.shape = shape;
                    this.toolGroup.activate(toolShapeEditLineConnector);
                }
            });
            return result;
        }
        onToolShapeButtonElbowConnectorActive() {
            this.toolGroup.activate(this.toolShapeCreateElbowConnector);
        }
        onToolShapeButtonElbowConnectorInactive() {
            this.toolGroup.deactivate(this.toolShapeCreateElbowConnector);
        }
        get toolShapeButtonImage() {
            var _a;
            return ((_a = this._toolShapeButtonImage) !== null && _a !== void 0 ? _a : (this._toolShapeButtonImage = this.newToolShapeButtonImage()));
        }
        newToolShapeButtonImage() {
            const theme = this._theme;
            return new wcardinalUi.DButtonFile({
                group: this.toolShapeButtonGroup,
                title: theme.getToolShapeButtonImageTitle(),
                theme: theme.getToolShapeButtonTheme(),
                as: wcardinalUi.DButtonFileAs.DATA_URL,
                image: {
                    source: this._icons.editor_image
                },
                on: {
                    open: (dataUrl) => {
                        this.onToolShapeButtonImageOpen(dataUrl);
                    }
                }
            });
        }
        onToolShapeButtonImageOpen(dataUrl) {
            const diagram = this.diagram;
            const layer = diagram.layer;
            const canvas = diagram.canvas;
            if (canvas != null && layer != null) {
                wcardinalUi.createImage(dataUrl).then((shape) => {
                    shape.transform.position.set(canvas.width * 0.5, canvas.height * 0.5);
                    shape.attach(layer);
                    wcardinalUi.DControllers.getCommandController().push(new ECommandShapeCreate([shape], layer, this.toolShapeSelect.selection, true));
                });
            }
        }
        get toolShapeButtonGraphicPiece() {
            var _a;
            return ((_a = this._toolShapeButtonGraphicPiece) !== null && _a !== void 0 ? _a : (this._toolShapeButtonGraphicPiece = this.newToolShapeButtonGraphicPiece()));
        }
        newToolShapeButtonGraphicPiece() {
            const theme = this._theme;
            return new wcardinalUi.DButton({
                group: this.toolShapeButtonGroup,
                title: theme.getToolShapeButtonGraphicPieceTitle(),
                theme: theme.getToolShapeButtonTheme(),
                image: {
                    source: this._icons.graphic_piece
                },
                on: {
                    active: (emitter) => {
                        this.onToolShapeButtonGraphicPieceActive(emitter);
                    }
                }
            });
        }
        onToolShapeButtonGraphicPieceActive(opener) {
            this.dialogSelectPiece.then((dialogSelectPiece) => {
                dialogSelectPiece.open(opener);
            });
        }
        newToolShapeButtonExtensionFactory(factory) {
            let dialogSelect = null;
            return new wcardinalUi.DButton({
                group: this.toolShapeButtonGroup,
                title: this.toExtensionTitle(factory),
                theme: this._theme.getToolShapeButtonTheme(),
                image: {
                    source: factory.icon.texture
                },
                on: {
                    active: (emitter) => {
                        (dialogSelect !== null && dialogSelect !== void 0 ? dialogSelect : (dialogSelect = this.newDialogSelectExtensionFactory(factory))).open(emitter);
                    }
                }
            });
        }
        newToolShapeButtonExtension(extension) {
            let creatorOrTool = null;
            const result = new wcardinalUi.DButton({
                group: this.toolShapeButtonGroup,
                title: this.toExtensionTitle(extension),
                theme: this._theme.getToolShapeButtonTheme(),
                toggle: true,
                image: {
                    source: extension.icon.texture
                },
                on: {
                    active: () => {
                        if (creatorOrTool == null) {
                            creatorOrTool = this.toExtensionCreatorOrTool(extension);
                        }
                        this.onToolShapeButtonExtensionActive(creatorOrTool);
                    },
                    inactive: () => {
                        if (creatorOrTool == null) {
                            creatorOrTool = this.toExtensionCreatorOrTool(extension);
                        }
                        this.onToolShapeButtonExtensionInactive(creatorOrTool);
                    }
                }
            });
            if ("type" in extension) {
                const updaterCreatorOrOptions = extension.updater;
                if (updaterCreatorOrOptions != null) {
                    const type = extension.type;
                    let updater = null;
                    this.toolShapeSelect.on("edit", (shape) => {
                        if (shape.type === type) {
                            if (updater == null) {
                                updater = this.toExtensionUpdater(updaterCreatorOrOptions);
                            }
                            updater.shape = shape;
                            this.toolGroup.activate(updater);
                        }
                    });
                }
            }
            return result;
        }
        toExtensionUpdater(updaterCreatorOrOptions) {
            const updaterCreator = wcardinalUi.isFunction(updaterCreatorOrOptions)
                ? updaterCreatorOrOptions
                : updaterCreatorOrOptions.tool;
            const result = updaterCreator(this.toolShapeSelect.selection, this.diagram);
            result.on("done", () => {
                this.toolGroup.activate(this.toolShapeSelect);
            });
            result.on("cancel", () => {
                this.toolGroup.activate(this.toolShapeSelect);
            });
            return result;
        }
        toExtensionCreatorOrTool(extension) {
            const creator = extension.creator;
            if (wcardinalUi.isFunction(creator)) {
                return creator;
            }
            else {
                const result = creator.tool(this.toolShapeSelect.selection, this.diagram);
                result.on("done", () => {
                    this.toolShapeButtonSelect.activate();
                });
                result.on("cancel", () => {
                    this.toolShapeButtonSelect.activate();
                });
                return result;
            }
        }
        onToolShapeButtonExtensionActive(creatorOrTool) {
            const toolGroup = this.toolGroup;
            if (wcardinalUi.isFunction(creatorOrTool)) {
                const toolShapeCreate = this.toolShapeCreate;
                toolShapeCreate.shape = creatorOrTool;
                toolGroup.activate(toolShapeCreate, creatorOrTool);
            }
            else {
                toolGroup.activate(creatorOrTool);
            }
        }
        onToolShapeButtonExtensionInactive(creatorOrTool) {
            const toolGroup = this.toolGroup;
            if (wcardinalUi.isFunction(creatorOrTool)) {
                toolGroup.deactivate(this.toolShapeCreate, creatorOrTool);
            }
            else {
                toolGroup.deactivate(creatorOrTool);
            }
        }
        toExtensionTitle(extension) {
            const title = extension.title;
            if (wcardinalUi.isString(title)) {
                return title;
            }
            return title.create;
        }
        newDialogSelectExtensionFactory(factory) {
            return new wcardinalUi.DDialogSelect({
                controller: factory,
                list: {
                    data: {
                        toLabel: factory.item.toLabel
                    }
                },
                on: {
                    select: (value) => {
                        this.onDialogSelectExtensionFactorySelect(value, factory);
                    }
                }
            });
        }
        onDialogSelectExtensionFactorySelect(value, factory) {
            const diagram = this.diagram;
            const layer = diagram.layer;
            const canvas = diagram.canvas;
            if (canvas && layer) {
                factory.item.toCreator(value).then((creator) => {
                    const shape = creator();
                    shape.transform.position.set(canvas.width * 0.5, canvas.height * 0.5);
                    shape.attach(layer);
                    wcardinalUi.DControllers.getCommandController().push(new ECommandShapeCreate([shape], layer, this.toolShapeSelect.selection, true));
                });
            }
        }
        newToolFileButtons() {
            return [
                this.toolFileButtonCreate,
                this.toolFileButtonOpen,
                this.toolFileButtonSave,
                this.toolFileButtonSaveAs,
                this.toolFileButtonUpload,
                this.toolFileButtonDownload,
                this.toolFileButtonUndo,
                this.toolFileButtonRedo,
                this.toolFileButtonDelete
            ];
        }
        newToolShapeButtons() {
            const result = [
                this.toolShapeButtonSelect,
                this.toolShapeButtonLine,
                this.toolShapeButtonCircle,
                this.toolShapeButtonSemicircle,
                this.toolShapeButtonRectangle,
                this.toolShapeButtonRectangleRounded,
                this.toolShapeButtonTriangle,
                this.toolShapeButtonTriangleRounded,
                this.toolShapeButtonLineConnector,
                this.toolShapeButtonElbowConnector,
                this.toolShapeButtonImage
            ];
            if (this._isPieceEnabled) {
                result.push(this.toolShapeButtonGraphicPiece);
            }
            return result;
        }
        newToolShapeButtonsExtension() {
            const result = [];
            EShapeExtensions.each((extension) => {
                if ("icon" in extension) {
                    result.push(this.newToolShapeButtonExtension(extension));
                }
            });
            EShapeExtensionFactories.each((factory) => {
                result.push(this.newToolShapeButtonExtensionFactory(factory));
            });
            return result;
        }
        getToolButtonLayoutContainer() {
            return this._application.stage;
        }
        newToolButtonLayout() {
            const margin = this._margin;
            return new wcardinalUi.DLayoutVertical({
                x: margin,
                y: this.getToolButtonLayoutY(margin),
                theme: "EButtonToolLayout",
                children: this.newToolButtons()
            });
        }
        getToolButtonLayoutY(margin) {
            const header = this._header;
            if (header != null) {
                return margin + header.height + margin;
            }
            return margin;
        }
        newToolButtons() {
            const toolFileButtonCreate = this._toolFileButtonCreate;
            if (toolFileButtonCreate == null || toolFileButtonCreate.parent == null) {
                return this.newToolFileButtons()
                    .concat(new wcardinalUi.DLayoutSpace({ height: 10 }))
                    .concat(this.newToolShapeButtons())
                    .concat(this.newToolShapeButtonsExtension());
            }
            else {
                return this.newToolShapeButtons().concat(this.newToolShapeButtonsExtension());
            }
        }
        get editorButtonGroup() {
            var _a;
            return ((_a = this._editorButtonGroup) !== null && _a !== void 0 ? _a : (this._editorButtonGroup = this.newEditorButtonGroup()));
        }
        newEditorButtonGroup() {
            return undefined;
        }
        get editorButtonCoordinate() {
            var _a;
            return ((_a = this._editorButtonCoordinate) !== null && _a !== void 0 ? _a : (this._editorButtonCoordinate = this.newEditorButtonCoordinate()));
        }
        newEditorButtonCoordinate() {
            const theme = this._theme;
            return new wcardinalUi.DButton({
                group: this.editorButtonGroup,
                toggle: true,
                image: {
                    source: this._icons.editor_coordinate
                },
                title: theme.getEditorButtonCoordinateTitle(),
                theme: theme.getEditorButtonTheme(),
                on: {
                    active: () => {
                        this.editorCoordinate.show();
                    },
                    inactive: () => {
                        this.editorCoordinate.hide();
                    }
                }
            });
        }
        get editorCoordinate() {
            var _a;
            return ((_a = this._editorCoordinate) !== null && _a !== void 0 ? _a : (this._editorCoordinate = this.newEditorCoordinate()));
        }
        newEditorCoordinate() {
            return this.initEditor(0, new EEditorCoordinate({
                parent: this.editorContainer,
                selection: this.toolShapeSelect.selection,
                icons: this._icons
            }));
        }
        initEditor(zIndex, editor) {
            editor.zIndex = zIndex;
            editor.parent.sortChildren();
            editor.interactive = true;
            if (editor instanceof wcardinalUi.DBase) {
                editor.state.isFocusable = false;
            }
            return editor;
        }
        get editorButtonShape() {
            var _a;
            return ((_a = this._editorButtonShape) !== null && _a !== void 0 ? _a : (this._editorButtonShape = this.newEditorButtonShape()));
        }
        newEditorButtonShape() {
            const theme = this._theme;
            return new wcardinalUi.DButton({
                group: this.editorButtonGroup,
                toggle: true,
                image: {
                    source: this._icons.editor_shape
                },
                title: theme.getEditorButtonShapeTitle(),
                theme: theme.getEditorButtonTheme(),
                on: {
                    active: () => {
                        this.editorShape.show();
                    },
                    inactive: () => {
                        this.editorShape.hide();
                    }
                }
            });
        }
        get editorShape() {
            var _a;
            return ((_a = this._editorShape) !== null && _a !== void 0 ? _a : (this._editorShape = this.newEditorShape()));
        }
        newEditorShape() {
            return this.initEditor(1, new EEditorShape({
                parent: this.editorContainer,
                selection: this.toolShapeSelect.selection,
                icons: this._icons,
                canvas: this._canvas,
                content: {
                    theme: "EEditorPaneContent"
                },
                piece: {
                    enable: this._isPieceEnabled,
                    controller: this._options.controller,
                    exclude: () => {
                        return this._toPieceId(this.diagram);
                    }
                },
                connector: {
                    dangling: this.isDanglingConnectorAllowed()
                }
            }));
        }
        get editorButtonText() {
            var _a;
            return ((_a = this._editorButtonText) !== null && _a !== void 0 ? _a : (this._editorButtonText = this.newEditorButtonText()));
        }
        newEditorButtonText() {
            const theme = this._theme;
            return new wcardinalUi.DButton({
                group: this.editorButtonGroup,
                toggle: true,
                image: {
                    source: this._icons.editor_text
                },
                title: theme.getEditorButtonTextTitle(),
                theme: theme.getEditorButtonTheme(),
                on: {
                    active: () => {
                        this.editorText.show();
                    },
                    inactive: () => {
                        this.editorText.hide();
                    }
                }
            });
        }
        get editorText() {
            var _a;
            return ((_a = this._editorText) !== null && _a !== void 0 ? _a : (this._editorText = this.newEditorText()));
        }
        newEditorText() {
            return this.initEditor(2, new EEditorText({
                parent: this.editorContainer,
                selection: this.toolShapeSelect.selection,
                icons: this._icons,
                content: {
                    theme: "EEditorPaneContent"
                }
            }));
        }
        get editorButtonData() {
            var _a;
            return ((_a = this._editorButtonData) !== null && _a !== void 0 ? _a : (this._editorButtonData = this.newEditorButtonData()));
        }
        newEditorButtonData() {
            const theme = this._theme;
            return new wcardinalUi.DButton({
                group: this.editorButtonGroup,
                toggle: true,
                image: {
                    source: this._icons.editor_data
                },
                title: theme.getEditorButtonDataTitle(),
                theme: theme.getEditorButtonTheme(),
                on: {
                    active: () => {
                        this.editorData.show();
                    },
                    inactive: () => {
                        this.editorData.hide();
                    }
                }
            });
        }
        get editorData() {
            var _a;
            return ((_a = this._editorData) !== null && _a !== void 0 ? _a : (this._editorData = this.newEditorData()));
        }
        newEditorData() {
            return this.initEditor(3, new EEditorData({
                parent: this.editorContainer,
                selection: this.toolShapeSelect.selection,
                icons: this._icons
            }));
        }
        get editorButtonDataMapping() {
            var _a;
            return ((_a = this._editorButtonDataMapping) !== null && _a !== void 0 ? _a : (this._editorButtonDataMapping = this.newEditorButtonDataMapping()));
        }
        newEditorButtonDataMapping() {
            const theme = this._theme;
            return new wcardinalUi.DButton({
                group: this.editorButtonGroup,
                toggle: true,
                image: {
                    source: this._icons.editor_data_mapping
                },
                title: theme.getEditorButtonDataMappingTitle(),
                theme: theme.getEditorButtonTheme(),
                on: {
                    active: () => {
                        this.editorDataMapping.show();
                    },
                    inactive: () => {
                        this.editorDataMapping.hide();
                    }
                }
            });
        }
        get editorDataMapping() {
            var _a;
            return ((_a = this._editorDataMapping) !== null && _a !== void 0 ? _a : (this._editorDataMapping = this.newEditorDataMapping()));
        }
        newEditorDataMapping() {
            return this.initEditor(4, new EEditorDataMapping({
                parent: this.editorContainer,
                selection: this.toolShapeSelect.selection,
                icons: this._icons
            }));
        }
        get editorButtonAction() {
            var _a;
            return ((_a = this._editorButtonAction) !== null && _a !== void 0 ? _a : (this._editorButtonAction = this.newEditorButtonAction()));
        }
        newEditorButtonAction() {
            const theme = this._theme;
            return new wcardinalUi.DButton({
                group: this.editorButtonGroup,
                toggle: true,
                image: {
                    source: this._icons.editor_action
                },
                title: theme.getEditorButtonActionTitle(),
                theme: theme.getEditorButtonTheme(),
                on: {
                    active: () => {
                        this.editorAction.show();
                    },
                    inactive: () => {
                        this.editorAction.hide();
                    }
                }
            });
        }
        get editorAction() {
            var _a;
            return ((_a = this._editorAction) !== null && _a !== void 0 ? _a : (this._editorAction = this.newEditorAction()));
        }
        newEditorAction() {
            return this.initEditor(5, new EEditorAction({
                parent: this.editorContainer,
                selection: this.toolShapeSelect.selection,
                icons: this._icons,
                diagram: this.diagram
            }));
        }
        get editorButtonTree() {
            var _a;
            return ((_a = this._editorButtonTree) !== null && _a !== void 0 ? _a : (this._editorButtonTree = this.newEditorButtonTree()));
        }
        newEditorButtonTree() {
            const theme = this._theme;
            return new wcardinalUi.DButton({
                group: this.editorButtonGroup,
                toggle: true,
                image: {
                    source: this._icons.editor_tree
                },
                title: theme.getEditorButtonTreeTitle(),
                theme: theme.getEditorButtonTheme(),
                on: {
                    active: () => {
                        this.editorTree.show();
                    },
                    inactive: () => {
                        this.editorTree.hide();
                    }
                }
            });
        }
        get editorTree() {
            var _a;
            return ((_a = this._editorTree) !== null && _a !== void 0 ? _a : (this._editorTree = this.newEditorTree()));
        }
        newEditorTree() {
            return this.initEditor(6, new EEditorTree({
                parent: this.editorContainer,
                selection: this.toolShapeSelect.selection,
                icons: this._icons,
                diagram: this.diagram
            }));
        }
        get editorButtonLayer() {
            var _a;
            return ((_a = this._editorButtonLayer) !== null && _a !== void 0 ? _a : (this._editorButtonLayer = this.newEditorButtonLayer()));
        }
        newEditorButtonLayer() {
            const theme = this._theme;
            return new wcardinalUi.DButton({
                group: this.editorButtonGroup,
                toggle: true,
                image: {
                    source: this._icons.editor_layer
                },
                title: theme.getEditorButtonLayerTitle(),
                theme: theme.getEditorButtonTheme(),
                on: {
                    active: () => {
                        this.editorLayer.show();
                    },
                    inactive: () => {
                        this.editorLayer.hide();
                    }
                }
            });
        }
        get editorLayer() {
            var _a;
            return ((_a = this._editorLayer) !== null && _a !== void 0 ? _a : (this._editorLayer = this.newEditorLayer()));
        }
        newEditorLayer() {
            return this.initEditor(7, new EEditorLayer({
                parent: this.editorContainer,
                selection: this.toolShapeSelect.selection,
                icons: this._icons,
                diagram: this.diagram
            }));
        }
        get editorButtonSnap() {
            var _a;
            return ((_a = this._editorButtonSnap) !== null && _a !== void 0 ? _a : (this._editorButtonSnap = this.newEditorButtonSnap()));
        }
        newEditorButtonSnap() {
            const theme = this._theme;
            return new wcardinalUi.DButton({
                group: this.editorButtonGroup,
                toggle: true,
                image: {
                    source: this._icons.editor_snap
                },
                title: theme.getEditorButtonSnapTitle(),
                theme: theme.getEditorButtonTheme(),
                on: {
                    active: () => {
                        this.editorSnap.show();
                    },
                    inactive: () => {
                        this.editorSnap.hide();
                    }
                }
            });
        }
        get editorSnap() {
            var _a;
            return ((_a = this._editorSnap) !== null && _a !== void 0 ? _a : (this._editorSnap = this.newEditorSnap()));
        }
        newEditorSnap() {
            return this.initEditor(8, new EEditorSnap({
                parent: this.editorContainer,
                selection: this.toolShapeSelect.selection,
                icons: this._icons,
                diagram: this.diagram
            }));
        }
        get editorButtonValidation() {
            var _a;
            return ((_a = this._editorButtonValidation) !== null && _a !== void 0 ? _a : (this._editorButtonValidation = this.newEditorButtonValidation()));
        }
        newEditorButtonValidation() {
            const theme = this._theme;
            return new wcardinalUi.DButton({
                group: this.editorButtonGroup,
                toggle: true,
                image: {
                    source: this._icons.editor_validation
                },
                title: theme.getEditorButtonValidationTitle(),
                theme: theme.getEditorButtonTheme(),
                on: {
                    active: () => {
                        this.editorValidation.show();
                    },
                    inactive: () => {
                        this.editorValidation.hide();
                    }
                }
            });
        }
        get editorValidation() {
            var _a;
            return ((_a = this._editorValidation) !== null && _a !== void 0 ? _a : (this._editorValidation = this.newEditorValidation()));
        }
        newEditorValidation() {
            return this.initEditor(9, new EEditorValidation({
                parent: this.editorContainer,
                selection: this.toolShapeSelect.selection,
                icons: this._icons,
                diagram: this.diagram,
                validator: this._validation.validator
            }));
        }
        get editorButtonSearch() {
            var _a;
            return ((_a = this._editorButtonSearch) !== null && _a !== void 0 ? _a : (this._editorButtonSearch = this.newEditorButtonSearch()));
        }
        newEditorButtonSearch() {
            const theme = this._theme;
            return new wcardinalUi.DButton({
                group: this.editorButtonGroup,
                toggle: true,
                image: {
                    source: this._icons.editor_search
                },
                title: theme.getEditorButtonSearchTitle(),
                theme: theme.getEditorButtonTheme(),
                on: {
                    active: () => {
                        this.editorSearch.show();
                    },
                    inactive: () => {
                        this.editorSearch.hide();
                    }
                }
            });
        }
        get editorSearch() {
            var _a;
            return ((_a = this._editorSearch) !== null && _a !== void 0 ? _a : (this._editorSearch = this.newEditorSearch()));
        }
        newEditorSearch() {
            return this.initEditor(9, new EEditorSearch({
                parent: this.editorContainer,
                selection: this.toolShapeSelect.selection,
                icons: this._icons,
                diagram: this.diagram,
                finder: this._search.finder,
                interval: this._search.interval
            }));
        }
        get editorCanvas() {
            var _a;
            return ((_a = this._editorCanvas) !== null && _a !== void 0 ? _a : (this._editorCanvas = this.newEditorCanvas()));
        }
        newEditorCanvas() {
            return new EEditorCanvas({
                icons: this._icons,
                diagram: this.diagram,
                canvas: this._canvas
            });
        }
        isEditorCanvasCompatible() {
            var _a, _b;
            return !!((_b = (_a = this._options.compatibility) === null || _a === void 0 ? void 0 : _a.editor) === null || _b === void 0 ? void 0 : _b.canvas);
        }
        get editorButtonCanvasLegacy() {
            var _a;
            return ((_a = this._editorButtonCanvasLegacy) !== null && _a !== void 0 ? _a : (this._editorButtonCanvasLegacy = this.newEditorButtonCanvasLegacy()));
        }
        newEditorButtonCanvasLegacy() {
            const theme = this._theme;
            return new wcardinalUi.DButton({
                group: this.editorButtonGroup,
                toggle: true,
                image: {
                    source: this._icons.editor_canvas_legacy
                },
                title: theme.getEditorButtonCanvasLegacyTitle(),
                theme: theme.getEditorButtonTheme(),
                on: {
                    active: () => {
                        this.editorCanvasLegacy.show();
                    },
                    inactive: () => {
                        this.editorCanvasLegacy.hide();
                    }
                }
            });
        }
        get editorCanvasLegacy() {
            var _a;
            return ((_a = this._editorCanvasLegacy) !== null && _a !== void 0 ? _a : (this._editorCanvasLegacy = this.newEditorCanvasLegacy()));
        }
        newEditorCanvasLegacy() {
            return this.initEditor(10, new EEditorCanvasLegacy({
                parent: this.editorContainer,
                diagram: this.diagram,
                canvas: this._canvas,
                content: {
                    theme: "EEditorPaneContent"
                }
            }));
        }
        newEditorButtonExtension(extension, editor) {
            let editorInstance = null;
            const result = new wcardinalUi.DButton({
                group: this.editorButtonGroup,
                toggle: true,
                image: {
                    source: extension.icon.texture
                },
                title: editor.title,
                theme: this._theme.getEditorButtonTheme(),
                visible: false,
                on: {
                    active: () => {
                        editorInstance !== null && editorInstance !== void 0 ? editorInstance : (editorInstance = this.newEditorExtension(editor));
                        editorInstance.show();
                    },
                    inactive: () => {
                        if (editorInstance) {
                            editorInstance.hide();
                        }
                    }
                }
            });
            const selection = this.toolShapeSelect.selection;
            selection.on("change", () => {
                this.onEditorButtonExtensionSelectionChange(result, extension.type);
            });
            return result;
        }
        newEditorExtension(editor) {
            return this.initEditor(11, new editor.constructor({
                parent: this.editorContainer,
                selection: this.toolShapeSelect.selection,
                diagram: this.diagram,
                icons: this._icons,
                content: {
                    theme: "EEditorPaneContent"
                },
                theme: editor.theme
            }));
        }
        onEditorButtonExtensionSelectionChange(button, extensionType) {
            const selection = this.toolShapeSelect.selection;
            const last = selection.last();
            const buttonLast = this._editorButtonExtensionLast;
            if (last != null && last.type === extensionType && buttonLast !== button) {
                let wasActive = false;
                if (buttonLast != null) {
                    buttonLast.hide();
                    if (buttonLast.state.isActive) {
                        buttonLast.activate();
                        wasActive = true;
                    }
                }
                button.show();
                this._editorButtonExtensionLast = button;
                if (wasActive && !button.state.isActive) {
                    button.activate();
                }
            }
        }
        get viewButtonZoomOut() {
            var _a;
            return ((_a = this._viewButtonZoomOut) !== null && _a !== void 0 ? _a : (this._viewButtonZoomOut = this.newViewButtonZoomOut()));
        }
        newViewButtonZoomOut() {
            const theme = this._theme;
            return new wcardinalUi.DButton({
                image: {
                    source: this._icons.view_zoom_out
                },
                title: theme.getViewButtonZoomOutTitle(),
                shortcut: theme.getViewButtonZoomOutShortcut(),
                theme: theme.getViewButtonTheme(),
                on: {
                    active: () => {
                        this.diagram.view.zoomOut();
                    }
                }
            });
        }
        get viewButtonZoomIn() {
            var _a;
            return ((_a = this._viewButtonZoomIn) !== null && _a !== void 0 ? _a : (this._viewButtonZoomIn = this.newViewButtonZoomIn()));
        }
        newViewButtonZoomIn() {
            const theme = this._theme;
            return new wcardinalUi.DButton({
                image: {
                    source: this._icons.view_zoom_in
                },
                title: theme.getViewButtonZoomInTitle(),
                shortcut: theme.getViewButtonZoomInShortcut(),
                shortcuts: theme.getViewButtonZoomInShortcuts(),
                theme: theme.getViewButtonTheme(),
                on: {
                    active: () => {
                        this.diagram.view.zoomIn();
                    }
                }
            });
        }
        get viewButtonDragAndPinch() {
            var _a;
            return ((_a = this._viewButtonDragAndPinch) !== null && _a !== void 0 ? _a : (this._viewButtonDragAndPinch = this.newViewButtonDragAndPinch()));
        }
        newViewButtonDragAndPinch() {
            const theme = this._theme;
            return new wcardinalUi.DButton({
                image: {
                    source: this._icons.camera
                },
                toggle: true,
                title: theme.getViewButtonDragAndPinchTitle(),
                shortcut: theme.getViewButtonDragAndPinchShortcut(),
                theme: theme.getViewButtonTheme(),
                on: {
                    active: () => {
                        this.toolGroup.suspend();
                    },
                    inactive: () => {
                        this.toolGroup.resume();
                    }
                }
            });
        }
        get viewButtonReset() {
            var _a;
            return ((_a = this._viewButtonReset) !== null && _a !== void 0 ? _a : (this._viewButtonReset = this.newViewButtonReset()));
        }
        newViewButtonReset() {
            const theme = this._theme;
            return new wcardinalUi.DButton({
                image: {
                    source: this._icons.view_reset
                },
                title: theme.getViewButtonResetTitle(),
                shortcut: theme.getViewButtonResetShortcut(),
                theme: theme.getViewButtonTheme(),
                on: {
                    active: () => {
                        this.diagram.view.reset();
                    }
                }
            });
        }
        get viewButtonFit() {
            var _a;
            return ((_a = this._viewButtonFit) !== null && _a !== void 0 ? _a : (this._viewButtonFit = this.newViewButtonFit()));
        }
        newViewButtonFit() {
            const theme = this._theme;
            return new wcardinalUi.DButton({
                image: {
                    source: this._icons.view_fit
                },
                title: theme.getViewButtonFitTitle(),
                shortcut: theme.getViewButtonFitShortcut(),
                theme: theme.getViewButtonTheme(),
                on: {
                    active: () => {
                        this.diagram.view.fit();
                    }
                }
            });
        }
        newEditorButtons() {
            const result = [
                this.editorButtonCoordinate,
                this.editorButtonShape,
                this.editorButtonText,
                this.editorButtonData,
                this.editorButtonDataMapping,
                this.editorButtonAction,
                this.editorButtonTree,
                this.editorButtonLayer,
                this.editorButtonSnap
            ];
            if (this._validation.validator != null) {
                result.push(this.editorButtonValidation);
            }
            result.push(this.editorButtonSearch);
            if (this.isEditorCanvasCompatible()) {
                result.push(this.editorButtonCanvasLegacy);
            }
            EShapeExtensions.each((extension) => {
                if ("editor" in extension) {
                    const editor = this.toEditorExtentionConstructorOptions(extension);
                    if (editor) {
                        result.push(this.newEditorButtonExtension(extension, editor));
                    }
                }
            });
            result.push(new wcardinalUi.DLayoutSpace({
                weight: 1
            }), this.viewButtonZoomOut, this.viewButtonZoomIn, this.viewButtonDragAndPinch, this.viewButtonReset, this.viewButtonFit);
            return result;
        }
        toEditorExtentionConstructorOptions(extension) {
            var _a, _b;
            const editor = extension.editor;
            if (wcardinalUi.isFunction(editor)) {
                return {
                    constructor: editor,
                    title: extension.name || "",
                    theme: "EEditorPane"
                };
            }
            else if (editor.constructor) {
                return {
                    constructor: editor.constructor,
                    title: (_a = editor.title) !== null && _a !== void 0 ? _a : (extension.name || ""),
                    theme: (_b = editor.theme) !== null && _b !== void 0 ? _b : "EEditorPane"
                };
            }
        }
        get editorContainer() {
            var _a;
            return ((_a = this._editorContainer) !== null && _a !== void 0 ? _a : (this._editorContainer = this.newEditorContainer()));
        }
        newEditorContainer() {
            return new wcardinalUi.DLayoutHorizontal({
                width: "auto",
                height: "padding"
            });
        }
        getEditorLayoutContainer() {
            return this._application.stage;
        }
        newEditorLayout() {
            const margin = this._margin;
            const y = this.getToolButtonLayoutY(margin);
            return new wcardinalUi.DLayoutHorizontal({
                x: (p, s) => p - s - margin,
                y,
                width: "auto",
                height: (p) => p - y - margin,
                theme: "EEditorLayout",
                children: [this.editorContainer, this.newEditorButtonLayout()],
                on: {
                    resize: (width, height) => {
                        this.onEditorLayoutResized(width, height);
                    }
                }
            });
        }
        newEditorButtonLayout() {
            return new wcardinalUi.DLayoutVertical({
                theme: "EEditorButtonLayout",
                children: this.newEditorButtons()
            });
        }
        onEditorLayoutResized(width, height) {
            // The tool layout width is `margin + 65`.
            // The editor layout width is `width`.
            // Therefore here shifts the diagram `(margin + 65 - width) * 0.5` along the X axis.
            const diagram = this.diagram;
            const theme = diagram.theme;
            const padding = diagram.padding;
            const margin = this._margin;
            const os = padding.getLeft() - padding.getRight();
            padding.left = theme.getPaddingLeft() + margin + 65;
            padding.right = theme.getPaddingRight() + margin + width;
            const canvas = diagram.canvas;
            if (canvas != null) {
                const ns = padding.getLeft() - padding.getRight();
                canvas.position.x += (ns - os) * 0.5;
            }
        }
        get toolShapeSelect() {
            var _a;
            return ((_a = this._toolShapeSelect) !== null && _a !== void 0 ? _a : (this._toolShapeSelect = this.newToolShapeSelect()));
        }
        newToolShapeSelect() {
            const diagram = this.diagram;
            const result = new EToolSelect({ diagram });
            diagram.on("set", () => {
                result.selection.clear();
            });
            diagram.on("unset", () => {
                result.selection.clear();
            });
            return result;
        }
        get toolShapeCreate() {
            var _a;
            return ((_a = this._toolShapeCreate) !== null && _a !== void 0 ? _a : (this._toolShapeCreate = this.newToolShapeCreate()));
        }
        newToolShapeCreate() {
            const result = new EToolShapeCreate(this.toolShapeSelect.selection, this.diagram);
            result.on("done", () => {
                this.toolShapeButtonSelect.activate();
            });
            return result;
        }
        get toolShapeCreateLine() {
            var _a;
            return ((_a = this._toolShapeCreateLine) !== null && _a !== void 0 ? _a : (this._toolShapeCreateLine = this.newToolShapeCreateLine()));
        }
        newToolShapeCreateLine() {
            const result = new EToolShapeCreateLine({
                selection: this.toolShapeSelect.selection,
                diagram: this.diagram
            });
            result.on("done", () => {
                this.toolShapeButtonSelect.activate();
            });
            result.on("cancel", () => {
                this.toolShapeButtonSelect.activate();
            });
            return result;
        }
        get toolShapeCreateLineConnector() {
            var _a;
            return ((_a = this._toolShapeCreateLineConnector) !== null && _a !== void 0 ? _a : (this._toolShapeCreateLineConnector = this.newToolShapeCreateLineConnector()));
        }
        newToolShapeCreateLineConnector() {
            const result = new EToolShapeCreateLineConnector({
                selection: this.toolShapeSelect.selection,
                diagram: this.diagram,
                dangling: this.isDanglingConnectorAllowed()
            });
            result.on("done", () => {
                this.toolShapeButtonSelect.activate();
            });
            result.on("cancel", () => {
                this.toolShapeButtonSelect.activate();
            });
            return result;
        }
        get toolShapeCreateElbowConnector() {
            var _a;
            return ((_a = this._toolShapeCreateElbowConnector) !== null && _a !== void 0 ? _a : (this._toolShapeCreateElbowConnector = this.newToolShapeCreateElbowConnector()));
        }
        newToolShapeCreateElbowConnector() {
            const result = new EToolShapeCreateElbowConnector({
                selection: this.toolShapeSelect.selection,
                diagram: this.diagram,
                dangling: this.isDanglingConnectorAllowed()
            });
            result.on("done", () => {
                this.toolShapeButtonSelect.activate();
            });
            result.on("cancel", () => {
                this.toolShapeButtonSelect.activate();
            });
            return result;
        }
        isDanglingConnectorAllowed() {
            var _a;
            return (_a = this._options.connector) === null || _a === void 0 ? void 0 : _a.dangling;
        }
        get toolShapeEditLine() {
            var _a;
            return ((_a = this._toolShapeEditLine) !== null && _a !== void 0 ? _a : (this._toolShapeEditLine = this.newToolShapeEditLine()));
        }
        newToolShapeEditLine() {
            const result = new EToolShapeEditLine({
                selection: this.toolShapeSelect.selection,
                diagram: this.diagram
            });
            result.on("done", () => {
                this.toolGroup.activate(this.toolShapeSelect);
            });
            result.on("cancel", () => {
                this.toolGroup.activate(this.toolShapeSelect);
            });
            return result;
        }
        get toolShapeEditLineConnector() {
            var _a;
            return ((_a = this._toolShapeEditLineConnector) !== null && _a !== void 0 ? _a : (this._toolShapeEditLineConnector = this.newToolShapeEditLineConnector()));
        }
        newToolShapeEditLineConnector() {
            const result = new EToolShapeEditLineConnector({
                selection: this.toolShapeSelect.selection,
                diagram: this.diagram,
                dangling: this.isDanglingConnectorAllowed()
            });
            result.on("done", () => {
                this.toolGroup.activate(this.toolShapeSelect);
            });
            result.on("cancel", () => {
                this.toolGroup.activate(this.toolShapeSelect);
            });
            return result;
        }
        get toolGroup() {
            var _a;
            return ((_a = this._toolGroup) !== null && _a !== void 0 ? _a : (this._toolGroup = this.newToolGroup()));
        }
        newToolGroup() {
            return new EToolGroupImpl();
        }
        get diagram() {
            var _a;
            return ((_a = this._diagram) !== null && _a !== void 0 ? _a : (this._diagram = this.newDiagram()));
        }
        newDiagram() {
            return new wcardinalUi.DDiagramEditor(this.toDiagramOptions(this._options));
        }
        getDiagramContainer() {
            return this._application.stage;
        }
        toDiagramOptions(options) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6;
            const result = options.diagram || {};
            // Controller
            (_a = result.controller) !== null && _a !== void 0 ? _a : (result.controller = this._controller.graphic);
            // Coordinate
            (_b = result.x) !== null && _b !== void 0 ? _b : (result.x = 0);
            (_c = result.y) !== null && _c !== void 0 ? _c : (result.y = 0);
            (_d = result.width) !== null && _d !== void 0 ? _d : (result.width = "100%");
            (_e = result.height) !== null && _e !== void 0 ? _e : (result.height = "100%");
            // Outline
            const outline = ((_f = result.outline) !== null && _f !== void 0 ? _f : (result.outline = {}));
            (_g = outline.color) !== null && _g !== void 0 ? _g : (outline.color = null);
            // View settings
            const view = ((_h = result.view) !== null && _h !== void 0 ? _h : (result.view = {}));
            const gesture = ((_j = view.gesture) !== null && _j !== void 0 ? _j : (view.gesture = {}));
            (_k = gesture.modifier) !== null && _k !== void 0 ? _k : (gesture.modifier = wcardinalUi.UtilGestureModifier.ALT);
            const checker = ((_l = gesture.checker) !== null && _l !== void 0 ? _l : (gesture.checker = {}));
            (_m = checker.start) !== null && _m !== void 0 ? _m : (checker.start = (e, modifier) => {
                return wcardinalUi.UtilGestureModifiers.match(e, modifier) || this.toolGroup.isSuspended();
            });
            (_o = checker.move) !== null && _o !== void 0 ? _o : (checker.move = (e, modifier) => {
                return wcardinalUi.UtilGestureModifiers.match(e, modifier) || this.diagram.state.isGesturing;
            });
            const zoom = ((_p = view.zoom) !== null && _p !== void 0 ? _p : (view.zoom = {}));
            const dblclick = ((_q = zoom.dblclick) !== null && _q !== void 0 ? _q : (zoom.dblclick = {}));
            (_r = dblclick.checker) !== null && _r !== void 0 ? _r : (dblclick.checker = (e, modifier) => {
                return this.toolGroup.isSuspended();
            });
            const viewOn = ((_s = view.on) !== null && _s !== void 0 ? _s : (view.on = {}));
            (_t = viewOn.gesturestart) !== null && _t !== void 0 ? _t : (viewOn.gesturestart = () => {
                this.onDiagramViewOnStart();
            });
            (_u = viewOn.transformstart) !== null && _u !== void 0 ? _u : (viewOn.transformstart = () => {
                this.onDiagramViewOnStart();
            });
            (_v = viewOn.wheeltranslationstart) !== null && _v !== void 0 ? _v : (viewOn.wheeltranslationstart = () => {
                this.onDiagramViewOnStart();
            });
            (_w = view.constraint) !== null && _w !== void 0 ? _w : (view.constraint = (target, x, y, scaleX, scaleY) => {
                this.onDiagramViewConstraint(target, x, y, scaleX, scaleY);
            });
            // Thumbnail settings
            const thumbnail = result.thumbnail;
            if (thumbnail === null || thumbnail === void 0 ? void 0 : thumbnail.enable) {
                (_x = thumbnail.size) !== null && _x !== void 0 ? _x : (thumbnail.size = getDialogSelectThumbnailSize() * 2);
            }
            // Event settings
            const on = ((_y = result.on) !== null && _y !== void 0 ? _y : (result.on = {}));
            (_z = on.saving) !== null && _z !== void 0 ? _z : (on.saving = () => {
                this.onDiagramSaving(this._toolFileButtonSave);
            });
            (_0 = on.saved) !== null && _0 !== void 0 ? _0 : (on.saved = (reason) => {
                this.onDiagramSaved(reason, this._toolFileButtonSave);
            });
            (_1 = on.deleting) !== null && _1 !== void 0 ? _1 : (on.deleting = () => {
                this.onDiagramDeleting(this._toolFileButtonDelete);
            });
            (_2 = on.deleted) !== null && _2 !== void 0 ? _2 : (on.deleted = (reason) => {
                this.onDiagramDeleted(reason, this._toolFileButtonDelete);
            });
            // Snapshot event settings
            const snapshot = ((_3 = result.snapshot) !== null && _3 !== void 0 ? _3 : (result.snapshot = {}));
            const snapshotOn = ((_4 = snapshot.on) !== null && _4 !== void 0 ? _4 : (snapshot.on = {}));
            (_5 = snapshotOn.taking) !== null && _5 !== void 0 ? _5 : (snapshotOn.taking = () => {
                this.onDiagramSnapshotTaking();
            });
            (_6 = snapshotOn.took) !== null && _6 !== void 0 ? _6 : (snapshotOn.took = () => {
                this.onDiagramSnapshotTook();
            });
            // Done
            return result;
        }
        onDiagramViewOnStart() {
            var _a, _b;
            const diagram = this._diagram;
            if (diagram != null) {
                const d = ((_a = this._localBoundsDiagram) !== null && _a !== void 0 ? _a : (this._localBoundsDiagram = new pixi_js.Rectangle()));
                const p = diagram.padding;
                const l = p.getLeft() - 65 - this._margin;
                const t = p.getTop();
                const r = diagram.width - p.getRight();
                const b = diagram.height - p.getBottom();
                d.x = l;
                d.y = t;
                d.width = Math.max(0, r - l);
                d.height = Math.max(0, b - t);
                const canvas = diagram.canvas;
                if (canvas != null) {
                    const c = ((_b = this._localBoundsCanvas) !== null && _b !== void 0 ? _b : (this._localBoundsCanvas = new pixi_js.Rectangle()));
                    canvas.getLocalBounds(c);
                }
            }
        }
        onDiagramViewConstraint(target, x, y, sx, sy) {
            const d = this._localBoundsDiagram;
            const c = this._localBoundsCanvas;
            if (d != null && c != null) {
                target.position.set(Math.max(d.x - (c.x + c.width) * sx, Math.min(d.x + d.width - c.x * sx, x)), Math.max(d.y - (c.y + c.height) * sy, Math.min(d.y + d.height - c.y * sy, y)));
                target.scale.set(sx, sy);
            }
        }
        onDiagramSaving(opener) {
            this.dialogSaveProcessing.open(opener);
        }
        onDiagramSaved(reason, opener) {
            const dialogSaveProcessing = this.dialogSaveProcessing;
            if (reason == null) {
                dialogSaveProcessing.resolve();
            }
            else {
                if (reason === "duplication") {
                    dialogSaveProcessing.once("close", () => {
                        this.dialogSaveAs.open(opener);
                    });
                }
                dialogSaveProcessing.reject(reason);
            }
        }
        onDiagramDeleting(opener) {
            this.dialogDeleteProcessing.open(opener);
        }
        onDiagramDeleted(reason, opener) {
            const dialogDeleteProcessing = this.dialogDeleteProcessing;
            if (reason == null) {
                dialogDeleteProcessing.resolve();
            }
            else {
                dialogDeleteProcessing.reject(reason);
            }
        }
        onDiagramSnapshotTaking() {
            this.toolShapeSelect.selection.modifier.renderable = false;
        }
        onDiagramSnapshotTook() {
            this.toolShapeSelect.selection.modifier.renderable = true;
        }
        get dialogSaveProcessing() {
            var _a;
            return ((_a = this._dialogSaveProcessing) !== null && _a !== void 0 ? _a : (this._dialogSaveProcessing = this.newDialogSaveProcessing()));
        }
        newDialogSaveProcessing() {
            return new EDialogProcessing();
        }
        get dialogDeleteProcessing() {
            var _a;
            return ((_a = this._dialogDeleteProcessing) !== null && _a !== void 0 ? _a : (this._dialogDeleteProcessing = this.newDialogDeleteProcessing()));
        }
        newDialogDeleteProcessing() {
            return new EDialogProcessing();
        }
        get dialogSaveAs() {
            var _a;
            return ((_a = this._dialogSaveAs) !== null && _a !== void 0 ? _a : (this._dialogSaveAs = this.newDialogSaveAs()));
        }
        newDialogSaveAs() {
            return new wcardinalUi.DDialogSaveAs();
        }
        get dialogCreate() {
            var _a;
            return ((_a = this._dialogCreate) !== null && _a !== void 0 ? _a : (this._dialogCreate = this.newDialogCreate()));
        }
        newDialogCreate() {
            return this._canvas.get().then((canvas) => {
                return new EDialogCanvas({
                    canvas,
                    on: {
                        ok: (value, emitter) => {
                            this.onDialogCreateOk(value, emitter);
                        }
                    }
                });
            });
        }
        onDialogCreateOk(value, opener) {
            this.diagram.create(value).then((canvas) => {
                wcardinalUi.DControllers.getCommandController().push(new ECommandDocumentCreate(this.diagram, canvas));
            });
        }
        get dialogDiscard() {
            var _a;
            return ((_a = this._dialogDiscard) !== null && _a !== void 0 ? _a : (this._dialogDiscard = this.newDialogDiscard()));
        }
        newDialogDiscard() {
            return new wcardinalUi.DDialogConfirmDiscard();
        }
        get dialogSelect() {
            var _a;
            return ((_a = this._dialogSelect) !== null && _a !== void 0 ? _a : (this._dialogSelect = this.newDialogSelect()));
        }
        newDialogSelect() {
            return this._canvas.get().then((canvas) => {
                var _a, _b;
                if ((_b = (_a = this._options.diagram) === null || _a === void 0 ? void 0 : _a.thumbnail) === null || _b === void 0 ? void 0 : _b.enable) {
                    const result = this.newDialogSelectImage();
                    result.categories = canvas.category.items;
                    return result;
                }
                else {
                    const result = this.newDialogSelectNoImage();
                    result.categories = canvas.category.items;
                    return result;
                }
            });
        }
        newDialogSelectNoImage() {
            return new wcardinalUi.DDialogSelect({
                controller: this._controller.graphic,
                on: {
                    select: (value) => {
                        this.onDialogSelectSelect(value);
                    }
                }
            });
        }
        onDialogSelectSelect(value) {
            this.diagram.open(value.id).then((canvas) => {
                wcardinalUi.DControllers.getCommandController().push(new ECommandDocumentOpen(this.diagram, canvas));
            });
        }
        newDialogSelectImage() {
            return newDialogSelectWithThumbnails(this._options.controller.graphic, this._controller.toThumbnail, (value) => {
                this.onDialogSelectSelect(value);
            });
        }
        get dialogSelectPiece() {
            var _a;
            return ((_a = this._dialogSelectPiece) !== null && _a !== void 0 ? _a : (this._dialogSelectPiece = this.newDialogSelectPiece()));
        }
        newDialogSelectPiece() {
            return this._canvas.get().then((canvas) => {
                var _a, _b;
                if ((_b = (_a = this._options.diagram) === null || _a === void 0 ? void 0 : _a.thumbnail) === null || _b === void 0 ? void 0 : _b.enable) {
                    const result = this.newDialogSelectPieceImage();
                    result.categories = canvas.category.items;
                    return result;
                }
                else {
                    const result = this.newDialogSelectPieceNoImage();
                    result.categories = canvas.category.items;
                    return result;
                }
            });
        }
        newDialogSelectPieceNoImage() {
            return new wcardinalUi.DDialogSelect({
                controller: this.newDialogSelectPieceController(),
                on: {
                    select: (value) => {
                        this.onDialogSelectPieceSelect(value);
                    }
                }
            });
        }
        newDialogSelectPieceImage() {
            return newDialogSelectWithThumbnails(this.newDialogSelectPieceController(), this._options.controller.toPieceThumbnail, (value) => {
                this.onDialogSelectPieceSelect(value);
            });
        }
        newDialogSelectPieceController() {
            const graphicPiece = this._options.controller.graphic.piece;
            return {
                search: (word, categoryId) => {
                    if (categoryId === undefined) {
                        return graphicPiece.search(word).then((pieces) => {
                            return this.toDialogSelectPieceResult(pieces);
                        });
                    }
                    else {
                        return graphicPiece.search(word, categoryId).then((pieces) => {
                            return this.toDialogSelectPieceResult(pieces);
                        });
                    }
                }
            };
        }
        toDialogSelectPieceResult(targets) {
            const pieceId = this._toPieceId(this.diagram);
            if (pieceId == null) {
                return targets;
            }
            const result = [];
            for (let i = 0, imax = targets.length; i < imax; ++i) {
                const target = targets[i];
                if (target.id !== pieceId) {
                    result.push(target);
                }
            }
            return result;
        }
        onDialogSelectPieceSelect(value) {
            const diagram = this.diagram;
            const layer = diagram.layer;
            const canvas = diagram.canvas;
            if (canvas && layer) {
                const graphic = this._options.controller.graphic;
                graphic.piece.get(value.id).then((serialized) => {
                    wcardinalUi.EShapeEmbeddeds.from(serialized, graphic, wcardinalUi.EShapeResourceManagerDeserializationMode.EDITOR).then((shape) => {
                        shape.transform.position.set(canvas.width * 0.5, canvas.height * 0.5);
                        shape.attach(layer);
                        wcardinalUi.DControllers.getCommandController().push(new ECommandShapeCreate([shape], layer, this.toolShapeSelect.selection, true));
                    });
                });
            }
        }
        get dialogDelete() {
            var _a;
            return ((_a = this._dialogDelete) !== null && _a !== void 0 ? _a : (this._dialogDelete = this.newDialogDelete()));
        }
        newDialogDelete() {
            return new wcardinalUi.DDialogConfirmDelete({
                on: {
                    ok: (value, emitter) => {
                        this.onDialogDeleteOk(emitter);
                    }
                }
            });
        }
        onDialogDeleteOk(opener) {
            this.diagram.delete().then(() => {
                wcardinalUi.DControllers.getCommandController().clear();
            });
        }
        toTheme(options) {
            const theme = options === null || options === void 0 ? void 0 : options.theme;
            if (theme) {
                if (wcardinalUi.isString(theme)) {
                    return wcardinalUi.DThemes.getInstance().get(theme);
                }
                return theme;
            }
            return this.getThemeDefault();
        }
        getThemeDefault() {
            return wcardinalUi.DThemes.getInstance().get(this.getType());
        }
        getType() {
            return "FGraphicEditor";
        }
    }

    class FGraphicTester {
        constructor(options) {
            var _a, _b;
            this._options = options;
            const theme = this.toTheme(options);
            this._theme = theme;
            this._controller = options.controller;
            this._category = new UtilCanvasCategory((_a = options.canvas) === null || _a === void 0 ? void 0 : _a.category);
            this._icons = theme.getIconBuilder().build();
            const margin = (_b = options.margin) !== null && _b !== void 0 ? _b : theme.getMargin();
            this._margin = margin;
            this._isEditable = options.editable !== false;
            this._isChanged = false;
            this._onDiagramMoveBound = (e) => {
                this.onDiagramMove(e);
            };
            this._onDiagramUpBound = (e) => {
                this.onDiagramUp(e);
            };
            this._onDiagramDownPoint = new pixi_js.Point();
            this._onDiagramMovePoint = new pixi_js.Point();
            this._selectAreaRect = new pixi_js.Rectangle();
            this._selectMode = 0 /* EToolSelectMode.NONE */;
            this._childSelectTime = 0;
            this._childSelectChild = null;
            this._isSelectSuspended = false;
            this._expressionMap = new Map();
            this._appliedValues = new Map();
            this._isMappingsDirty = false;
            // Application
            const application = new wcardinalUi.DApplication(options.application);
            this._application = application;
            // Panes
            application.stage.addChild(this.newPanes(options));
            this.onChange();
            const onMappingsChangeBound = () => {
                if (this._isMappingsDirty) {
                    this._isMappingsDirty = false;
                    this.onMappingsChange();
                }
                setTimeout(onMappingsChangeBound, 100);
            };
            onMappingsChangeBound();
        }
        get application() {
            return this._application;
        }
        get controller() {
            return this._controller;
        }
        newHeader(options) {
            const header = options.header;
            if (header) {
                const result = header();
                if (result) {
                    const margin = this._margin;
                    result.x = margin;
                    result.y = margin;
                    result.setWidth((p) => p);
                    return result;
                }
            }
            return null;
        }
        newPanes(options) {
            const margin = this._margin;
            return new wcardinalUi.DLayoutVertical({
                x: margin,
                y: margin,
                width: (p) => p - 2 * margin,
                height: (p) => p - 2 * margin,
                margin: margin,
                children: [
                    this.newHeader(options),
                    new wcardinalUi.DLayoutHorizontal({
                        weight: 1,
                        width: "padding",
                        margin: this._margin * 0.5,
                        children: [this.leftPane, this.rightPane]
                    })
                ]
            });
        }
        get leftPane() {
            let result = this._paneLeft;
            if (result == null) {
                result = this.newLeftPane();
                this._paneLeft = result;
            }
            return result;
        }
        newLeftPane() {
            return new wcardinalUi.DBoard({
                weight: 1,
                height: "padding",
                shadow: "WEAK",
                children: [this.diagram, this.toolFileButtonGraphicOpen, this.layoutViewButton]
            });
        }
        get toolFileButtonGraphicOpen() {
            let result = this._toolFileButtonGraphicOpen;
            if (result == null) {
                result = this.newToolFileButtonGraphicOpen();
                this._toolFileButtonGraphicOpen = result;
            }
            return result;
        }
        newToolFileButtonGraphicOpen() {
            const theme = this._theme;
            const margin = this._margin * 0.5;
            return new wcardinalUi.DButton({
                x: margin,
                y: margin,
                image: {
                    source: this._icons.open
                },
                title: theme.getToolFileButtonGraphicOpenTitle(),
                shortcut: theme.getToolFileButtonGraphicOpenShortcut(),
                theme: theme.getToolFileButtonGraphicTheme(),
                on: {
                    active: (emitter) => {
                        this.onToolFileButtonGraphicOpenActive(emitter);
                    }
                }
            });
        }
        onToolFileButtonGraphicOpenActive(opener) {
            if (this.isChanged) {
                this.dialogDiscard.open(opener).then(() => {
                    this.dialogSelectGraphic.then((dialogSelectGraphic) => {
                        dialogSelectGraphic.open(opener);
                    });
                });
            }
            else {
                this.dialogSelectGraphic.then((dialogSelectGraphic) => {
                    dialogSelectGraphic.open(opener);
                });
            }
        }
        get layoutViewButton() {
            let result = this._layoutViewButton;
            if (result == null) {
                result = this.newLayoutViewButton();
                this._layoutViewButton = result;
            }
            return result;
        }
        newLayoutViewButton() {
            const margin = this._margin * 0.5;
            const position = (p, s) => p - s - margin;
            return new wcardinalUi.DLayoutHorizontal({
                x: position,
                y: position,
                width: "auto",
                height: "auto",
                margin: 0,
                padding: 0,
                children: this.newViewButtons()
            });
        }
        newViewButtons() {
            return [
                this.viewButtonZoomOut,
                this.viewButtonZoomIn,
                this.viewButtonDragAndPinch,
                this.viewButtonReset,
                this.viewButtonFit
            ];
        }
        get viewButtonZoomOut() {
            let result = this._viewButtonZoomOut;
            if (result == null) {
                result = this.newViewButtonZoomOut();
                this._viewButtonZoomOut = result;
            }
            return result;
        }
        newViewButtonZoomOut() {
            const theme = this._theme;
            return new wcardinalUi.DButton({
                image: {
                    source: this._icons.view_zoom_out
                },
                title: theme.getViewButtonZoomOutTitle(),
                shortcut: theme.getViewButtonZoomOutShortcut(),
                theme: theme.getViewButtonTheme(),
                on: {
                    active: () => {
                        this.diagram.view.zoomOut();
                    }
                }
            });
        }
        get viewButtonZoomIn() {
            let result = this._viewButtonZoomIn;
            if (result == null) {
                result = this.newViewButtonZoomIn();
                this._viewButtonZoomIn = result;
            }
            return result;
        }
        newViewButtonZoomIn() {
            const theme = this._theme;
            return new wcardinalUi.DButton({
                image: {
                    source: this._icons.view_zoom_in
                },
                title: theme.getViewButtonZoomInTitle(),
                shortcut: theme.getViewButtonZoomInShortcut(),
                shortcuts: theme.getViewButtonZoomInShortcuts(),
                theme: theme.getViewButtonTheme(),
                on: {
                    active: () => {
                        this.diagram.view.zoomIn();
                    }
                }
            });
        }
        get viewButtonReset() {
            let result = this._viewButtonReset;
            if (result == null) {
                result = this.newViewButtonReset();
                this._viewButtonReset = result;
            }
            return result;
        }
        newViewButtonReset() {
            const theme = this._theme;
            return new wcardinalUi.DButton({
                image: {
                    source: this._icons.view_reset
                },
                title: theme.getViewButtonResetTitle(),
                shortcut: theme.getViewButtonResetShortcut(),
                theme: theme.getViewButtonTheme(),
                on: {
                    active: () => {
                        this.diagram.view.reset();
                    }
                }
            });
        }
        get viewButtonDragAndPinch() {
            let result = this._viewButtonDragAndPinch;
            if (result == null) {
                result = this.newViewButtonDragAndPinch();
                this._viewButtonDragAndPinch = result;
            }
            return result;
        }
        newViewButtonDragAndPinch() {
            const theme = this._theme;
            return new wcardinalUi.DButton({
                image: {
                    source: this._icons.camera
                },
                toggle: true,
                title: theme.getViewButtonDragAndPinchTitle(),
                shortcut: theme.getViewButtonDragAndPinchShortcut(),
                theme: theme.getViewButtonTheme(),
                on: {
                    active: () => {
                        this._isSelectSuspended = true;
                    },
                    inactive: () => {
                        this._isSelectSuspended = false;
                    }
                }
            });
        }
        get viewButtonFit() {
            let result = this._viewButtonFit;
            if (result == null) {
                result = this.newViewButtonFit();
                this._viewButtonFit = result;
            }
            return result;
        }
        newViewButtonFit() {
            const theme = this._theme;
            return new wcardinalUi.DButton({
                image: {
                    source: this._icons.view_fit
                },
                title: theme.getViewButtonFitTitle(),
                shortcut: theme.getViewButtonFitShortcut(),
                theme: theme.getViewButtonTheme(),
                on: {
                    active: () => {
                        this.diagram.view.fit();
                    }
                }
            });
        }
        get rightPane() {
            let result = this._paneRight;
            if (result == null) {
                result = this.newRightPane();
                this._paneRight = result;
            }
            return result;
        }
        newRightPane() {
            return new wcardinalUi.DLayoutVertical({
                width: 400,
                height: "padding",
                margin: this._margin * 0.5,
                children: [
                    new wcardinalUi.DLayoutHorizontal({
                        width: "padding",
                        height: "auto",
                        children: [
                            new wcardinalUi.DLayoutSpace({
                                weight: 1
                            }),
                            this.toolFileButtonCreate,
                            this.toolFileButtonOpen,
                            this.toolFileButtonSave,
                            this.toolFileButtonDelete
                        ]
                    }),
                    this.inputName,
                    new wcardinalUi.DLayoutHorizontal({
                        width: "padding",
                        height: "auto",
                        children: [
                            this.tableFilterInput,
                            this.toolFileButtonUpload,
                            this.toolFileButtonDownload
                        ]
                    }),
                    this.table
                ]
            });
        }
        get dialogProcessing() {
            let result = this._dialogProcessing;
            if (result == null) {
                result = this.newDialogProcessing();
                this._dialogProcessing = result;
            }
            return result;
        }
        newDialogProcessing() {
            return new EDialogProcessing();
        }
        get dialogDelete() {
            let result = this._dialogConfirmDelete;
            if (result == null) {
                result = this.newDialogDelete();
                this._dialogConfirmDelete = result;
            }
            return result;
        }
        newDialogDelete() {
            return new wcardinalUi.DDialogConfirmDelete({
                on: {
                    ok: () => {
                        const tester = this._tester;
                        if (tester) {
                            if (tester.id != null) {
                                this._controller.graphicTester.delete(tester.id);
                            }
                            this.tester = undefined;
                        }
                    }
                }
            });
        }
        get tableFilterInput() {
            let result = this._tableFilterInput;
            if (result == null) {
                result = this.newTableFilterInput();
                this._tableFilterInput = result;
            }
            return result;
        }
        newTableFilterInput() {
            return new wcardinalUi.DInputSearch({
                weight: 1,
                on: {
                    input: (value) => {
                        const word = value.trim();
                        this.tableFilter.word = word;
                        const filter = this.table.data.filter;
                        if (0 < word.length) {
                            filter.apply();
                        }
                        else {
                            filter.unapply();
                        }
                    }
                }
            });
        }
        get toolFileButtonCreate() {
            let result = this._toolFileButtonCreate;
            if (result == null) {
                result = this.newToolFileButtonCreate();
                this._toolFileButtonCreate = result;
            }
            return result;
        }
        newToolFileButtonCreate() {
            const theme = this._theme;
            return new wcardinalUi.DButton({
                image: {
                    source: this.icons.new
                },
                title: theme.getToolFileButtonCreateTitle(),
                shortcut: theme.getToolFileButtonCreateShortcut(),
                theme: theme.getToolFileButtonTheme(),
                on: {
                    active: (emitter) => {
                        this.onToolFileButtonCreateActive(emitter);
                    }
                }
            });
        }
        onToolFileButtonCreateActive(opener) {
            if (this.isChanged) {
                this.dialogDiscard.open(opener).then(() => {
                    this.dialogCreate.open(opener);
                });
            }
            else {
                this.dialogCreate.open(opener);
            }
        }
        get toolFileButtonOpen() {
            let result = this._toolFileButtonOpen;
            if (result == null) {
                result = this.newToolFileButtonOpen();
                this._toolFileButtonOpen = result;
            }
            return result;
        }
        newToolFileButtonOpen() {
            const theme = this._theme;
            return new wcardinalUi.DButton({
                image: {
                    source: this.icons.open
                },
                title: theme.getToolFileButtonOpenTitle(),
                shortcut: theme.getToolFileButtonOpenShortcut(),
                theme: theme.getToolFileButtonTheme(),
                on: {
                    active: (emitter) => {
                        this.onToolFileButtonOpenActive(emitter);
                    }
                }
            });
        }
        onToolFileButtonOpenActive(opener) {
            if (this.isChanged) {
                this.dialogDiscard.open(opener).then(() => {
                    this.dialogSelectMapping.open(opener);
                });
            }
            else {
                this.dialogSelectMapping.open(opener);
            }
        }
        get toolFileButtonUpload() {
            let result = this._toolFileButtonUpload;
            if (result == null) {
                result = this.newToolFileButtonUpload();
                this._toolFileButtonUpload = result;
            }
            return result;
        }
        newToolFileButtonUpload() {
            const theme = this._theme;
            return new wcardinalUi.DButtonFile({
                image: {
                    source: this.icons.upload
                },
                title: theme.getToolFileButtonUploadTitle(),
                shortcut: theme.getToolFileButtonUploadShortcut(),
                theme: theme.getToolFileButtonTheme(),
                as: wcardinalUi.DButtonFileAs.TEXT,
                on: {
                    open: (data, file) => {
                        this.onToolFileButtonUploadOpen(data, file);
                    }
                }
            });
        }
        onToolFileButtonUploadOpen(data, file) {
            const tester = this._tester;
            if (tester) {
                tester.mappings = toGraphicTesterObject(data);
                this.onDiagramSelectionChange();
                this.toDirty();
                this.toMappingsDirty();
            }
        }
        get toolFileButtonDownload() {
            let result = this._toolFileButtonDownload;
            if (result == null) {
                result = this.newToolFileButtonDownload();
                this._toolFileButtonDownload = result;
            }
            return result;
        }
        newToolFileButtonDownload() {
            const theme = this._theme;
            return new wcardinalUi.DButton({
                image: {
                    source: this.icons.download
                },
                title: theme.getToolFileButtonDownloadTitle(),
                shortcut: theme.getToolFileButtonDownloadShortcut(),
                theme: theme.getToolFileButtonTheme(),
                on: {
                    active: () => {
                        this.onToolFileButtonDownloadActive();
                    }
                }
            });
        }
        onToolFileButtonDownloadActive() {
            const graphic = this._graphic;
            const tester = this._tester;
            if (graphic && tester) {
                const diagram = this.diagram;
                const canvas = diagram.canvas;
                if (canvas) {
                    const layers = canvas.layer.children;
                    const uuidToDataValueIds = new Map();
                    const rows = [];
                    for (let i = 0, imax = layers.length; i < imax; ++i) {
                        this.toCsvRows(layers[i].children, tester.mappings, null, uuidToDataValueIds, rows);
                    }
                    rows.sort((a, b) => {
                        return a[0] - b[0];
                    });
                    wcardinalUi.UtilFileDownloader.download(this.getFilename(), UtilCsv.stringify(rows));
                }
            }
        }
        toCsvRows(shapes, mappings, dataShape, uuidToDataValueIds, result) {
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                const uuid = (dataShape || shape).uuid;
                const object = mappings.get(uuid);
                const data = shape.data;
                let dataValueIds = uuidToDataValueIds.get(uuid);
                if (dataValueIds == null) {
                    dataValueIds = new Set();
                    uuidToDataValueIds.set(uuid, dataValueIds);
                }
                for (let j = 0, jmax = data.size(); j < jmax; ++j) {
                    const dataValue = data.get(j);
                    if (dataValue) {
                        const dataValueId = dataValue.id;
                        if (!dataValueIds.has(dataValueId)) {
                            dataValueIds.add(dataValueId);
                            const value = (object && object[dataValueId]) || "";
                            result.push([uuid, dataValueId, value]);
                        }
                    }
                }
                this.toCsvRows(shape.children, mappings, this.toDataShape(dataShape, shape), uuidToDataValueIds, result);
            }
            return result;
        }
        get toolFileButtonSave() {
            let result = this._toolFileButtonSave;
            if (result == null) {
                result = this.newToolFileButtonSave();
                this._toolFileButtonSave = result;
            }
            return result;
        }
        newToolFileButtonSave() {
            const theme = this._theme;
            return new wcardinalUi.DButton({
                image: {
                    source: this.icons.save
                },
                title: theme.getToolFileButtonSaveTitle(),
                shortcut: theme.getToolFileButtonSaveShortcut(),
                theme: theme.getToolFileButtonTheme(),
                on: {
                    active: (emitter) => {
                        this.onToolFileButtonSaveActive(emitter);
                    }
                }
            });
        }
        onToolFileButtonSaveActive(opener) {
            const graphic = this._graphic;
            const tester = this._tester;
            if (graphic && tester) {
                tester.name = this.inputName.input.value;
                const simple = toGraphicTesterSimple(tester);
                const dialogProcessing = this.dialogProcessing;
                dialogProcessing.open(opener);
                this._controller.graphicTester.save(simple).then((id) => {
                    simple.id = id;
                    this.tester = toGraphicTesterSerialized(simple);
                    dialogProcessing.resolve();
                }, (reason) => {
                    dialogProcessing.reject(reason);
                });
            }
        }
        get toolFileButtonDelete() {
            let result = this._toolFileButtonDelete;
            if (result == null) {
                result = this.newToolFileButtonDelete();
                this._toolFileButtonDelete = result;
            }
            return result;
        }
        newToolFileButtonDelete() {
            const theme = this._theme;
            return new wcardinalUi.DButton({
                image: {
                    source: this.icons.delete
                },
                title: theme.getToolFileButtonDeleteTitle(),
                shortcut: theme.getToolFileButtonDeleteShortcut(),
                theme: theme.getToolFileButtonTheme(),
                on: {
                    active: (emitter) => {
                        this.onToolFileButtonDeleteActive(emitter);
                    }
                }
            });
        }
        onToolFileButtonDeleteActive(opener) {
            this.dialogDelete.open(opener);
        }
        get inputName() {
            let result = this._inputName;
            if (result == null) {
                result = this.newInputName();
                this._inputName = result;
            }
            return result;
        }
        newInputName() {
            return new wcardinalUi.DInputTextAndLabel({
                width: "100%",
                label: {
                    text: {
                        value: this._theme.getInputNameLabel()
                    }
                },
                input: {
                    weight: 1,
                    on: {
                        change: () => {
                            this.toDirty();
                        }
                    }
                }
            });
        }
        get icons() {
            return this._icons;
        }
        get diagram() {
            let result = this._diagram;
            if (result == null) {
                result = this.newDiagram();
                this._diagram = result;
            }
            return result;
        }
        newDiagram() {
            const result = new wcardinalUi.DDiagram(this.toDiagramOptions(this._options));
            result.on("down", (e, diagram) => {
                this.onDiagramDown(e, diagram);
            });
            result.on("keydown", (e) => {
                this.onDiagramKeydown(e);
            });
            return result;
        }
        toDiagramOptions(options) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
            const result = options.diagram || {};
            (_a = result.controller) !== null && _a !== void 0 ? _a : (result.controller = this._controller.graphic);
            (_b = result.width) !== null && _b !== void 0 ? _b : (result.width = "100%");
            (_c = result.height) !== null && _c !== void 0 ? _c : (result.height = "100%");
            (_d = result.mask) !== null && _d !== void 0 ? _d : (result.mask = true);
            (_e = result.ambient) !== null && _e !== void 0 ? _e : (result.ambient = true);
            const view = ((_f = result.view) !== null && _f !== void 0 ? _f : (result.view = {}));
            const gesture = ((_g = view.gesture) !== null && _g !== void 0 ? _g : (view.gesture = {}));
            (_h = gesture.modifier) !== null && _h !== void 0 ? _h : (gesture.modifier = wcardinalUi.UtilGestureModifier.ALT);
            const checker = ((_j = gesture.checker) !== null && _j !== void 0 ? _j : (gesture.checker = {}));
            (_k = checker.start) !== null && _k !== void 0 ? _k : (checker.start = (e, modifier) => {
                return wcardinalUi.UtilGestureModifiers.match(e, modifier) || this._isSelectSuspended;
            });
            (_l = checker.move) !== null && _l !== void 0 ? _l : (checker.move = (e, modifier) => {
                const diagram = this._diagram;
                return (wcardinalUi.UtilGestureModifiers.match(e, modifier) || !!(diagram && diagram.state.isGesturing));
            });
            const zoom = ((_m = view.zoom) !== null && _m !== void 0 ? _m : (view.zoom = {}));
            const dblclick = ((_o = zoom.dblclick) !== null && _o !== void 0 ? _o : (zoom.dblclick = {}));
            (_p = dblclick.checker) !== null && _p !== void 0 ? _p : (dblclick.checker = (e, modifier) => {
                return this._isSelectSuspended;
            });
            return result;
        }
        get selection() {
            let result = this._selection;
            if (result == null) {
                result = new EToolSelectSelection({
                    diagram: this.diagram,
                    modifier: {
                        editable: false
                    }
                });
                result.on("change", () => {
                    this.onDiagramSelectionChange();
                });
                this._selection = result;
            }
            return result;
        }
        toDataMappingRows(shapes, mappings, dataShape, dataValueIdToRow, result) {
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                const uuid = (dataShape || shape).uuid;
                const object = mappings.get(uuid);
                const data = shape.data;
                for (let j = 0, jmax = data.size(); j < jmax; ++j) {
                    const dataValue = data.get(j);
                    if (dataValue != null) {
                        const dataValueId = dataValue.id;
                        const value = (object && object[dataValueId]) || "";
                        let row = dataValueIdToRow.get(dataValueId);
                        if (row == null) {
                            row = {
                                uuids: [uuid],
                                id: dataValueId,
                                value
                            };
                            dataValueIdToRow.set(dataValueId, row);
                            result.push(row);
                        }
                        else {
                            row.uuids.push(uuid);
                            row.value = value;
                        }
                    }
                }
                this.toDataMappingRows(shape.children, mappings, this.toDataShape(dataShape, shape), dataValueIdToRow, result);
            }
            return result;
        }
        toDataShape(dataShape, shape) {
            if (dataShape) {
                return dataShape;
            }
            if (shape instanceof wcardinalUi.EShapeEmbedded) {
                return shape;
            }
            return null;
        }
        onDiagramSelectionChange() {
            const selection = this._selection;
            const tester = this._tester;
            const table = this.table;
            if (selection && tester) {
                const shapes = selection.get();
                if (0 < shapes.length) {
                    const rows = [];
                    this.toDataMappingRows(shapes, tester.mappings, null, new Map(), rows);
                    table.data.clearAndAddAll(rows);
                }
                else {
                    table.data.clear();
                }
            }
            else {
                table.data.clear();
            }
        }
        onDiagramDown(e, diagram) {
            if (this._isSelectSuspended) {
                return;
            }
            const originalEvent = e.data.originalEvent;
            if (originalEvent.altKey) {
                return;
            }
            const diagramCanvas = diagram.canvas;
            if (diagramCanvas) {
                const isAddMode = originalEvent.ctrlKey || originalEvent.shiftKey;
                if (this._selectMode === 1 /* EToolSelectMode.SELECT */) {
                    this._selectMode = 0 /* EToolSelectMode.NONE */;
                    this.onDiagramSelectEnd(diagramCanvas, isAddMode);
                    return;
                }
                const global = e.data.global;
                const onDownPoint = this._onDiagramDownPoint;
                onDownPoint.copyFrom(global);
                const selection = this.selection;
                const hitObject = this.hitTest(global, diagramCanvas);
                if (hitObject instanceof wcardinalUi.EShapeBase) {
                    if (isAddMode) {
                        selection.toggle(hitObject);
                    }
                    else if (!selection.contains(hitObject)) {
                        const first = selection.first();
                        if (first == null) {
                            selection.set(hitObject.root);
                        }
                        else {
                            const selected = UtilShapeSearch.toSelected(hitObject);
                            if (selected != null) {
                                if (wcardinalUi.EShapeCapabilities.contains(selected, wcardinalUi.EShapeCapability.CHILDREN)) {
                                    this._childSelectTime = Date.now();
                                    this._childSelectChild = UtilShapeSearch.toOfParent(hitObject, selected);
                                }
                            }
                            else {
                                const sharedParent = UtilShapeSearch.toSharedParent(first, hitObject);
                                selection.set(UtilShapeSearch.toOfParent(hitObject, sharedParent));
                            }
                        }
                    }
                    this._selectMode = 2 /* EToolSelectMode.TRANSLATE */;
                }
                else {
                    // Select area
                    const area = this.selectArea;
                    diagramCanvas.toLocal(global, undefined, onDownPoint);
                    area.x = onDownPoint.x;
                    area.y = onDownPoint.y;
                    area.size.set(0, 0);
                    area.update();
                    diagramCanvas.addChild(area);
                    wcardinalUi.DApplications.update(diagram);
                    // Select mode
                    this._selectMode = 1 /* EToolSelectMode.SELECT */;
                }
                const oldInteractionManager = this._interactionManager;
                if (oldInteractionManager) {
                    this._interactionManager = null;
                    oldInteractionManager.off(wcardinalUi.UtilPointerEvent.move, this._onDiagramMoveBound);
                    const onDiagramUpBound = this._onDiagramUpBound;
                    oldInteractionManager.off(wcardinalUi.UtilPointerEvent.up, onDiagramUpBound);
                    oldInteractionManager.off(wcardinalUi.UtilPointerEvent.upoutside, onDiagramUpBound);
                    oldInteractionManager.off(wcardinalUi.UtilPointerEvent.cancel, onDiagramUpBound);
                }
                const applicationLayer = wcardinalUi.DApplications.getLayer(diagram);
                if (applicationLayer) {
                    const newInteractionManager = applicationLayer.renderer.plugins.interaction;
                    this._interactionManager = newInteractionManager;
                    newInteractionManager.on(wcardinalUi.UtilPointerEvent.move, this._onDiagramMoveBound);
                    const onDiagramUpBound = this._onDiagramUpBound;
                    newInteractionManager.on(wcardinalUi.UtilPointerEvent.up, onDiagramUpBound);
                    newInteractionManager.on(wcardinalUi.UtilPointerEvent.upoutside, onDiagramUpBound);
                    newInteractionManager.on(wcardinalUi.UtilPointerEvent.cancel, onDiagramUpBound);
                }
            }
        }
        get selectArea() {
            let result = this._selectArea;
            if (result == null) {
                result = new EToolSelectArea();
                this._selectArea = result;
            }
            return result;
        }
        onDiagramMove(e) {
            const originalEvent = e.data.originalEvent;
            if (originalEvent.altKey) {
                return;
            }
            const diagram = this.diagram;
            const diagramCanvas = diagram.canvas;
            const diagramLayer = diagram.layer;
            const mode = this._selectMode;
            if (diagramCanvas && diagramLayer && mode !== 0 /* EToolSelectMode.NONE */) {
                const global = e.data.global;
                const onDownPoint = this._onDiagramDownPoint;
                if (mode === 1 /* EToolSelectMode.SELECT */) {
                    const area = this.selectArea;
                    const onMovePoint = diagramCanvas.toLocal(global, undefined, this._onDiagramMovePoint);
                    area.x = Math.min(onDownPoint.x, onMovePoint.x);
                    area.y = Math.min(onDownPoint.y, onMovePoint.y);
                    area.size.set(Math.max(onDownPoint.x, onMovePoint.x) - area.x, Math.max(onDownPoint.y, onMovePoint.y) - area.y);
                    area.update();
                    wcardinalUi.DApplications.update(diagram);
                }
                else {
                    const dx = global.x - onDownPoint.x;
                    const dy = global.y - onDownPoint.y;
                    if (1 <= Math.abs(dx) || 1 <= Math.abs(dy)) {
                        this._childSelectChild = null;
                    }
                }
            }
        }
        onDiagramUp(e) {
            const diagram = this.diagram;
            const diagramCanvas = diagram.canvas;
            const diagramLayer = diagram.layer;
            const mode = this._selectMode;
            const interactionManager = this._interactionManager;
            if (interactionManager) {
                this._interactionManager = null;
                interactionManager.off(wcardinalUi.UtilPointerEvent.move, this._onDiagramMoveBound);
                const onDiagramUpBound = this._onDiagramUpBound;
                interactionManager.off(wcardinalUi.UtilPointerEvent.up, onDiagramUpBound);
                interactionManager.off(wcardinalUi.UtilPointerEvent.upoutside, onDiagramUpBound);
                interactionManager.off(wcardinalUi.UtilPointerEvent.cancel, onDiagramUpBound);
            }
            if (diagramCanvas && diagramLayer && mode !== 0 /* EToolSelectMode.NONE */) {
                this._selectMode = 0 /* EToolSelectMode.NONE */;
                if (mode === 1 /* EToolSelectMode.SELECT */) {
                    const originalEvent = e.data.originalEvent;
                    const isAddMode = originalEvent.ctrlKey || originalEvent.shiftKey;
                    this.onDiagramSelectEnd(diagramCanvas, isAddMode);
                }
                else {
                    // Select the child
                    const selection = this.selection;
                    const childSelectChild = this._childSelectChild;
                    if (childSelectChild != null) {
                        this._childSelectChild = null;
                        const elapsedTime = Date.now() - this._childSelectTime;
                        if (elapsedTime < 333) {
                            selection.set(childSelectChild);
                        }
                    }
                    wcardinalUi.DApplications.update(diagram);
                }
            }
        }
        onDiagramSelectEnd(canvas, isAddMode) {
            const area = this.selectArea;
            const selection = this.selection;
            if (0 < area.size.x && 0 < area.size.y) {
                const areaRect = area.getBounds(false, this._selectAreaRect);
                const foundShapes = [];
                const layers = canvas.layer.children;
                for (let i = layers.length - 1; 0 <= i; --i) {
                    UtilShapeAreaSelect.findShapes(layers[i], areaRect, foundShapes);
                }
                if (isAddMode) {
                    if (0 < foundShapes.length) {
                        selection.addAll(foundShapes);
                    }
                }
                else {
                    if (0 < foundShapes.length || !selection.isEmpty()) {
                        selection.clearAndAddAll(foundShapes);
                    }
                }
            }
            else if (!isAddMode) {
                if (!selection.isEmpty()) {
                    selection.clear();
                }
            }
            canvas.removeChild(area);
            wcardinalUi.DApplications.update(canvas);
        }
        hitTest(global, canvas) {
            const layers = canvas.layer.children;
            for (let i = layers.length - 1; 0 <= i; --i) {
                const result = UtilHitTest.execute(global, layers[i]);
                if (result != null) {
                    return result;
                }
            }
            return null;
        }
        onDiagramKeydown(e) {
            if (wcardinalUi.UtilKeyboardEvent.isSelectAllKey(e)) {
                const canvas = this.diagram.canvas;
                if (canvas != null) {
                    const selection = this.selection;
                    selection.clear();
                    const layers = canvas.layer.children;
                    for (let i = 0, imax = layers.length; i < imax; ++i) {
                        const children = layers[i].children;
                        if (0 < children.length) {
                            selection.addAll(children);
                        }
                    }
                }
            }
        }
        get table() {
            let result = this._table;
            if (result == null) {
                result = this.newTable();
                this._table = result;
            }
            return result;
        }
        newTable() {
            return new wcardinalUi.DTable({
                weight: 1,
                width: "padding",
                columns: this.newColumnOptions(),
                data: {
                    filter: this.tableFilter
                }
            });
        }
        get tableFilter() {
            let result = this._tableFilter;
            if (result == null) {
                result = this.newTableFilter();
                this._tableFilter = result;
            }
            return result;
        }
        newTableFilter() {
            return {
                word: "",
                test(row) {
                    const word = this.word;
                    return (word.length <= 0 ||
                        0 <= row.id.indexOf(word) ||
                        0 <= row.value[0].indexOf(word) ||
                        0 <= row.value[1].indexOf(word));
                }
            };
        }
        get dialogSelectGraphic() {
            let result = this._dialogSelectGraphic;
            if (result == null) {
                result = this.newDialogSelectGraphic();
                this._dialogSelectGraphic = result;
            }
            return result;
        }
        newDialogSelectGraphic() {
            return this._category.get().then((category) => {
                if (this._options.controller.toThumbnail != null) {
                    const result = this.newDialogSelectGraphicImage();
                    result.categories = category.items;
                    return result;
                }
                else {
                    const result = this.newDialogSelectGraphicNoImage();
                    result.categories = category.items;
                    return result;
                }
            });
        }
        newDialogSelectGraphicNoImage() {
            return new wcardinalUi.DDialogSelect({
                controller: this._controller.graphic,
                on: {
                    select: (value) => {
                        this.onDialogSelectGraphicSelect(value);
                    }
                }
            });
        }
        newDialogSelectGraphicImage() {
            return newDialogSelectWithThumbnails(this._options.controller.graphic, this._controller.toThumbnail, (value) => {
                this.onDialogSelectGraphicSelect(value);
            });
        }
        onDialogSelectGraphicSelect(value) {
            this._controller.graphic.get(value.id).then((serialized) => {
                this.graphic = wcardinalUi.DDiagrams.toSerialized(serialized);
            });
        }
        get graphic() {
            return this._graphic;
        }
        set graphic(graphic) {
            this._graphic = graphic;
            const diagram = this.diagram;
            if (graphic != null) {
                diagram.set(graphic);
            }
            else {
                diagram.set(null);
            }
            this._appliedValues.clear();
            this.tester = undefined;
        }
        get dialogSelectMapping() {
            let result = this._dialogSelectTester;
            if (result == null) {
                result = this.newDialogSelectMapping();
                this._dialogSelectTester = result;
            }
            return result;
        }
        newDialogSelectMapping() {
            const controller = this._controller;
            return new wcardinalUi.DDialogSelect({
                controller: {
                    search: (word) => {
                        const graphic = this._graphic;
                        if (graphic) {
                            return controller.graphicTester.search(graphic.name, word);
                        }
                        return Promise.resolve([]);
                    }
                },
                on: {
                    select: (selected) => {
                        controller.graphicTester.get(selected.id).then((serialized) => {
                            const graphic = this._graphic;
                            if (graphic) {
                                this.tester = toGraphicTesterSerialized(serialized);
                            }
                        });
                    }
                }
            });
        }
        get dialogDiscard() {
            let result = this._dialogDiscard;
            if (result == null) {
                result = new wcardinalUi.DDialogConfirmDiscard();
                this._dialogDiscard = result;
            }
            return result;
        }
        get dialogCreate() {
            let result = this._dialogCreate;
            if (result == null) {
                result = this.newDialogCreate();
                this._dialogCreate = result;
            }
            return result;
        }
        newDialogCreate() {
            const result = new wcardinalUi.DDialogInputText({
                on: {
                    open: () => {
                        result.value = this._theme.newDialogCreateTextValue();
                    },
                    ok: (value) => {
                        const graphic = this._graphic;
                        if (graphic) {
                            this.tester = newGraphicTester(value, graphic);
                        }
                    }
                }
            });
            return result;
        }
        get tester() {
            return this._tester;
        }
        set tester(tester) {
            this._isChanged = false;
            const inputName = this.inputName.input;
            this._tester = tester;
            inputName.value = tester ? tester.name : "";
            this.onDiagramSelectionChange();
            this.onChange();
            this.toMappingsDirty();
        }
        get isNew() {
            const tester = this._tester;
            return tester != null && tester.id == null;
        }
        get isChanged() {
            return this._isChanged || this.isNew;
        }
        onChange() {
            const hasNoGraphc = this._graphic == null;
            const hasNoMapping = this._tester == null;
            const hasNoChanges = !this.isChanged;
            const isNotEditable = !this._isEditable;
            this.table.state.isDisabled = hasNoMapping;
            this.tableFilterInput.state.isDisabled = hasNoMapping;
            this.inputName.state.isDisabled = hasNoMapping || isNotEditable;
            this.toolFileButtonCreate.state.isDisabled = hasNoGraphc || isNotEditable;
            this.toolFileButtonOpen.state.isDisabled = hasNoGraphc;
            this.toolFileButtonUpload.state.isDisabled = hasNoMapping || isNotEditable;
            this.toolFileButtonDownload.state.isDisabled = hasNoMapping;
            this.toolFileButtonSave.state.isDisabled = hasNoMapping || hasNoChanges || isNotEditable;
            this.toolFileButtonDelete.state.isDisabled = hasNoMapping || isNotEditable;
        }
        evaluate(expression) {
            return Function(`try { return (${expression}); } catch( e ) { return 0; }`)();
        }
        onMappingsChange() {
            const tester = this._tester;
            if (tester) {
                const mappings = tester.mappings;
                const diagram = this.diagram;
                const canvas = diagram.canvas;
                if (canvas) {
                    let isChanged = false;
                    const layers = canvas.layer.children;
                    for (let i = 0, imax = layers.length; i < imax; ++i) {
                        if (this.applyMappings(layers[i].children, mappings, null)) {
                            isChanged = true;
                        }
                    }
                    if (isChanged) {
                        wcardinalUi.DApplications.update(diagram);
                    }
                }
            }
        }
        applyMappings(shapes, mappings, dataShape) {
            let isChanged = false;
            for (let i = 0, imax = shapes.length; i < imax; ++i) {
                const shape = shapes[i];
                // Apply the mappings
                const uuid = (dataShape || shape).uuid;
                const mapping = mappings.get(uuid);
                if (mapping) {
                    const data = shape.data;
                    for (let j = 0, jmax = data.size(); j < jmax; ++j) {
                        const dataValue = data.get(j);
                        if (dataValue != null && this.applyMapping(dataValue, mapping[dataValue.id])) {
                            isChanged = true;
                        }
                    }
                }
                // Children
                if (this.applyMappings(shape.children, mappings, this.toDataShape(dataShape, shape))) {
                    isChanged = true;
                }
            }
            // Done
            return isChanged;
        }
        applyMapping(dataValue, expression) {
            if (expression != null) {
                const expressionMap = this._expressionMap;
                if (expressionMap.has(expression)) {
                    return this.applyMappingIfChanged(dataValue, expressionMap.get(expression));
                }
                else if (0 < expression.length) {
                    try {
                        const evaluated = this.evaluate(expression);
                        expressionMap.set(expression, evaluated);
                        return this.applyMappingIfChanged(dataValue, evaluated);
                    }
                    catch (_a) {
                        // DO NOTHING
                    }
                }
            }
            return false;
        }
        applyMappingIfChanged(dataValue, value) {
            const appliedValues = this._appliedValues;
            if (appliedValues.has(dataValue)) {
                const appliedValue = appliedValues.get(dataValue);
                if (appliedValue !== value) {
                    appliedValues.set(dataValue, value);
                    dataValue.value = value;
                    return true;
                }
            }
            else {
                appliedValues.set(dataValue, value);
                dataValue.value = value;
                return true;
            }
            return false;
        }
        toDirty() {
            if (!this._isChanged) {
                this._isChanged = true;
                this.onChange();
            }
        }
        toMappingsDirty() {
            this._isMappingsDirty = true;
        }
        getFilename() {
            const name = this.inputName.input.value.toLowerCase();
            const date = UtilDate.format(Date.now());
            return `graphic-tester-${name}-${date}.csv`;
        }
        newColumnOptions() {
            const isEditable = this._isEditable;
            const theme = this._theme;
            return [
                {
                    type: "TEXT",
                    label: theme.getTableColumnDataLabel(),
                    editable: false,
                    sortable: true,
                    getter: (row) => {
                        return row.id;
                    },
                    setter: (row, index, value) => {
                        row.id = value;
                        this.toDirty();
                    }
                },
                {
                    type: "TEXT",
                    label: theme.getTableColumnValueLabel(),
                    align: "LEFT",
                    editable: isEditable,
                    sortable: true,
                    formatter: (value) => {
                        return value || "";
                    },
                    getter: (row) => {
                        return row.value;
                    },
                    setter: (row, index, value) => {
                        const tester = this._tester;
                        if (tester) {
                            const uuids = row.uuids;
                            const mappings = tester.mappings;
                            const id = row.id;
                            if (0 < value.length) {
                                for (let i = 0, imax = uuids.length; i < imax; ++i) {
                                    const uuid = uuids[i];
                                    let object = mappings.get(uuid);
                                    if (object == null) {
                                        object = {};
                                        mappings.set(uuid, object);
                                    }
                                    object[id] = value;
                                }
                            }
                            else {
                                for (let i = 0, imax = uuids.length; i < imax; ++i) {
                                    const uuid = uuids[i];
                                    const object = mappings.get(uuid);
                                    if (object != null) {
                                        delete object[id];
                                    }
                                }
                            }
                        }
                        row.value = value;
                        this.toDirty();
                        this.toMappingsDirty();
                    }
                }
            ];
        }
        toTheme(options) {
            const theme = options === null || options === void 0 ? void 0 : options.theme;
            if (theme) {
                if (wcardinalUi.isString(theme)) {
                    return wcardinalUi.DThemes.getInstance().get(theme);
                }
                return theme;
            }
            return this.getThemeDefault();
        }
        getThemeDefault() {
            return wcardinalUi.DThemes.getInstance().get(this.getType());
        }
        getType() {
            return "FGraphicTester";
        }
    }

    class FGraphicViewer {
        constructor(options) {
            var _a, _b;
            // Options
            this._options = options;
            const theme = this.toTheme(options);
            this._theme = theme;
            const margin = (_a = options.margin) !== null && _a !== void 0 ? _a : theme.getMargin();
            this._margin = margin;
            const icons = theme.getIconBuilder().build();
            this._icons = icons;
            this._category = new UtilCanvasCategory((_b = options.canvas) === null || _b === void 0 ? void 0 : _b.category);
            // Application
            const application = new wcardinalUi.DApplication(options.application);
            this._application = application;
            const stage = application.stage;
            // Diagram
            const diagram = this.diagram;
            stage.addChild(diagram);
            // Header
            const header = this.header;
            if (header != null) {
                stage.addChild(header);
            }
            // View operations
            const button = options.button;
            if (button == null || button.view !== false) {
                stage.addChild(this.layoutViewButton);
            }
        }
        get application() {
            return this._application;
        }
        get diagram() {
            let result = this._diagram;
            if (result == null) {
                result = this.newDiagram();
                this._diagram = result;
            }
            return result;
        }
        newDiagram() {
            const controller = this._options.controller;
            return new wcardinalUi.DDiagram({
                x: 0,
                y: 0,
                width: "100%",
                height: "100%",
                outline: {
                    color: null
                },
                controller: controller.graphic,
                data: {
                    mapper: this.newDataMapper(),
                    remote: {
                        controller: controller.remote
                    }
                }
            });
        }
        get header() {
            let result = this._header;
            if (result === undefined) {
                result = this.newHeader();
                this._header = result;
            }
            return result;
        }
        newHeader() {
            const header = this._options.header;
            if (header != null) {
                const result = header(this.newToolFileButtons());
                if (result != null) {
                    const margin = this._margin;
                    result.x = margin;
                    result.y = margin;
                    result.setWidth((p) => p - 2 * margin);
                    return result;
                }
            }
            return null;
        }
        newToolFileButtons() {
            const result = [];
            const button = this._options.button;
            if (button == null || button.open !== false) {
                result.push(this.toolFileButtonGraphicOpen);
            }
            return result;
        }
        get toolFileButtonGraphicOpen() {
            let result = this._toolFileButtonGraphicOpen;
            if (result == null) {
                result = this.newToolFileButtonGraphicOpen();
                this._toolFileButtonGraphicOpen = result;
            }
            return result;
        }
        newToolFileButtonGraphicOpen() {
            const theme = this._theme;
            return new wcardinalUi.DButton({
                image: {
                    source: this._icons.open
                },
                title: theme.getToolFileButtonGraphicOpenTitle(),
                shortcut: theme.getToolFileButtonGraphicOpenShortcut(),
                theme: theme.getToolFileButtonGraphicTheme(),
                on: {
                    active: (emitter) => {
                        this.onToolFileButtonGraphicOpenActive(emitter);
                    }
                }
            });
        }
        onToolFileButtonGraphicOpenActive(opener) {
            this.dialogSelect.then((dialogSelect) => {
                dialogSelect.open(opener);
            });
        }
        get layoutViewButton() {
            let result = this._layoutViewButton;
            if (result == null) {
                result = this.newLayoutViewButton();
                this._layoutViewButton = result;
            }
            return result;
        }
        newLayoutViewButton() {
            const margin = this._margin;
            const position = (p, s) => p - s - margin;
            return new wcardinalUi.DLayoutHorizontal({
                x: position,
                y: position,
                width: "auto",
                height: "auto",
                margin: 0,
                children: this.newViewButtons()
            });
        }
        newViewButtons() {
            return [
                this.viewButtonZoomOut,
                this.viewButtonZoomIn,
                this.viewButtonReset,
                this.viewButtonFit
            ];
        }
        get viewButtonZoomOut() {
            let result = this._viewButtonZoomOut;
            if (result == null) {
                result = this.newViewButtonZoomOut();
                this._viewButtonZoomOut = result;
            }
            return result;
        }
        newViewButtonZoomOut() {
            const theme = this._theme;
            return new wcardinalUi.DButton({
                image: {
                    source: this._icons.view_zoom_out
                },
                title: theme.getViewButtonZoomOutTitle(),
                shortcut: theme.getViewButtonZoomOutShortcut(),
                theme: theme.getViewButtonTheme(),
                on: {
                    active: () => {
                        this.diagram.view.zoomOut();
                    }
                }
            });
        }
        get viewButtonZoomIn() {
            let result = this._viewButtonZoomIn;
            if (result == null) {
                result = this.newViewButtonZoomIn();
                this._viewButtonZoomIn = result;
            }
            return result;
        }
        newViewButtonZoomIn() {
            const theme = this._theme;
            return new wcardinalUi.DButton({
                image: {
                    source: this._icons.view_zoom_in
                },
                title: theme.getViewButtonZoomInTitle(),
                shortcut: theme.getViewButtonZoomInShortcut(),
                shortcuts: theme.getViewButtonZoomInShortcuts(),
                theme: theme.getViewButtonTheme(),
                on: {
                    active: () => {
                        this.diagram.view.zoomIn();
                    }
                }
            });
        }
        get viewButtonReset() {
            let result = this._viewButtonReset;
            if (result == null) {
                result = this.newViewButtonReset();
                this._viewButtonReset = result;
            }
            return result;
        }
        newViewButtonReset() {
            const theme = this._theme;
            return new wcardinalUi.DButton({
                image: {
                    source: this._icons.view_reset
                },
                title: theme.getViewButtonResetTitle(),
                shortcut: theme.getViewButtonResetShortcut(),
                theme: theme.getViewButtonTheme(),
                on: {
                    active: () => {
                        this.diagram.view.reset();
                    }
                }
            });
        }
        get viewButtonFit() {
            let result = this._viewButtonFit;
            if (result == null) {
                result = this.newViewButtonFit();
                this._viewButtonFit = result;
            }
            return result;
        }
        newViewButtonFit() {
            const theme = this._theme;
            return new wcardinalUi.DButton({
                image: {
                    source: this._icons.view_fit
                },
                title: theme.getViewButtonFitTitle(),
                shortcut: theme.getViewButtonFitShortcut(),
                theme: theme.getViewButtonTheme(),
                on: {
                    active: () => {
                        this.diagram.view.fit();
                    }
                }
            });
        }
        get dialogSelect() {
            let result = this._dialogSelect;
            if (result == null) {
                result = this.newDialogSelect();
                this._dialogSelect = result;
            }
            return result;
        }
        newDialogSelect() {
            return this._category.get().then((category) => {
                if (this._options.controller.toThumbnail != null) {
                    const result = this.newDialogSelectImage();
                    result.categories = category.items;
                    return result;
                }
                else {
                    const result = this.newDialogSelectNoImage();
                    result.categories = category.items;
                    return result;
                }
            });
        }
        newDialogSelectNoImage() {
            return new wcardinalUi.DDialogSelect({
                controller: this._options.controller.graphic,
                on: {
                    select: (value) => {
                        this.onDialogSelectSelect(value);
                    }
                }
            });
        }
        newDialogSelectImage() {
            const controller = this._options.controller;
            return newDialogSelectWithThumbnails(controller.graphic, controller.toThumbnail, (value) => {
                this.onDialogSelectSelect(value);
            });
        }
        onDialogSelectSelect(value) {
            this._options.controller.graphic.get(value.id).then((serialized) => {
                this.diagram.set(wcardinalUi.DDiagrams.toSerialized(serialized));
            });
        }
        newDataMapper() {
            return undefined;
        }
        toTheme(options) {
            const theme = options === null || options === void 0 ? void 0 : options.theme;
            if (theme) {
                if (wcardinalUi.isString(theme)) {
                    return wcardinalUi.DThemes.getInstance().get(theme);
                }
                return theme;
            }
            return this.getThemeDefault();
        }
        getThemeDefault() {
            return wcardinalUi.DThemes.getInstance().get(this.getType());
        }
        getType() {
            return "FGraphicViewer";
        }
    }

    var geditor = {
        __proto__: null,
        ECommandChartAxisXPadding: ECommandChartAxisXPadding,
        ECommandChartAxisYPadding: ECommandChartAxisYPadding,
        ECommandChartTickXMajorCount: ECommandChartTickXMajorCount,
        ECommandChartTickXMinorCount: ECommandChartTickXMinorCount,
        ECommandChartTickYMajorCount: ECommandChartTickYMajorCount,
        ECommandChartTickYMinorCount: ECommandChartTickYMinorCount,
        ECommandComposition: ECommandComposition,
        ECommandDocumentAll: ECommandDocumentAll,
        ECommandDocumentBackground: ECommandDocumentBackground,
        ECommandDocumentCategory: ECommandDocumentCategory,
        ECommandDocumentCreate: ECommandDocumentCreate,
        ECommandDocumentDescription: ECommandDocumentDescription,
        ECommandDocumentHeight: ECommandDocumentHeight,
        ECommandDocumentLabel: ECommandDocumentLabel,
        ECommandDocumentName: ECommandDocumentName,
        ECommandDocumentOpen: ECommandDocumentOpen,
        ECommandDocumentSnapBringForward: ECommandDocumentSnapBringForward,
        ECommandDocumentSnapCreate: ECommandDocumentSnapCreate,
        ECommandDocumentSnapDelete: ECommandDocumentSnapDelete,
        ECommandDocumentSnapGridSize: ECommandDocumentSnapGridSize,
        ECommandDocumentSnapGridToggle: ECommandDocumentSnapGridToggle,
        ECommandDocumentSnapGridToggleVisibility: ECommandDocumentSnapGridToggleVisibility,
        ECommandDocumentSnapReplace: ECommandDocumentSnapReplace,
        ECommandDocumentSnapSendBackward: ECommandDocumentSnapSendBackward,
        ECommandDocumentSnapTargetToggle: ECommandDocumentSnapTargetToggle,
        ECommandDocumentSnapTargetToggleVisibility: ECommandDocumentSnapTargetToggleVisibility,
        ECommandDocumentSnapToggle: ECommandDocumentSnapToggle,
        ECommandDocumentSummary: ECommandDocumentSummary,
        ECommandDocumentWidth: ECommandDocumentWidth,
        ECommandLayerBringForward: ECommandLayerBringForward,
        ECommandLayerChange: ECommandLayerChange,
        ECommandLayerCreate: ECommandLayerCreate,
        ECommandLayerDelete: ECommandLayerDelete,
        ECommandLayerSendBackward: ECommandLayerSendBackward,
        ECommandShapeActionValueAdd: ECommandShapeActionValueAdd,
        ECommandShapeActionValueBringForward: ECommandShapeActionValueBringForward,
        ECommandShapeActionValueRemove: ECommandShapeActionValueRemove,
        ECommandShapeActionValueReplace: ECommandShapeActionValueReplace,
        ECommandShapeActionValueSendBackward: ECommandShapeActionValueSendBackward,
        ECommandShapeButtonLayerValueAdd: ECommandShapeButtonLayerValueAdd,
        ECommandShapeButtonLayerValueBringForward: ECommandShapeButtonLayerValueBringForward,
        ECommandShapeButtonLayerValueMargin: ECommandShapeButtonLayerValueMargin,
        ECommandShapeButtonLayerValueRemove: ECommandShapeButtonLayerValueRemove,
        ECommandShapeButtonLayerValueReplace: ECommandShapeButtonLayerValueReplace,
        ECommandShapeButtonLayerValueSendBackward: ECommandShapeButtonLayerValueSendBackward,
        ECommandShapeButtonPropertyIsActive: ECommandShapeButtonPropertyIsActive,
        ECommandShapeButtonPropertyIsGrouped: ECommandShapeButtonPropertyIsGrouped,
        ECommandShapeButtonPropertyIsToggle: ECommandShapeButtonPropertyIsToggle,
        ECommandShapeCreate: ECommandShapeCreate,
        ECommandShapeDataMappingValueAdd: ECommandShapeDataMappingValueAdd,
        ECommandShapeDataMappingValueBringForward: ECommandShapeDataMappingValueBringForward,
        ECommandShapeDataMappingValueRemove: ECommandShapeDataMappingValueRemove,
        ECommandShapeDataMappingValueReplace: ECommandShapeDataMappingValueReplace,
        ECommandShapeDataMappingValueSendBackward: ECommandShapeDataMappingValueSendBackward,
        ECommandShapeDataValueAdd: ECommandShapeDataValueAdd,
        ECommandShapeDataValueBringForward: ECommandShapeDataValueBringForward,
        ECommandShapeDataValueRemove: ECommandShapeDataValueRemove,
        ECommandShapeDataValueReplace: ECommandShapeDataValueReplace,
        ECommandShapeDataValueSendBackward: ECommandShapeDataValueSendBackward,
        ECommandShapeDelete: ECommandShapeDelete,
        ECommandShapeGroup: ECommandShapeGroup,
        ECommandShapeProperty: ECommandShapeProperty,
        ECommandShapePropertyAll: ECommandShapePropertyAll,
        ECommandShapePropertyCapability: ECommandShapePropertyCapability,
        ECommandShapePropertyCapabilityLock: ECommandShapePropertyCapabilityLock,
        ECommandShapePropertyCapabilityUnlock: ECommandShapePropertyCapabilityUnlock,
        ECommandShapePropertyCornerOff: ECommandShapePropertyCornerOff,
        ECommandShapePropertyCornerOn: ECommandShapePropertyCornerOn,
        ECommandShapePropertyCursor: ECommandShapePropertyCursor,
        ECommandShapePropertyFillColor: ECommandShapePropertyFillColor,
        ECommandShapePropertyFillEnable: ECommandShapePropertyFillEnable,
        ECommandShapePropertyFocusable: ECommandShapePropertyFocusable,
        ECommandShapePropertyId: ECommandShapePropertyId,
        ECommandShapePropertyImage: ECommandShapePropertyImage,
        ECommandShapePropertyImageClear: ECommandShapePropertyImageClear,
        ECommandShapePropertyImageFitTo: ECommandShapePropertyImageFitTo,
        ECommandShapePropertyInteractive: ECommandShapePropertyInteractive,
        ECommandShapePropertyLineHeadColor: ECommandShapePropertyLineHeadColor,
        ECommandShapePropertyLineHeadMargin: ECommandShapePropertyLineHeadMargin,
        ECommandShapePropertyLineHeadSizeX: ECommandShapePropertyLineHeadSizeX,
        ECommandShapePropertyLineHeadSizeY: ECommandShapePropertyLineHeadSizeY,
        ECommandShapePropertyLineHeadType: ECommandShapePropertyLineHeadType,
        ECommandShapePropertyLineTailColor: ECommandShapePropertyLineTailColor,
        ECommandShapePropertyLineTailMargin: ECommandShapePropertyLineTailMargin,
        ECommandShapePropertyLineTailSizeX: ECommandShapePropertyLineTailSizeX,
        ECommandShapePropertyLineTailSizeY: ECommandShapePropertyLineTailSizeY,
        ECommandShapePropertyLineTailType: ECommandShapePropertyLineTailType,
        ECommandShapePropertyPointsStyle: ECommandShapePropertyPointsStyle,
        ECommandShapePropertyPosition: ECommandShapePropertyPosition,
        ECommandShapePropertyPositionAndRotate: ECommandShapePropertyPositionAndRotate,
        ECommandShapePropertyPositionLeft: ECommandShapePropertyPositionLeft,
        ECommandShapePropertyPositionTop: ECommandShapePropertyPositionTop,
        ECommandShapePropertyPositionX: ECommandShapePropertyPositionX,
        ECommandShapePropertyPositionY: ECommandShapePropertyPositionY,
        ECommandShapePropertyRadius: ECommandShapePropertyRadius,
        ECommandShapePropertyRecursive: ECommandShapePropertyRecursive,
        ECommandShapePropertyRecursiveSimple: ECommandShapePropertyRecursiveSimple,
        ECommandShapePropertyRotation: ECommandShapePropertyRotation,
        ECommandShapePropertyShortcut: ECommandShapePropertyShortcut,
        ECommandShapePropertySizeX: ECommandShapePropertySizeX,
        ECommandShapePropertySizeY: ECommandShapePropertySizeY,
        ECommandShapePropertySkew: ECommandShapePropertySkew,
        ECommandShapePropertyStrokeAlign: ECommandShapePropertyStrokeAlign,
        ECommandShapePropertyStrokeColor: ECommandShapePropertyStrokeColor,
        ECommandShapePropertyStrokeEnable: ECommandShapePropertyStrokeEnable,
        ECommandShapePropertyStrokeSideOff: ECommandShapePropertyStrokeSideOff,
        ECommandShapePropertyStrokeSideOn: ECommandShapePropertyStrokeSideOn,
        ECommandShapePropertyStrokeStyle: ECommandShapePropertyStrokeStyle,
        ECommandShapePropertyStrokeWidth: ECommandShapePropertyStrokeWidth,
        ECommandShapePropertyTextAlignHorizontal: ECommandShapePropertyTextAlignHorizontal,
        ECommandShapePropertyTextAlignVertical: ECommandShapePropertyTextAlignVertical,
        ECommandShapePropertyTextClipping: ECommandShapePropertyTextClipping,
        ECommandShapePropertyTextColor: ECommandShapePropertyTextColor,
        ECommandShapePropertyTextDirection: ECommandShapePropertyTextDirection,
        ECommandShapePropertyTextFamily: ECommandShapePropertyTextFamily,
        ECommandShapePropertyTextFitting: ECommandShapePropertyTextFitting,
        ECommandShapePropertyTextOffsetHorizontal: ECommandShapePropertyTextOffsetHorizontal,
        ECommandShapePropertyTextOffsetVertical: ECommandShapePropertyTextOffsetVertical,
        ECommandShapePropertyTextOutlineColor: ECommandShapePropertyTextOutlineColor,
        ECommandShapePropertyTextOutlineEnable: ECommandShapePropertyTextOutlineEnable,
        ECommandShapePropertyTextOutlineWidth: ECommandShapePropertyTextOutlineWidth,
        ECommandShapePropertyTextPaddingHorizontal: ECommandShapePropertyTextPaddingHorizontal,
        ECommandShapePropertyTextPaddingVertical: ECommandShapePropertyTextPaddingVertical,
        ECommandShapePropertyTextSize: ECommandShapePropertyTextSize,
        ECommandShapePropertyTextSizeDelta: ECommandShapePropertyTextSizeDelta,
        ECommandShapePropertyTextSpacingHorizontal: ECommandShapePropertyTextSpacingHorizontal,
        ECommandShapePropertyTextSpacingVertical: ECommandShapePropertyTextSpacingVertical,
        ECommandShapePropertyTextStyle: ECommandShapePropertyTextStyle,
        ECommandShapePropertyTextValue: ECommandShapePropertyTextValue,
        ECommandShapePropertyTextWeight: ECommandShapePropertyTextWeight,
        ECommandShapePropertyTitle: ECommandShapePropertyTitle,
        ECommandShapeReplace: ECommandShapeReplace,
        ECommandShapeReplaceOne: ECommandShapeReplaceOne,
        ECommandShapeSelect: ECommandShapeSelect,
        ECommandShapeTableColumnValueAdd: ECommandShapeTableColumnValueAdd,
        ECommandShapeTableColumnValueBringForward: ECommandShapeTableColumnValueBringForward,
        ECommandShapeTableColumnValueRemove: ECommandShapeTableColumnValueRemove,
        ECommandShapeTableColumnValueReplace: ECommandShapeTableColumnValueReplace,
        ECommandShapeTableColumnValueSendBackward: ECommandShapeTableColumnValueSendBackward,
        ECommandShapeTableRowHeight: ECommandShapeTableRowHeight,
        ECommandShapeTableRowSelectionType: ECommandShapeTableRowSelectionType,
        ECommandShapeTreeBringForward: ECommandShapeTreeBringForward,
        ECommandShapeTreeBringToFront: ECommandShapeTreeBringToFront,
        ECommandShapeTreeSendBackward: ECommandShapeTreeSendBackward,
        ECommandShapeTreeSendToBack: ECommandShapeTreeSendToBack,
        ECommandShapeUngroup: ECommandShapeUngroup,
        EDialogAction: EDialogAction,
        EDialogActionExtension: EDialogActionExtension,
        EDialogActionExtensionContainer: EDialogActionExtensionContainer,
        EDialogDataMappingValue: EDialogDataMappingValue,
        EDialogDataValue: EDialogDataValue,
        EDialogLayer: EDialogLayer,
        EDialogLayerValue: EDialogLayerValue,
        EDialogLayerValueBackground: EDialogLayerValueBackground,
        EDialogProcessing: EDialogProcessing,
        EDialogShapeButtonLayerValue: EDialogShapeButtonLayerValue,
        EDialogSnap: EDialogSnap,
        EDialogTableColumn: EDialogTableColumn,
        EEDITOR_BUTTON_COUNT: EEDITOR_BUTTON_COUNT,
        EEditorAction: EEditorAction,
        EEditorCanvas: EEditorCanvas,
        EEditorCoordinate: EEditorCoordinate,
        EEditorData: EEditorData,
        EEditorDataMapping: EEditorDataMapping,
        EEditorLayer: EEditorLayer,
        EEditorLayerItem: EEditorLayerItem,
        EEditorSearch: EEditorSearch,
        EEditorShape: EEditorShape,
        EEditorShapeButton: EEditorShapeButton,
        EEditorShapeButtonLayer: EEditorShapeButtonLayer,
        EEditorShapeChartLine: EEditorShapeChartLine,
        EEditorShapeTable: EEditorShapeTable,
        EEditorSnap: EEditorSnap,
        EEditorText: EEditorText,
        EEditorTree: EEditorTree,
        EEditorTreeSelection: EEditorTreeSelection,
        EEditorValidation: EEditorValidation,
        EShapeActionExtensionInputType: EShapeActionExtensionInputType,
        EShapeActionExtensions: EShapeActionExtensions,
        EShapeButtonLayer: EShapeButtonLayer,
        EShapeButtonLayerButtonValue: EShapeButtonLayerButtonValue,
        EShapeButtonLayerButtonValueContainer: EShapeButtonLayerButtonValueContainer,
        EShapeButtonLayerIds: EShapeButtonLayerIds,
        EShapeButtonLayers: EShapeButtonLayers,
        EShapeButtons: EShapeButtons,
        EShapeChartAxes: EShapeChartAxes,
        EShapeChartAxis: EShapeChartAxis,
        EShapeChartAxisX: EShapeChartAxisX,
        EShapeChartAxisY: EShapeChartAxisY,
        EShapeChartLine: EShapeChartLine,
        EShapeChartLineActionRuntime: EShapeChartLineActionRuntime,
        EShapeChartLineIds: EShapeChartLineIds,
        EShapeChartLineRuntime: EShapeChartLineRuntime,
        EShapeChartLines: EShapeChartLines,
        EShapeChartTick: EShapeChartTick,
        EShapeChartTickMajor: EShapeChartTickMajor,
        EShapeChartTickMinor: EShapeChartTickMinor,
        EShapeEmbeddedAcceptorEdges: EShapeEmbeddedAcceptorEdges,
        EShapeExtensionFactories: EShapeExtensionFactories,
        EShapeExtensions: EShapeExtensions,
        EShapeInputs: EShapeInputs,
        EShapeTable: EShapeTable,
        EShapeTableActionRuntime: EShapeTableActionRuntime,
        EShapeTableBody: EShapeTableBody,
        EShapeTableBodyRuntime: EShapeTableBodyRuntime,
        EShapeTableCell: EShapeTableCell,
        EShapeTableCellActionValueChangeColor: EShapeTableCellActionValueChangeColor,
        EShapeTableColumn: EShapeTableColumn,
        EShapeTableColumnValue: EShapeTableColumnValue,
        EShapeTableColumnValueBody: EShapeTableColumnValueBody,
        EShapeTableColumnValueHeader: EShapeTableColumnValueHeader,
        EShapeTableColumnValueRuntime: EShapeTableColumnValueRuntime,
        EShapeTableColumnValueType: EShapeTableColumnValueType,
        EShapeTableHeader: EShapeTableHeader,
        EShapeTableHeaderRuntime: EShapeTableHeaderRuntime,
        EShapeTableIds: EShapeTableIds,
        EShapeTableRow: EShapeTableRow,
        EShapeTableRowSelection: EShapeTableRowSelection,
        EShapeTableRowSelectionType: EShapeTableRowSelectionType,
        EShapeTableRuntime: EShapeTableRuntime,
        EShapeTables: EShapeTables,
        EToolGroupImpl: EToolGroupImpl,
        EToolImpl: EToolImpl,
        EToolSelect: EToolSelect,
        EToolSelectArea: EToolSelectArea,
        get EToolSelectMode () { return EToolSelectMode; },
        EToolSelectModifier: EToolSelectModifier,
        EToolSelectModifierContainer: EToolSelectModifierContainer,
        EToolSelectModifierHitArea: EToolSelectModifierHitArea,
        EToolSelectSelection: EToolSelectSelection,
        EToolSelectSelectionUpdatedPart: EToolSelectSelectionUpdatedPart,
        EToolShapeAcceptorEdge: EToolShapeAcceptorEdge,
        EToolShapeAcceptorEdgeRenderer: EToolShapeAcceptorEdgeRenderer,
        EToolShapeCreate: EToolShapeCreate,
        EToolShapeCreateElbowConnector: EToolShapeCreateElbowConnector,
        EToolShapeCreateLine: EToolShapeCreateLine,
        EToolShapeCreateLineConnector: EToolShapeCreateLineConnector,
        EToolShapeCreateLineConnectorPhase: EToolShapeCreateLineConnectorPhase,
        EToolShapeEditLine: EToolShapeEditLine,
        EToolShapeEditLineBase: EToolShapeEditLineBase,
        EToolShapeEditLineConnector: EToolShapeEditLineConnector,
        EToolShapeEditLineHitArea: EToolShapeEditLineHitArea,
        FGraphicEditor: FGraphicEditor,
        FGraphicTester: FGraphicTester,
        FGraphicViewer: FGraphicViewer,
        UtilAjax: UtilAjax,
        UtilCanvas: UtilCanvas,
        UtilCanvasCategory: UtilCanvasCategory,
        UtilCsv: UtilCsv,
        UtilCsvState: UtilCsvState,
        UtilDataValues: UtilDataValues,
        UtilDate: UtilDate,
        UtilHitTest: UtilHitTest,
        UtilShapeAreaSelect: UtilShapeAreaSelect,
        UtilShapeConnectorTransformData: UtilShapeConnectorTransformData,
        UtilShapeConnectorTransforms: UtilShapeConnectorTransforms,
        UtilShapeDeleter: UtilShapeDeleter,
        UtilShapeSearch: UtilShapeSearch,
        UtilShapeTransforms: UtilShapeTransforms,
        getDialogSelectThumbnailNotFound: getDialogSelectThumbnailNotFound,
        getDialogSelectThumbnailSize: getDialogSelectThumbnailSize,
        getShapeTypeTheme: getShapeTypeTheme,
        loadShapeExtensionButton: loadShapeExtensionButton,
        loadShapeExtensionButtonLayer: loadShapeExtensionButtonLayer,
        loadShapeExtensionChartLine: loadShapeExtensionChartLine,
        loadShapeExtensionEmbeddedAcceptorEdge: loadShapeExtensionEmbeddedAcceptorEdge,
        loadShapeExtensionInput: loadShapeExtensionInput,
        loadShapeExtensionTable: loadShapeExtensionTable,
        newDialogSelectWithThumbnails: newDialogSelectWithThumbnails,
        newDialogSelectWithThumbnailsOptions: newDialogSelectWithThumbnailsOptions,
        newDialogTHumbnailNotFound: newDialogTHumbnailNotFound,
        newGraphicTester: newGraphicTester,
        setDialogSelectThumbnailSize: setDialogSelectThumbnailSize,
        toGraphicTesterObject: toGraphicTesterObject,
        toGraphicTesterSerialized: toGraphicTesterSerialized,
        toGraphicTesterSimple: toGraphicTesterSimple,
        toShapeLabel: toShapeLabel,
        toShapeTypeLabel: toShapeTypeLabel
    };

    const global = window;
    global.wcardinal = global.wcardinal || {};
    global.wcardinal.geditor = geditor;

})(wcardinal.ui, PIXI);
